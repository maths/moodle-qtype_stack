{"version":3,"file":"js-yaml-lazy.min.js","sources":["../src/js-yaml-lazy.js"],"sourcesContent":["\n/*! js-yaml 4.1.0 https://github.com/nodeca/js-yaml @license MIT */\n\n  function isNothing(subject) {\n    return (typeof subject === 'undefined') || (subject === null);\n  }\n\n\n  function isObject(subject) {\n    return (typeof subject === 'object') && (subject !== null);\n  }\n\n\n  function toArray(sequence) {\n    if (Array.isArray(sequence)) return sequence;\n    else if (isNothing(sequence)) return [];\n\n    return [ sequence ];\n  }\n\n\n  function extend(target, source) {\n    var index, length, key, sourceKeys;\n\n    if (source) {\n      sourceKeys = Object.keys(source);\n\n      for (index = 0, length = sourceKeys.length; index < length; index += 1) {\n        key = sourceKeys[index];\n        target[key] = source[key];\n      }\n    }\n\n    return target;\n  }\n\n\n  function repeat(string, count) {\n    var result = '', cycle;\n\n    for (cycle = 0; cycle < count; cycle += 1) {\n      result += string;\n    }\n\n    return result;\n  }\n\n\n  function isNegativeZero(number) {\n    return (number === 0) && (Number.NEGATIVE_INFINITY === 1 / number);\n  }\n\n\n  var isNothing_1      = isNothing;\n  var isObject_1       = isObject;\n  var toArray_1        = toArray;\n  var repeat_1         = repeat;\n  var isNegativeZero_1 = isNegativeZero;\n  var extend_1         = extend;\n\n  var common = {\n    isNothing: isNothing_1,\n    isObject: isObject_1,\n    toArray: toArray_1,\n    repeat: repeat_1,\n    isNegativeZero: isNegativeZero_1,\n    extend: extend_1\n  };\n\n  // YAML error class. http://stackoverflow.com/questions/8458984\n\n\n  function formatError(exception, compact) {\n    var where = '', message = exception.reason || '(unknown reason)';\n\n    if (!exception.mark) return message;\n\n    if (exception.mark.name) {\n      where += 'in \"' + exception.mark.name + '\" ';\n    }\n\n    where += '(' + (exception.mark.line + 1) + ':' + (exception.mark.column + 1) + ')';\n\n    if (!compact && exception.mark.snippet) {\n      where += '\\n\\n' + exception.mark.snippet;\n    }\n\n    return message + ' ' + where;\n  }\n\n\n  function YAMLException$1(reason, mark) {\n    // Super constructor\n    Error.call(this);\n\n    this.name = 'YAMLException';\n    this.reason = reason;\n    this.mark = mark;\n    this.message = formatError(this, false);\n\n    // Include stack trace in error object\n    if (Error.captureStackTrace) {\n      // Chrome and NodeJS\n      Error.captureStackTrace(this, this.constructor);\n    } else {\n      // FF, IE 10+ and Safari 6+. Fallback for others\n      this.stack = (new Error()).stack || '';\n    }\n  }\n\n\n  // Inherit from Error\n  YAMLException$1.prototype = Object.create(Error.prototype);\n  YAMLException$1.prototype.constructor = YAMLException$1;\n\n\n  YAMLException$1.prototype.toString = function toString(compact) {\n    return this.name + ': ' + formatError(this, compact);\n  };\n\n\n  var exception = YAMLException$1;\n\n  // get snippet for a single line, respecting maxLength\n  function getLine(buffer, lineStart, lineEnd, position, maxLineLength) {\n    var head = '';\n    var tail = '';\n    var maxHalfLength = Math.floor(maxLineLength / 2) - 1;\n\n    if (position - lineStart > maxHalfLength) {\n      head = ' ... ';\n      lineStart = position - maxHalfLength + head.length;\n    }\n\n    if (lineEnd - position > maxHalfLength) {\n      tail = ' ...';\n      lineEnd = position + maxHalfLength - tail.length;\n    }\n\n    return {\n      str: head + buffer.slice(lineStart, lineEnd).replace(/\\t/g, 'â†’') + tail,\n      pos: position - lineStart + head.length // relative position\n    };\n  }\n\n\n  function padStart(string, max) {\n    return common.repeat(' ', max - string.length) + string;\n  }\n\n\n  function makeSnippet(mark, options) {\n    options = Object.create(options || null);\n\n    if (!mark.buffer) return null;\n\n    if (!options.maxLength) options.maxLength = 79;\n    if (typeof options.indent      !== 'number') options.indent      = 1;\n    if (typeof options.linesBefore !== 'number') options.linesBefore = 3;\n    if (typeof options.linesAfter  !== 'number') options.linesAfter  = 2;\n\n    var re = /\\r?\\n|\\r|\\0/g;\n    var lineStarts = [ 0 ];\n    var lineEnds = [];\n    var match;\n    var foundLineNo = -1;\n\n    while ((match = re.exec(mark.buffer))) {\n      lineEnds.push(match.index);\n      lineStarts.push(match.index + match[0].length);\n\n      if (mark.position <= match.index && foundLineNo < 0) {\n        foundLineNo = lineStarts.length - 2;\n      }\n    }\n\n    if (foundLineNo < 0) foundLineNo = lineStarts.length - 1;\n\n    var result = '', i, line;\n    var lineNoLength = Math.min(mark.line + options.linesAfter, lineEnds.length).toString().length;\n    var maxLineLength = options.maxLength - (options.indent + lineNoLength + 3);\n\n    for (i = 1; i <= options.linesBefore; i++) {\n      if (foundLineNo - i < 0) break;\n      line = getLine(\n        mark.buffer,\n        lineStarts[foundLineNo - i],\n        lineEnds[foundLineNo - i],\n        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo - i]),\n        maxLineLength\n      );\n      result = common.repeat(' ', options.indent) + padStart((mark.line - i + 1).toString(), lineNoLength) +\n        ' | ' + line.str + '\\n' + result;\n    }\n\n    line = getLine(mark.buffer, lineStarts[foundLineNo], lineEnds[foundLineNo], mark.position, maxLineLength);\n    result += common.repeat(' ', options.indent) + padStart((mark.line + 1).toString(), lineNoLength) +\n      ' | ' + line.str + '\\n';\n    result += common.repeat('-', options.indent + lineNoLength + 3 + line.pos) + '^' + '\\n';\n\n    for (i = 1; i <= options.linesAfter; i++) {\n      if (foundLineNo + i >= lineEnds.length) break;\n      line = getLine(\n        mark.buffer,\n        lineStarts[foundLineNo + i],\n        lineEnds[foundLineNo + i],\n        mark.position - (lineStarts[foundLineNo] - lineStarts[foundLineNo + i]),\n        maxLineLength\n      );\n      result += common.repeat(' ', options.indent) + padStart((mark.line + i + 1).toString(), lineNoLength) +\n        ' | ' + line.str + '\\n';\n    }\n\n    return result.replace(/\\n$/, '');\n  }\n\n\n  var snippet = makeSnippet;\n\n  var TYPE_CONSTRUCTOR_OPTIONS = [\n    'kind',\n    'multi',\n    'resolve',\n    'construct',\n    'instanceOf',\n    'predicate',\n    'represent',\n    'representName',\n    'defaultStyle',\n    'styleAliases'\n  ];\n\n  var YAML_NODE_KINDS = [\n    'scalar',\n    'sequence',\n    'mapping'\n  ];\n\n  function compileStyleAliases(map) {\n    var result = {};\n\n    if (map !== null) {\n      Object.keys(map).forEach(function (style) {\n        map[style].forEach(function (alias) {\n          result[String(alias)] = style;\n        });\n      });\n    }\n\n    return result;\n  }\n\n  function Type$1(tag, options) {\n    options = options || {};\n\n    Object.keys(options).forEach(function (name) {\n      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {\n        throw new exception('Unknown option \"' + name + '\" is met in definition of \"' + tag + '\" YAML type.');\n      }\n    });\n\n    // TODO: Add tag format check.\n    this.options       = options; // keep original options in case user wants to extend this type later\n    this.tag           = tag;\n    this.kind          = options['kind']          || null;\n    this.resolve       = options['resolve']       || function () { return true; };\n    this.construct     = options['construct']     || function (data) { return data; };\n    this.instanceOf    = options['instanceOf']    || null;\n    this.predicate     = options['predicate']     || null;\n    this.represent     = options['represent']     || null;\n    this.representName = options['representName'] || null;\n    this.defaultStyle  = options['defaultStyle']  || null;\n    this.multi         = options['multi']         || false;\n    this.styleAliases  = compileStyleAliases(options['styleAliases'] || null);\n\n    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {\n      throw new exception('Unknown kind \"' + this.kind + '\" is specified for \"' + tag + '\" YAML type.');\n    }\n  }\n\n  var type = Type$1;\n\n  /*eslint-disable max-len*/\n\n\n\n\n\n  function compileList(schema, name) {\n    var result = [];\n\n    schema[name].forEach(function (currentType) {\n      var newIndex = result.length;\n\n      result.forEach(function (previousType, previousIndex) {\n        if (previousType.tag === currentType.tag &&\n            previousType.kind === currentType.kind &&\n            previousType.multi === currentType.multi) {\n\n          newIndex = previousIndex;\n        }\n      });\n\n      result[newIndex] = currentType;\n    });\n\n    return result;\n  }\n\n\n  function compileMap(/* lists... */) {\n    var result = {\n          scalar: {},\n          sequence: {},\n          mapping: {},\n          fallback: {},\n          multi: {\n            scalar: [],\n            sequence: [],\n            mapping: [],\n            fallback: []\n          }\n        }, index, length;\n\n    function collectType(type) {\n      if (type.multi) {\n        result.multi[type.kind].push(type);\n        result.multi['fallback'].push(type);\n      } else {\n        result[type.kind][type.tag] = result['fallback'][type.tag] = type;\n      }\n    }\n\n    for (index = 0, length = arguments.length; index < length; index += 1) {\n      arguments[index].forEach(collectType);\n    }\n    return result;\n  }\n\n\n  function Schema$1(definition) {\n    return this.extend(definition);\n  }\n\n\n  Schema$1.prototype.extend = function extend(definition) {\n    var implicit = [];\n    var explicit = [];\n\n    if (definition instanceof type) {\n      // Schema.extend(type)\n      explicit.push(definition);\n\n    } else if (Array.isArray(definition)) {\n      // Schema.extend([ type1, type2, ... ])\n      explicit = explicit.concat(definition);\n\n    } else if (definition && (Array.isArray(definition.implicit) || Array.isArray(definition.explicit))) {\n      // Schema.extend({ explicit: [ type1, type2, ... ], implicit: [ type1, type2, ... ] })\n      if (definition.implicit) implicit = implicit.concat(definition.implicit);\n      if (definition.explicit) explicit = explicit.concat(definition.explicit);\n\n    } else {\n      throw new exception('Schema.extend argument should be a Type, [ Type ], ' +\n        'or a schema definition ({ implicit: [...], explicit: [...] })');\n    }\n\n    implicit.forEach(function (type$1) {\n      if (!(type$1 instanceof type)) {\n        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n      }\n\n      if (type$1.loadKind && type$1.loadKind !== 'scalar') {\n        throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');\n      }\n\n      if (type$1.multi) {\n        throw new exception('There is a multi type in the implicit list of a schema. Multi tags can only be listed as explicit.');\n      }\n    });\n\n    explicit.forEach(function (type$1) {\n      if (!(type$1 instanceof type)) {\n        throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');\n      }\n    });\n\n    var result = Object.create(Schema$1.prototype);\n\n    result.implicit = (this.implicit || []).concat(implicit);\n    result.explicit = (this.explicit || []).concat(explicit);\n\n    result.compiledImplicit = compileList(result, 'implicit');\n    result.compiledExplicit = compileList(result, 'explicit');\n    result.compiledTypeMap  = compileMap(result.compiledImplicit, result.compiledExplicit);\n\n    return result;\n  };\n\n\n  var schema = Schema$1;\n\n  var str = new type('tag:yaml.org,2002:str', {\n    kind: 'scalar',\n    construct: function (data) { return data !== null ? data : ''; }\n  });\n\n  var seq = new type('tag:yaml.org,2002:seq', {\n    kind: 'sequence',\n    construct: function (data) { return data !== null ? data : []; }\n  });\n\n  var map = new type('tag:yaml.org,2002:map', {\n    kind: 'mapping',\n    construct: function (data) { return data !== null ? data : {}; }\n  });\n\n  var failsafe = new schema({\n    explicit: [\n      str,\n      seq,\n      map\n    ]\n  });\n\n  function resolveYamlNull(data) {\n    if (data === null) return true;\n\n    var max = data.length;\n\n    return (max === 1 && data === '~') ||\n           (max === 4 && (data === 'null' || data === 'Null' || data === 'NULL'));\n  }\n\n  function constructYamlNull() {\n    return null;\n  }\n\n  function isNull(object) {\n    return object === null;\n  }\n\n  var _null = new type('tag:yaml.org,2002:null', {\n    kind: 'scalar',\n    resolve: resolveYamlNull,\n    construct: constructYamlNull,\n    predicate: isNull,\n    represent: {\n      canonical: function () { return '~';    },\n      lowercase: function () { return 'null'; },\n      uppercase: function () { return 'NULL'; },\n      camelcase: function () { return 'Null'; },\n      empty:     function () { return '';     }\n    },\n    defaultStyle: 'lowercase'\n  });\n\n  function resolveYamlBoolean(data) {\n    if (data === null) return false;\n\n    var max = data.length;\n\n    return (max === 4 && (data === 'true' || data === 'True' || data === 'TRUE')) ||\n           (max === 5 && (data === 'false' || data === 'False' || data === 'FALSE'));\n  }\n\n  function constructYamlBoolean(data) {\n    return data === 'true' ||\n           data === 'True' ||\n           data === 'TRUE';\n  }\n\n  function isBoolean(object) {\n    return Object.prototype.toString.call(object) === '[object Boolean]';\n  }\n\n  var bool = new type('tag:yaml.org,2002:bool', {\n    kind: 'scalar',\n    resolve: resolveYamlBoolean,\n    construct: constructYamlBoolean,\n    predicate: isBoolean,\n    represent: {\n      lowercase: function (object) { return object ? 'true' : 'false'; },\n      uppercase: function (object) { return object ? 'TRUE' : 'FALSE'; },\n      camelcase: function (object) { return object ? 'True' : 'False'; }\n    },\n    defaultStyle: 'lowercase'\n  });\n\n  function isHexCode(c) {\n    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) ||\n           ((0x41/* A */ <= c) && (c <= 0x46/* F */)) ||\n           ((0x61/* a */ <= c) && (c <= 0x66/* f */));\n  }\n\n  function isOctCode(c) {\n    return ((0x30/* 0 */ <= c) && (c <= 0x37/* 7 */));\n  }\n\n  function isDecCode(c) {\n    return ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */));\n  }\n\n  function resolveYamlInteger(data) {\n    if (data === null) return false;\n\n    var max = data.length,\n        index = 0,\n        hasDigits = false,\n        ch;\n\n    if (!max) return false;\n\n    ch = data[index];\n\n    // sign\n    if (ch === '-' || ch === '+') {\n      ch = data[++index];\n    }\n\n    if (ch === '0') {\n      // 0\n      if (index + 1 === max) return true;\n      ch = data[++index];\n\n      // base 2, base 8, base 16\n\n      if (ch === 'b') {\n        // base 2\n        index++;\n\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (ch !== '0' && ch !== '1') return false;\n          hasDigits = true;\n        }\n        return hasDigits && ch !== '_';\n      }\n\n\n      if (ch === 'x') {\n        // base 16\n        index++;\n\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (!isHexCode(data.charCodeAt(index))) return false;\n          hasDigits = true;\n        }\n        return hasDigits && ch !== '_';\n      }\n\n\n      if (ch === 'o') {\n        // base 8\n        index++;\n\n        for (; index < max; index++) {\n          ch = data[index];\n          if (ch === '_') continue;\n          if (!isOctCode(data.charCodeAt(index))) return false;\n          hasDigits = true;\n        }\n        return hasDigits && ch !== '_';\n      }\n    }\n\n    // base 10 (except 0)\n\n    // value should not start with `_`;\n    if (ch === '_') return false;\n\n    for (; index < max; index++) {\n      ch = data[index];\n      if (ch === '_') continue;\n      if (!isDecCode(data.charCodeAt(index))) {\n        return false;\n      }\n      hasDigits = true;\n    }\n\n    // Should have digits and should not end with `_`\n    if (!hasDigits || ch === '_') return false;\n\n    return true;\n  }\n\n  function constructYamlInteger(data) {\n    var value = data, sign = 1, ch;\n\n    if (value.indexOf('_') !== -1) {\n      value = value.replace(/_/g, '');\n    }\n\n    ch = value[0];\n\n    if (ch === '-' || ch === '+') {\n      if (ch === '-') sign = -1;\n      value = value.slice(1);\n      ch = value[0];\n    }\n\n    if (value === '0') return 0;\n\n    if (ch === '0') {\n      if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);\n      if (value[1] === 'x') return sign * parseInt(value.slice(2), 16);\n      if (value[1] === 'o') return sign * parseInt(value.slice(2), 8);\n    }\n\n    return sign * parseInt(value, 10);\n  }\n\n  function isInteger(object) {\n    return (Object.prototype.toString.call(object)) === '[object Number]' &&\n           (object % 1 === 0 && !common.isNegativeZero(object));\n  }\n\n  var int = new type('tag:yaml.org,2002:int', {\n    kind: 'scalar',\n    resolve: resolveYamlInteger,\n    construct: constructYamlInteger,\n    predicate: isInteger,\n    represent: {\n      binary:      function (obj) { return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1); },\n      octal:       function (obj) { return obj >= 0 ? '0o'  + obj.toString(8) : '-0o'  + obj.toString(8).slice(1); },\n      decimal:     function (obj) { return obj.toString(10); },\n      /* eslint-disable max-len */\n      hexadecimal: function (obj) { return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() :  '-0x' + obj.toString(16).toUpperCase().slice(1); }\n    },\n    defaultStyle: 'decimal',\n    styleAliases: {\n      binary:      [ 2,  'bin' ],\n      octal:       [ 8,  'oct' ],\n      decimal:     [ 10, 'dec' ],\n      hexadecimal: [ 16, 'hex' ]\n    }\n  });\n\n  var YAML_FLOAT_PATTERN = new RegExp(\n    // 2.5e4, 2.5 and integers\n    '^(?:[-+]?(?:[0-9][0-9_]*)(?:\\\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' +\n    // .2e4, .2\n    // special case, seems not from spec\n    '|\\\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' +\n    // .inf\n    '|[-+]?\\\\.(?:inf|Inf|INF)' +\n    // .nan\n    '|\\\\.(?:nan|NaN|NAN))$');\n\n  function resolveYamlFloat(data) {\n    if (data === null) return false;\n\n    if (!YAML_FLOAT_PATTERN.test(data) ||\n        // Quick hack to not allow integers end with `_`\n        // Probably should update regexp & check speed\n        data[data.length - 1] === '_') {\n      return false;\n    }\n\n    return true;\n  }\n\n  function constructYamlFloat(data) {\n    var value, sign;\n\n    value  = data.replace(/_/g, '').toLowerCase();\n    sign   = value[0] === '-' ? -1 : 1;\n\n    if ('+-'.indexOf(value[0]) >= 0) {\n      value = value.slice(1);\n    }\n\n    if (value === '.inf') {\n      return (sign === 1) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n    } else if (value === '.nan') {\n      return NaN;\n    }\n    return sign * parseFloat(value, 10);\n  }\n\n\n  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;\n\n  function representYamlFloat(object, style) {\n    var res;\n\n    if (isNaN(object)) {\n      switch (style) {\n        case 'lowercase': return '.nan';\n        case 'uppercase': return '.NAN';\n        case 'camelcase': return '.NaN';\n      }\n    } else if (Number.POSITIVE_INFINITY === object) {\n      switch (style) {\n        case 'lowercase': return '.inf';\n        case 'uppercase': return '.INF';\n        case 'camelcase': return '.Inf';\n      }\n    } else if (Number.NEGATIVE_INFINITY === object) {\n      switch (style) {\n        case 'lowercase': return '-.inf';\n        case 'uppercase': return '-.INF';\n        case 'camelcase': return '-.Inf';\n      }\n    } else if (common.isNegativeZero(object)) {\n      return '-0.0';\n    }\n\n    res = object.toString(10);\n\n    // JS stringifier can build scientific format without dots: 5e-100,\n    // while YAML requres dot: 5.e-100. Fix it with simple hack\n\n    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;\n  }\n\n  function isFloat(object) {\n    return (Object.prototype.toString.call(object) === '[object Number]') &&\n           (object % 1 !== 0 || common.isNegativeZero(object));\n  }\n\n  var float = new type('tag:yaml.org,2002:float', {\n    kind: 'scalar',\n    resolve: resolveYamlFloat,\n    construct: constructYamlFloat,\n    predicate: isFloat,\n    represent: representYamlFloat,\n    defaultStyle: 'lowercase'\n  });\n\n  var json = failsafe.extend({\n    implicit: [\n      _null,\n      bool,\n      int,\n      float\n    ]\n  });\n\n  var core = json;\n\n  var YAML_DATE_REGEXP = new RegExp(\n    '^([0-9][0-9][0-9][0-9])'          + // [1] year\n    '-([0-9][0-9])'                    + // [2] month\n    '-([0-9][0-9])$');                   // [3] day\n\n  var YAML_TIMESTAMP_REGEXP = new RegExp(\n    '^([0-9][0-9][0-9][0-9])'          + // [1] year\n    '-([0-9][0-9]?)'                   + // [2] month\n    '-([0-9][0-9]?)'                   + // [3] day\n    '(?:[Tt]|[ \\\\t]+)'                 + // ...\n    '([0-9][0-9]?)'                    + // [4] hour\n    ':([0-9][0-9])'                    + // [5] minute\n    ':([0-9][0-9])'                    + // [6] second\n    '(?:\\\\.([0-9]*))?'                 + // [7] fraction\n    '(?:[ \\\\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour\n    '(?::([0-9][0-9]))?))?$');           // [11] tz_minute\n\n  function resolveYamlTimestamp(data) {\n    if (data === null) return false;\n    if (YAML_DATE_REGEXP.exec(data) !== null) return true;\n    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;\n    return false;\n  }\n\n  function constructYamlTimestamp(data) {\n    var match, year, month, day, hour, minute, second, fraction = 0,\n        delta = null, tz_hour, tz_minute, date;\n\n    match = YAML_DATE_REGEXP.exec(data);\n    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);\n\n    if (match === null) throw new Error('Date resolve error');\n\n    // match: [1] year [2] month [3] day\n\n    year = +(match[1]);\n    month = +(match[2]) - 1; // JS month starts with 0\n    day = +(match[3]);\n\n    if (!match[4]) { // no hour\n      return new Date(Date.UTC(year, month, day));\n    }\n\n    // match: [4] hour [5] minute [6] second [7] fraction\n\n    hour = +(match[4]);\n    minute = +(match[5]);\n    second = +(match[6]);\n\n    if (match[7]) {\n      fraction = match[7].slice(0, 3);\n      while (fraction.length < 3) { // milli-seconds\n        fraction += '0';\n      }\n      fraction = +fraction;\n    }\n\n    // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute\n\n    if (match[9]) {\n      tz_hour = +(match[10]);\n      tz_minute = +(match[11] || 0);\n      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds\n      if (match[9] === '-') delta = -delta;\n    }\n\n    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));\n\n    if (delta) date.setTime(date.getTime() - delta);\n\n    return date;\n  }\n\n  function representYamlTimestamp(object /*, style*/) {\n    return object.toISOString();\n  }\n\n  var timestamp = new type('tag:yaml.org,2002:timestamp', {\n    kind: 'scalar',\n    resolve: resolveYamlTimestamp,\n    construct: constructYamlTimestamp,\n    instanceOf: Date,\n    represent: representYamlTimestamp\n  });\n\n  function resolveYamlMerge(data) {\n    return data === '<<' || data === null;\n  }\n\n  var merge = new type('tag:yaml.org,2002:merge', {\n    kind: 'scalar',\n    resolve: resolveYamlMerge\n  });\n\n  /*eslint-disable no-bitwise*/\n\n\n\n\n\n  // [ 64, 65, 66 ] -> [ padding, CR, LF ]\n  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\\n\\r';\n\n\n  function resolveYamlBinary(data) {\n    if (data === null) return false;\n\n    var code, idx, bitlen = 0, max = data.length, map = BASE64_MAP;\n\n    // Convert one by one.\n    for (idx = 0; idx < max; idx++) {\n      code = map.indexOf(data.charAt(idx));\n\n      // Skip CR/LF\n      if (code > 64) continue;\n\n      // Fail on illegal characters\n      if (code < 0) return false;\n\n      bitlen += 6;\n    }\n\n    // If there are any bits left, source was corrupted\n    return (bitlen % 8) === 0;\n  }\n\n  function constructYamlBinary(data) {\n    var idx, tailbits,\n        input = data.replace(/[\\r\\n=]/g, ''), // remove CR/LF & padding to simplify scan\n        max = input.length,\n        map = BASE64_MAP,\n        bits = 0,\n        result = [];\n\n    // Collect by 6*4 bits (3 bytes)\n\n    for (idx = 0; idx < max; idx++) {\n      if ((idx % 4 === 0) && idx) {\n        result.push((bits >> 16) & 0xFF);\n        result.push((bits >> 8) & 0xFF);\n        result.push(bits & 0xFF);\n      }\n\n      bits = (bits << 6) | map.indexOf(input.charAt(idx));\n    }\n\n    // Dump tail\n\n    tailbits = (max % 4) * 6;\n\n    if (tailbits === 0) {\n      result.push((bits >> 16) & 0xFF);\n      result.push((bits >> 8) & 0xFF);\n      result.push(bits & 0xFF);\n    } else if (tailbits === 18) {\n      result.push((bits >> 10) & 0xFF);\n      result.push((bits >> 2) & 0xFF);\n    } else if (tailbits === 12) {\n      result.push((bits >> 4) & 0xFF);\n    }\n\n    return new Uint8Array(result);\n  }\n\n  function representYamlBinary(object /*, style*/) {\n    var result = '', bits = 0, idx, tail,\n        max = object.length,\n        map = BASE64_MAP;\n\n    // Convert every three bytes to 4 ASCII characters.\n\n    for (idx = 0; idx < max; idx++) {\n      if ((idx % 3 === 0) && idx) {\n        result += map[(bits >> 18) & 0x3F];\n        result += map[(bits >> 12) & 0x3F];\n        result += map[(bits >> 6) & 0x3F];\n        result += map[bits & 0x3F];\n      }\n\n      bits = (bits << 8) + object[idx];\n    }\n\n    // Dump tail\n\n    tail = max % 3;\n\n    if (tail === 0) {\n      result += map[(bits >> 18) & 0x3F];\n      result += map[(bits >> 12) & 0x3F];\n      result += map[(bits >> 6) & 0x3F];\n      result += map[bits & 0x3F];\n    } else if (tail === 2) {\n      result += map[(bits >> 10) & 0x3F];\n      result += map[(bits >> 4) & 0x3F];\n      result += map[(bits << 2) & 0x3F];\n      result += map[64];\n    } else if (tail === 1) {\n      result += map[(bits >> 2) & 0x3F];\n      result += map[(bits << 4) & 0x3F];\n      result += map[64];\n      result += map[64];\n    }\n\n    return result;\n  }\n\n  function isBinary(obj) {\n    return Object.prototype.toString.call(obj) ===  '[object Uint8Array]';\n  }\n\n  var binary = new type('tag:yaml.org,2002:binary', {\n    kind: 'scalar',\n    resolve: resolveYamlBinary,\n    construct: constructYamlBinary,\n    predicate: isBinary,\n    represent: representYamlBinary\n  });\n\n  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;\n  var _toString$2       = Object.prototype.toString;\n\n  function resolveYamlOmap(data) {\n    if (data === null) return true;\n\n    var objectKeys = [], index, length, pair, pairKey, pairHasKey,\n        object = data;\n\n    for (index = 0, length = object.length; index < length; index += 1) {\n      pair = object[index];\n      pairHasKey = false;\n\n      if (_toString$2.call(pair) !== '[object Object]') return false;\n\n      for (pairKey in pair) {\n        if (_hasOwnProperty$3.call(pair, pairKey)) {\n          if (!pairHasKey) pairHasKey = true;\n          else return false;\n        }\n      }\n\n      if (!pairHasKey) return false;\n\n      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);\n      else return false;\n    }\n\n    return true;\n  }\n\n  function constructYamlOmap(data) {\n    return data !== null ? data : [];\n  }\n\n  var omap = new type('tag:yaml.org,2002:omap', {\n    kind: 'sequence',\n    resolve: resolveYamlOmap,\n    construct: constructYamlOmap\n  });\n\n  var _toString$1 = Object.prototype.toString;\n\n  function resolveYamlPairs(data) {\n    if (data === null) return true;\n\n    var index, length, pair, keys, result,\n        object = data;\n\n    result = new Array(object.length);\n\n    for (index = 0, length = object.length; index < length; index += 1) {\n      pair = object[index];\n\n      if (_toString$1.call(pair) !== '[object Object]') return false;\n\n      keys = Object.keys(pair);\n\n      if (keys.length !== 1) return false;\n\n      result[index] = [ keys[0], pair[keys[0]] ];\n    }\n\n    return true;\n  }\n\n  function constructYamlPairs(data) {\n    if (data === null) return [];\n\n    var index, length, pair, keys, result,\n        object = data;\n\n    result = new Array(object.length);\n\n    for (index = 0, length = object.length; index < length; index += 1) {\n      pair = object[index];\n\n      keys = Object.keys(pair);\n\n      result[index] = [ keys[0], pair[keys[0]] ];\n    }\n\n    return result;\n  }\n\n  var pairs = new type('tag:yaml.org,2002:pairs', {\n    kind: 'sequence',\n    resolve: resolveYamlPairs,\n    construct: constructYamlPairs\n  });\n\n  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;\n\n  function resolveYamlSet(data) {\n    if (data === null) return true;\n\n    var key, object = data;\n\n    for (key in object) {\n      if (_hasOwnProperty$2.call(object, key)) {\n        if (object[key] !== null) return false;\n      }\n    }\n\n    return true;\n  }\n\n  function constructYamlSet(data) {\n    return data !== null ? data : {};\n  }\n\n  var set = new type('tag:yaml.org,2002:set', {\n    kind: 'mapping',\n    resolve: resolveYamlSet,\n    construct: constructYamlSet\n  });\n\n  var _default = core.extend({\n    implicit: [\n      timestamp,\n      merge\n    ],\n    explicit: [\n      binary,\n      omap,\n      pairs,\n      set\n    ]\n  });\n\n  /*eslint-disable max-len,no-use-before-define*/\n\n\n\n\n\n\n\n  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;\n\n\n  var CONTEXT_FLOW_IN   = 1;\n  var CONTEXT_FLOW_OUT  = 2;\n  var CONTEXT_BLOCK_IN  = 3;\n  var CONTEXT_BLOCK_OUT = 4;\n\n\n  var CHOMPING_CLIP  = 1;\n  var CHOMPING_STRIP = 2;\n  var CHOMPING_KEEP  = 3;\n\n\n  var PATTERN_NON_PRINTABLE         = /[\\x00-\\x08\\x0B\\x0C\\x0E-\\x1F\\x7F-\\x84\\x86-\\x9F\\uFFFE\\uFFFF]|[\\uD800-\\uDBFF](?![\\uDC00-\\uDFFF])|(?:[^\\uD800-\\uDBFF]|^)[\\uDC00-\\uDFFF]/;\n  var PATTERN_NON_ASCII_LINE_BREAKS = /[\\x85\\u2028\\u2029]/;\n  var PATTERN_FLOW_INDICATORS       = /[,\\[\\]\\{\\}]/;\n  var PATTERN_TAG_HANDLE            = /^(?:!|!!|![a-z\\-]+!)$/i;\n  var PATTERN_TAG_URI               = /^(?:!|[^,\\[\\]\\{\\}])(?:%[0-9a-f]{2}|[0-9a-z\\-#;\\/\\?:@&=\\+\\$,_\\.!~\\*'\\(\\)\\[\\]])*$/i;\n\n\n  function _class(obj) { return Object.prototype.toString.call(obj); }\n\n  function is_EOL(c) {\n    return (c === 0x0A/* LF */) || (c === 0x0D/* CR */);\n  }\n\n  function is_WHITE_SPACE(c) {\n    return (c === 0x09/* Tab */) || (c === 0x20/* Space */);\n  }\n\n  function is_WS_OR_EOL(c) {\n    return (c === 0x09/* Tab */) ||\n           (c === 0x20/* Space */) ||\n           (c === 0x0A/* LF */) ||\n           (c === 0x0D/* CR */);\n  }\n\n  function is_FLOW_INDICATOR(c) {\n    return c === 0x2C/* , */ ||\n           c === 0x5B/* [ */ ||\n           c === 0x5D/* ] */ ||\n           c === 0x7B/* { */ ||\n           c === 0x7D/* } */;\n  }\n\n  function fromHexCode(c) {\n    var lc;\n\n    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n      return c - 0x30;\n    }\n\n    /*eslint-disable no-bitwise*/\n    lc = c | 0x20;\n\n    if ((0x61/* a */ <= lc) && (lc <= 0x66/* f */)) {\n      return lc - 0x61 + 10;\n    }\n\n    return -1;\n  }\n\n  function escapedHexLen(c) {\n    if (c === 0x78/* x */) { return 2; }\n    if (c === 0x75/* u */) { return 4; }\n    if (c === 0x55/* U */) { return 8; }\n    return 0;\n  }\n\n  function fromDecimalCode(c) {\n    if ((0x30/* 0 */ <= c) && (c <= 0x39/* 9 */)) {\n      return c - 0x30;\n    }\n\n    return -1;\n  }\n\n  function simpleEscapeSequence(c) {\n    /* eslint-disable indent */\n    return (c === 0x30/* 0 */) ? '\\x00' :\n          (c === 0x61/* a */) ? '\\x07' :\n          (c === 0x62/* b */) ? '\\x08' :\n          (c === 0x74/* t */) ? '\\x09' :\n          (c === 0x09/* Tab */) ? '\\x09' :\n          (c === 0x6E/* n */) ? '\\x0A' :\n          (c === 0x76/* v */) ? '\\x0B' :\n          (c === 0x66/* f */) ? '\\x0C' :\n          (c === 0x72/* r */) ? '\\x0D' :\n          (c === 0x65/* e */) ? '\\x1B' :\n          (c === 0x20/* Space */) ? ' ' :\n          (c === 0x22/* \" */) ? '\\x22' :\n          (c === 0x2F/* / */) ? '/' :\n          (c === 0x5C/* \\ */) ? '\\x5C' :\n          (c === 0x4E/* N */) ? '\\x85' :\n          (c === 0x5F/* _ */) ? '\\xA0' :\n          (c === 0x4C/* L */) ? '\\u2028' :\n          (c === 0x50/* P */) ? '\\u2029' : '';\n  }\n\n  function charFromCodepoint(c) {\n    if (c <= 0xFFFF) {\n      return String.fromCharCode(c);\n    }\n    // Encode UTF-16 surrogate pair\n    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF\n    return String.fromCharCode(\n      ((c - 0x010000) >> 10) + 0xD800,\n      ((c - 0x010000) & 0x03FF) + 0xDC00\n    );\n  }\n\n  var simpleEscapeCheck = new Array(256); // integer, for fast access\n  var simpleEscapeMap = new Array(256);\n  for (var i = 0; i < 256; i++) {\n    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;\n    simpleEscapeMap[i] = simpleEscapeSequence(i);\n  }\n\n\n  function State$1(input, options) {\n    this.input = input;\n\n    this.filename  = options['filename']  || null;\n    this.schema    = options['schema']    || _default;\n    this.onWarning = options['onWarning'] || null;\n    // (Hidden) Remove? makes the loader to expect YAML 1.1 documents\n    // if such documents have no explicit %YAML directive\n    this.legacy    = options['legacy']    || false;\n\n    this.json      = options['json']      || false;\n    this.listener  = options['listener']  || null;\n\n    this.implicitTypes = this.schema.compiledImplicit;\n    this.typeMap       = this.schema.compiledTypeMap;\n\n    this.length     = input.length;\n    this.position   = 0;\n    this.line       = 0;\n    this.lineStart  = 0;\n    this.lineIndent = 0;\n\n    // position of first leading tab in the current line,\n    // used to make sure there are no tabs in the indentation\n    this.firstTabInLine = -1;\n\n    this.documents = [];\n\n    /*\n    this.version;\n    this.checkLineBreaks;\n    this.tagMap;\n    this.anchorMap;\n    this.tag;\n    this.anchor;\n    this.kind;\n    this.result;*/\n\n  }\n\n\n  function generateError(state, message) {\n    var mark = {\n      name:     state.filename,\n      buffer:   state.input.slice(0, -1), // omit trailing \\0\n      position: state.position,\n      line:     state.line,\n      column:   state.position - state.lineStart\n    };\n\n    mark.snippet = snippet(mark);\n\n    return new exception(message, mark);\n  }\n\n  function throwError(state, message) {\n    throw generateError(state, message);\n  }\n\n  function throwWarning(state, message) {\n    if (state.onWarning) {\n      state.onWarning.call(null, generateError(state, message));\n    }\n  }\n\n\n  var directiveHandlers = {\n\n    YAML: function handleYamlDirective(state, name, args) {\n\n      var match, major, minor;\n\n      if (state.version !== null) {\n        throwError(state, 'duplication of %YAML directive');\n      }\n\n      if (args.length !== 1) {\n        throwError(state, 'YAML directive accepts exactly one argument');\n      }\n\n      match = /^([0-9]+)\\.([0-9]+)$/.exec(args[0]);\n\n      if (match === null) {\n        throwError(state, 'ill-formed argument of the YAML directive');\n      }\n\n      major = parseInt(match[1], 10);\n      minor = parseInt(match[2], 10);\n\n      if (major !== 1) {\n        throwError(state, 'unacceptable YAML version of the document');\n      }\n\n      state.version = args[0];\n      state.checkLineBreaks = (minor < 2);\n\n      if (minor !== 1 && minor !== 2) {\n        throwWarning(state, 'unsupported YAML version of the document');\n      }\n    },\n\n    TAG: function handleTagDirective(state, name, args) {\n\n      var handle, prefix;\n\n      if (args.length !== 2) {\n        throwError(state, 'TAG directive accepts exactly two arguments');\n      }\n\n      handle = args[0];\n      prefix = args[1];\n\n      if (!PATTERN_TAG_HANDLE.test(handle)) {\n        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');\n      }\n\n      if (_hasOwnProperty$1.call(state.tagMap, handle)) {\n        throwError(state, 'there is a previously declared suffix for \"' + handle + '\" tag handle');\n      }\n\n      if (!PATTERN_TAG_URI.test(prefix)) {\n        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');\n      }\n\n      try {\n        prefix = decodeURIComponent(prefix);\n      } catch (err) {\n        throwError(state, 'tag prefix is malformed: ' + prefix);\n      }\n\n      state.tagMap[handle] = prefix;\n    }\n  };\n\n\n  function captureSegment(state, start, end, checkJson) {\n    var _position, _length, _character, _result;\n\n    if (start < end) {\n      _result = state.input.slice(start, end);\n\n      if (checkJson) {\n        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {\n          _character = _result.charCodeAt(_position);\n          if (!(_character === 0x09 ||\n                (0x20 <= _character && _character <= 0x10FFFF))) {\n            throwError(state, 'expected valid JSON character');\n          }\n        }\n      } else if (PATTERN_NON_PRINTABLE.test(_result)) {\n        throwError(state, 'the stream contains non-printable characters');\n      }\n\n      state.result += _result;\n    }\n  }\n\n  function mergeMappings(state, destination, source, overridableKeys) {\n    var sourceKeys, key, index, quantity;\n\n    if (!common.isObject(source)) {\n      throwError(state, 'cannot merge mappings; the provided source object is unacceptable');\n    }\n\n    sourceKeys = Object.keys(source);\n\n    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {\n      key = sourceKeys[index];\n\n      if (!_hasOwnProperty$1.call(destination, key)) {\n        destination[key] = source[key];\n        overridableKeys[key] = true;\n      }\n    }\n  }\n\n  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode,\n    startLine, startLineStart, startPos) {\n\n    var index, quantity;\n\n    // The output is a plain object here, so keys can only be strings.\n    // We need to convert keyNode to a string, but doing so can hang the process\n    // (deeply nested arrays that explode exponentially using aliases).\n    if (Array.isArray(keyNode)) {\n      keyNode = Array.prototype.slice.call(keyNode);\n\n      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {\n        if (Array.isArray(keyNode[index])) {\n          throwError(state, 'nested arrays are not supported inside keys');\n        }\n\n        if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {\n          keyNode[index] = '[object Object]';\n        }\n      }\n    }\n\n    // Avoid code execution in load() via toString property\n    // (still use its own toString for arrays, timestamps,\n    // and whatever user schema extensions happen to have @@toStringTag)\n    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {\n      keyNode = '[object Object]';\n    }\n\n\n    keyNode = String(keyNode);\n\n    if (_result === null) {\n      _result = {};\n    }\n\n    if (keyTag === 'tag:yaml.org,2002:merge') {\n      if (Array.isArray(valueNode)) {\n        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {\n          mergeMappings(state, _result, valueNode[index], overridableKeys);\n        }\n      } else {\n        mergeMappings(state, _result, valueNode, overridableKeys);\n      }\n    } else {\n      if (!state.json &&\n          !_hasOwnProperty$1.call(overridableKeys, keyNode) &&\n          _hasOwnProperty$1.call(_result, keyNode)) {\n        state.line = startLine || state.line;\n        state.lineStart = startLineStart || state.lineStart;\n        state.position = startPos || state.position;\n        throwError(state, 'duplicated mapping key');\n      }\n\n      // used for this specific key only because Object.defineProperty is slow\n      if (keyNode === '__proto__') {\n        Object.defineProperty(_result, keyNode, {\n          configurable: true,\n          enumerable: true,\n          writable: true,\n          value: valueNode\n        });\n      } else {\n        _result[keyNode] = valueNode;\n      }\n      delete overridableKeys[keyNode];\n    }\n\n    return _result;\n  }\n\n  function readLineBreak(state) {\n    var ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x0A/* LF */) {\n      state.position++;\n    } else if (ch === 0x0D/* CR */) {\n      state.position++;\n      if (state.input.charCodeAt(state.position) === 0x0A/* LF */) {\n        state.position++;\n      }\n    } else {\n      throwError(state, 'a line break is expected');\n    }\n\n    state.line += 1;\n    state.lineStart = state.position;\n    state.firstTabInLine = -1;\n  }\n\n  function skipSeparationSpace(state, allowComments, checkIndent) {\n    var lineBreaks = 0,\n        ch = state.input.charCodeAt(state.position);\n\n    while (ch !== 0) {\n      while (is_WHITE_SPACE(ch)) {\n        if (ch === 0x09/* Tab */ && state.firstTabInLine === -1) {\n          state.firstTabInLine = state.position;\n        }\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (allowComments && ch === 0x23/* # */) {\n        do {\n          ch = state.input.charCodeAt(++state.position);\n        } while (ch !== 0x0A/* LF */ && ch !== 0x0D/* CR */ && ch !== 0);\n      }\n\n      if (is_EOL(ch)) {\n        readLineBreak(state);\n\n        ch = state.input.charCodeAt(state.position);\n        lineBreaks++;\n        state.lineIndent = 0;\n\n        while (ch === 0x20/* Space */) {\n          state.lineIndent++;\n          ch = state.input.charCodeAt(++state.position);\n        }\n      } else {\n        break;\n      }\n    }\n\n    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {\n      throwWarning(state, 'deficient indentation');\n    }\n\n    return lineBreaks;\n  }\n\n  function testDocumentSeparator(state) {\n    var _position = state.position,\n        ch;\n\n    ch = state.input.charCodeAt(_position);\n\n    // Condition state.position === state.lineStart is tested\n    // in parent on each call, for efficiency. No needs to test here again.\n    if ((ch === 0x2D/* - */ || ch === 0x2E/* . */) &&\n        ch === state.input.charCodeAt(_position + 1) &&\n        ch === state.input.charCodeAt(_position + 2)) {\n\n      _position += 3;\n\n      ch = state.input.charCodeAt(_position);\n\n      if (ch === 0 || is_WS_OR_EOL(ch)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  function writeFoldedLines(state, count) {\n    if (count === 1) {\n      state.result += ' ';\n    } else if (count > 1) {\n      state.result += common.repeat('\\n', count - 1);\n    }\n  }\n\n\n  function readPlainScalar(state, nodeIndent, withinFlowCollection) {\n    var preceding,\n        following,\n        captureStart,\n        captureEnd,\n        hasPendingContent,\n        _line,\n        _lineStart,\n        _lineIndent,\n        _kind = state.kind,\n        _result = state.result,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (is_WS_OR_EOL(ch)      ||\n        is_FLOW_INDICATOR(ch) ||\n        ch === 0x23/* # */    ||\n        ch === 0x26/* & */    ||\n        ch === 0x2A/* * */    ||\n        ch === 0x21/* ! */    ||\n        ch === 0x7C/* | */    ||\n        ch === 0x3E/* > */    ||\n        ch === 0x27/* ' */    ||\n        ch === 0x22/* \" */    ||\n        ch === 0x25/* % */    ||\n        ch === 0x40/* @ */    ||\n        ch === 0x60/* ` */) {\n      return false;\n    }\n\n    if (ch === 0x3F/* ? */ || ch === 0x2D/* - */) {\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (is_WS_OR_EOL(following) ||\n          withinFlowCollection && is_FLOW_INDICATOR(following)) {\n        return false;\n      }\n    }\n\n    state.kind = 'scalar';\n    state.result = '';\n    captureStart = captureEnd = state.position;\n    hasPendingContent = false;\n\n    while (ch !== 0) {\n      if (ch === 0x3A/* : */) {\n        following = state.input.charCodeAt(state.position + 1);\n\n        if (is_WS_OR_EOL(following) ||\n            withinFlowCollection && is_FLOW_INDICATOR(following)) {\n          break;\n        }\n\n      } else if (ch === 0x23/* # */) {\n        preceding = state.input.charCodeAt(state.position - 1);\n\n        if (is_WS_OR_EOL(preceding)) {\n          break;\n        }\n\n      } else if ((state.position === state.lineStart && testDocumentSeparator(state)) ||\n                 withinFlowCollection && is_FLOW_INDICATOR(ch)) {\n        break;\n\n      } else if (is_EOL(ch)) {\n        _line = state.line;\n        _lineStart = state.lineStart;\n        _lineIndent = state.lineIndent;\n        skipSeparationSpace(state, false, -1);\n\n        if (state.lineIndent >= nodeIndent) {\n          hasPendingContent = true;\n          ch = state.input.charCodeAt(state.position);\n          continue;\n        } else {\n          state.position = captureEnd;\n          state.line = _line;\n          state.lineStart = _lineStart;\n          state.lineIndent = _lineIndent;\n          break;\n        }\n      }\n\n      if (hasPendingContent) {\n        captureSegment(state, captureStart, captureEnd, false);\n        writeFoldedLines(state, state.line - _line);\n        captureStart = captureEnd = state.position;\n        hasPendingContent = false;\n      }\n\n      if (!is_WHITE_SPACE(ch)) {\n        captureEnd = state.position + 1;\n      }\n\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    captureSegment(state, captureStart, captureEnd, false);\n\n    if (state.result) {\n      return true;\n    }\n\n    state.kind = _kind;\n    state.result = _result;\n    return false;\n  }\n\n  function readSingleQuotedScalar(state, nodeIndent) {\n    var ch,\n        captureStart, captureEnd;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch !== 0x27/* ' */) {\n      return false;\n    }\n\n    state.kind = 'scalar';\n    state.result = '';\n    state.position++;\n    captureStart = captureEnd = state.position;\n\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n      if (ch === 0x27/* ' */) {\n        captureSegment(state, captureStart, state.position, true);\n        ch = state.input.charCodeAt(++state.position);\n\n        if (ch === 0x27/* ' */) {\n          captureStart = state.position;\n          state.position++;\n          captureEnd = state.position;\n        } else {\n          return true;\n        }\n\n      } else if (is_EOL(ch)) {\n        captureSegment(state, captureStart, captureEnd, true);\n        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n        captureStart = captureEnd = state.position;\n\n      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n        throwError(state, 'unexpected end of the document within a single quoted scalar');\n\n      } else {\n        state.position++;\n        captureEnd = state.position;\n      }\n    }\n\n    throwError(state, 'unexpected end of the stream within a single quoted scalar');\n  }\n\n  function readDoubleQuotedScalar(state, nodeIndent) {\n    var captureStart,\n        captureEnd,\n        hexLength,\n        hexResult,\n        tmp,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch !== 0x22/* \" */) {\n      return false;\n    }\n\n    state.kind = 'scalar';\n    state.result = '';\n    state.position++;\n    captureStart = captureEnd = state.position;\n\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n      if (ch === 0x22/* \" */) {\n        captureSegment(state, captureStart, state.position, true);\n        state.position++;\n        return true;\n\n      } else if (ch === 0x5C/* \\ */) {\n        captureSegment(state, captureStart, state.position, true);\n        ch = state.input.charCodeAt(++state.position);\n\n        if (is_EOL(ch)) {\n          skipSeparationSpace(state, false, nodeIndent);\n\n          // TODO: rework to inline fn with no type cast?\n        } else if (ch < 256 && simpleEscapeCheck[ch]) {\n          state.result += simpleEscapeMap[ch];\n          state.position++;\n\n        } else if ((tmp = escapedHexLen(ch)) > 0) {\n          hexLength = tmp;\n          hexResult = 0;\n\n          for (; hexLength > 0; hexLength--) {\n            ch = state.input.charCodeAt(++state.position);\n\n            if ((tmp = fromHexCode(ch)) >= 0) {\n              hexResult = (hexResult << 4) + tmp;\n\n            } else {\n              throwError(state, 'expected hexadecimal character');\n            }\n          }\n\n          state.result += charFromCodepoint(hexResult);\n\n          state.position++;\n\n        } else {\n          throwError(state, 'unknown escape sequence');\n        }\n\n        captureStart = captureEnd = state.position;\n\n      } else if (is_EOL(ch)) {\n        captureSegment(state, captureStart, captureEnd, true);\n        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));\n        captureStart = captureEnd = state.position;\n\n      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {\n        throwError(state, 'unexpected end of the document within a double quoted scalar');\n\n      } else {\n        state.position++;\n        captureEnd = state.position;\n      }\n    }\n\n    throwError(state, 'unexpected end of the stream within a double quoted scalar');\n  }\n\n  function readFlowCollection(state, nodeIndent) {\n    var readNext = true,\n        _line,\n        _lineStart,\n        _pos,\n        _tag     = state.tag,\n        _result,\n        _anchor  = state.anchor,\n        following,\n        terminator,\n        isPair,\n        isExplicitPair,\n        isMapping,\n        overridableKeys = Object.create(null),\n        keyNode,\n        keyTag,\n        valueNode,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x5B/* [ */) {\n      terminator = 0x5D;/* ] */\n      isMapping = false;\n      _result = [];\n    } else if (ch === 0x7B/* { */) {\n      terminator = 0x7D;/* } */\n      isMapping = true;\n      _result = {};\n    } else {\n      return false;\n    }\n\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = _result;\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n\n    while (ch !== 0) {\n      skipSeparationSpace(state, true, nodeIndent);\n\n      ch = state.input.charCodeAt(state.position);\n\n      if (ch === terminator) {\n        state.position++;\n        state.tag = _tag;\n        state.anchor = _anchor;\n        state.kind = isMapping ? 'mapping' : 'sequence';\n        state.result = _result;\n        return true;\n      } else if (!readNext) {\n        throwError(state, 'missed comma between flow collection entries');\n      } else if (ch === 0x2C/* , */) {\n        // \"flow collection entries can never be completely empty\", as per YAML 1.2, section 7.4\n        throwError(state, \"expected the node content, but found ','\");\n      }\n\n      keyTag = keyNode = valueNode = null;\n      isPair = isExplicitPair = false;\n\n      if (ch === 0x3F/* ? */) {\n        following = state.input.charCodeAt(state.position + 1);\n\n        if (is_WS_OR_EOL(following)) {\n          isPair = isExplicitPair = true;\n          state.position++;\n          skipSeparationSpace(state, true, nodeIndent);\n        }\n      }\n\n      _line = state.line; // Save the current line.\n      _lineStart = state.lineStart;\n      _pos = state.position;\n      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n      keyTag = state.tag;\n      keyNode = state.result;\n      skipSeparationSpace(state, true, nodeIndent);\n\n      ch = state.input.charCodeAt(state.position);\n\n      if ((isExplicitPair || state.line === _line) && ch === 0x3A/* : */) {\n        isPair = true;\n        ch = state.input.charCodeAt(++state.position);\n        skipSeparationSpace(state, true, nodeIndent);\n        composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);\n        valueNode = state.result;\n      }\n\n      if (isMapping) {\n        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos);\n      } else if (isPair) {\n        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode, _line, _lineStart, _pos));\n      } else {\n        _result.push(keyNode);\n      }\n\n      skipSeparationSpace(state, true, nodeIndent);\n\n      ch = state.input.charCodeAt(state.position);\n\n      if (ch === 0x2C/* , */) {\n        readNext = true;\n        ch = state.input.charCodeAt(++state.position);\n      } else {\n        readNext = false;\n      }\n    }\n\n    throwError(state, 'unexpected end of the stream within a flow collection');\n  }\n\n  function readBlockScalar(state, nodeIndent) {\n    var captureStart,\n        folding,\n        chomping       = CHOMPING_CLIP,\n        didReadContent = false,\n        detectedIndent = false,\n        textIndent     = nodeIndent,\n        emptyLines     = 0,\n        atMoreIndented = false,\n        tmp,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch === 0x7C/* | */) {\n      folding = false;\n    } else if (ch === 0x3E/* > */) {\n      folding = true;\n    } else {\n      return false;\n    }\n\n    state.kind = 'scalar';\n    state.result = '';\n\n    while (ch !== 0) {\n      ch = state.input.charCodeAt(++state.position);\n\n      if (ch === 0x2B/* + */ || ch === 0x2D/* - */) {\n        if (CHOMPING_CLIP === chomping) {\n          chomping = (ch === 0x2B/* + */) ? CHOMPING_KEEP : CHOMPING_STRIP;\n        } else {\n          throwError(state, 'repeat of a chomping mode identifier');\n        }\n\n      } else if ((tmp = fromDecimalCode(ch)) >= 0) {\n        if (tmp === 0) {\n          throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');\n        } else if (!detectedIndent) {\n          textIndent = nodeIndent + tmp - 1;\n          detectedIndent = true;\n        } else {\n          throwError(state, 'repeat of an indentation width identifier');\n        }\n\n      } else {\n        break;\n      }\n    }\n\n    if (is_WHITE_SPACE(ch)) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (is_WHITE_SPACE(ch));\n\n      if (ch === 0x23/* # */) {\n        do { ch = state.input.charCodeAt(++state.position); }\n        while (!is_EOL(ch) && (ch !== 0));\n      }\n    }\n\n    while (ch !== 0) {\n      readLineBreak(state);\n      state.lineIndent = 0;\n\n      ch = state.input.charCodeAt(state.position);\n\n      while ((!detectedIndent || state.lineIndent < textIndent) &&\n             (ch === 0x20/* Space */)) {\n        state.lineIndent++;\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      if (!detectedIndent && state.lineIndent > textIndent) {\n        textIndent = state.lineIndent;\n      }\n\n      if (is_EOL(ch)) {\n        emptyLines++;\n        continue;\n      }\n\n      // End of the scalar.\n      if (state.lineIndent < textIndent) {\n\n        // Perform the chomping.\n        if (chomping === CHOMPING_KEEP) {\n          state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n        } else if (chomping === CHOMPING_CLIP) {\n          if (didReadContent) { // i.e. only if the scalar is not empty.\n            state.result += '\\n';\n          }\n        }\n\n        // Break this `while` cycle and go to the funciton's epilogue.\n        break;\n      }\n\n      // Folded style: use fancy rules to handle line breaks.\n      if (folding) {\n\n        // Lines starting with white space characters (more-indented lines) are not folded.\n        if (is_WHITE_SPACE(ch)) {\n          atMoreIndented = true;\n          // except for the first content line (cf. Example 8.1)\n          state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n\n        // End of more-indented block.\n        } else if (atMoreIndented) {\n          atMoreIndented = false;\n          state.result += common.repeat('\\n', emptyLines + 1);\n\n        // Just one line break - perceive as the same line.\n        } else if (emptyLines === 0) {\n          if (didReadContent) { // i.e. only if we have already read some scalar content.\n            state.result += ' ';\n          }\n\n        // Several line breaks - perceive as different lines.\n        } else {\n          state.result += common.repeat('\\n', emptyLines);\n        }\n\n      // Literal style: just add exact number of line breaks between content lines.\n      } else {\n        // Keep all line breaks except the header line break.\n        state.result += common.repeat('\\n', didReadContent ? 1 + emptyLines : emptyLines);\n      }\n\n      didReadContent = true;\n      detectedIndent = true;\n      emptyLines = 0;\n      captureStart = state.position;\n\n      while (!is_EOL(ch) && (ch !== 0)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      captureSegment(state, captureStart, state.position, false);\n    }\n\n    return true;\n  }\n\n  function readBlockSequence(state, nodeIndent) {\n    var _line,\n        _tag      = state.tag,\n        _anchor   = state.anchor,\n        _result   = [],\n        following,\n        detected  = false,\n        ch;\n\n    // there is a leading tab before this token, so it can't be a block sequence/mapping;\n    // it can still be flow sequence/mapping or a scalar\n    if (state.firstTabInLine !== -1) return false;\n\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = _result;\n    }\n\n    ch = state.input.charCodeAt(state.position);\n\n    while (ch !== 0) {\n      if (state.firstTabInLine !== -1) {\n        state.position = state.firstTabInLine;\n        throwError(state, 'tab characters must not be used in indentation');\n      }\n\n      if (ch !== 0x2D/* - */) {\n        break;\n      }\n\n      following = state.input.charCodeAt(state.position + 1);\n\n      if (!is_WS_OR_EOL(following)) {\n        break;\n      }\n\n      detected = true;\n      state.position++;\n\n      if (skipSeparationSpace(state, true, -1)) {\n        if (state.lineIndent <= nodeIndent) {\n          _result.push(null);\n          ch = state.input.charCodeAt(state.position);\n          continue;\n        }\n      }\n\n      _line = state.line;\n      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);\n      _result.push(state.result);\n      skipSeparationSpace(state, true, -1);\n\n      ch = state.input.charCodeAt(state.position);\n\n      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n        throwError(state, 'bad indentation of a sequence entry');\n      } else if (state.lineIndent < nodeIndent) {\n        break;\n      }\n    }\n\n    if (detected) {\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = 'sequence';\n      state.result = _result;\n      return true;\n    }\n    return false;\n  }\n\n  function readBlockMapping(state, nodeIndent, flowIndent) {\n    var following,\n        allowCompact,\n        _line,\n        _keyLine,\n        _keyLineStart,\n        _keyPos,\n        _tag          = state.tag,\n        _anchor       = state.anchor,\n        _result       = {},\n        overridableKeys = Object.create(null),\n        keyTag        = null,\n        keyNode       = null,\n        valueNode     = null,\n        atExplicitKey = false,\n        detected      = false,\n        ch;\n\n    // there is a leading tab before this token, so it can't be a block sequence/mapping;\n    // it can still be flow sequence/mapping or a scalar\n    if (state.firstTabInLine !== -1) return false;\n\n    if (state.anchor !== null) {\n      state.anchorMap[state.anchor] = _result;\n    }\n\n    ch = state.input.charCodeAt(state.position);\n\n    while (ch !== 0) {\n      if (!atExplicitKey && state.firstTabInLine !== -1) {\n        state.position = state.firstTabInLine;\n        throwError(state, 'tab characters must not be used in indentation');\n      }\n\n      following = state.input.charCodeAt(state.position + 1);\n      _line = state.line; // Save the current line.\n\n      //\n      // Explicit notation case. There are two separate blocks:\n      // first for the key (denoted by \"?\") and second for the value (denoted by \":\")\n      //\n      if ((ch === 0x3F/* ? */ || ch === 0x3A/* : */) && is_WS_OR_EOL(following)) {\n\n        if (ch === 0x3F/* ? */) {\n          if (atExplicitKey) {\n            storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n            keyTag = keyNode = valueNode = null;\n          }\n\n          detected = true;\n          atExplicitKey = true;\n          allowCompact = true;\n\n        } else if (atExplicitKey) {\n          // i.e. 0x3A/* : */ === character after the explicit key.\n          atExplicitKey = false;\n          allowCompact = true;\n\n        } else {\n          throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');\n        }\n\n        state.position += 1;\n        ch = following;\n\n      //\n      // Implicit notation case. Flow-style node as the key first, then \":\", and the value.\n      //\n      } else {\n        _keyLine = state.line;\n        _keyLineStart = state.lineStart;\n        _keyPos = state.position;\n\n        if (!composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {\n          // Neither implicit nor explicit notation.\n          // Reading is done. Go to the epilogue.\n          break;\n        }\n\n        if (state.line === _line) {\n          ch = state.input.charCodeAt(state.position);\n\n          while (is_WHITE_SPACE(ch)) {\n            ch = state.input.charCodeAt(++state.position);\n          }\n\n          if (ch === 0x3A/* : */) {\n            ch = state.input.charCodeAt(++state.position);\n\n            if (!is_WS_OR_EOL(ch)) {\n              throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');\n            }\n\n            if (atExplicitKey) {\n              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n              keyTag = keyNode = valueNode = null;\n            }\n\n            detected = true;\n            atExplicitKey = false;\n            allowCompact = false;\n            keyTag = state.tag;\n            keyNode = state.result;\n\n          } else if (detected) {\n            throwError(state, 'can not read an implicit mapping pair; a colon is missed');\n\n          } else {\n            state.tag = _tag;\n            state.anchor = _anchor;\n            return true; // Keep the result of `composeNode`.\n          }\n\n        } else if (detected) {\n          throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');\n\n        } else {\n          state.tag = _tag;\n          state.anchor = _anchor;\n          return true; // Keep the result of `composeNode`.\n        }\n      }\n\n      //\n      // Common reading code for both explicit and implicit notations.\n      //\n      if (state.line === _line || state.lineIndent > nodeIndent) {\n        if (atExplicitKey) {\n          _keyLine = state.line;\n          _keyLineStart = state.lineStart;\n          _keyPos = state.position;\n        }\n\n        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {\n          if (atExplicitKey) {\n            keyNode = state.result;\n          } else {\n            valueNode = state.result;\n          }\n        }\n\n        if (!atExplicitKey) {\n          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _keyLine, _keyLineStart, _keyPos);\n          keyTag = keyNode = valueNode = null;\n        }\n\n        skipSeparationSpace(state, true, -1);\n        ch = state.input.charCodeAt(state.position);\n      }\n\n      if ((state.line === _line || state.lineIndent > nodeIndent) && (ch !== 0)) {\n        throwError(state, 'bad indentation of a mapping entry');\n      } else if (state.lineIndent < nodeIndent) {\n        break;\n      }\n    }\n\n    //\n    // Epilogue.\n    //\n\n    // Special case: last mapping's node contains only the key in explicit notation.\n    if (atExplicitKey) {\n      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null, _keyLine, _keyLineStart, _keyPos);\n    }\n\n    // Expose the resulting mapping.\n    if (detected) {\n      state.tag = _tag;\n      state.anchor = _anchor;\n      state.kind = 'mapping';\n      state.result = _result;\n    }\n\n    return detected;\n  }\n\n  function readTagProperty(state) {\n    var _position,\n        isVerbatim = false,\n        isNamed    = false,\n        tagHandle,\n        tagName,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch !== 0x21/* ! */) return false;\n\n    if (state.tag !== null) {\n      throwError(state, 'duplication of a tag property');\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n\n    if (ch === 0x3C/* < */) {\n      isVerbatim = true;\n      ch = state.input.charCodeAt(++state.position);\n\n    } else if (ch === 0x21/* ! */) {\n      isNamed = true;\n      tagHandle = '!!';\n      ch = state.input.charCodeAt(++state.position);\n\n    } else {\n      tagHandle = '!';\n    }\n\n    _position = state.position;\n\n    if (isVerbatim) {\n      do { ch = state.input.charCodeAt(++state.position); }\n      while (ch !== 0 && ch !== 0x3E/* > */);\n\n      if (state.position < state.length) {\n        tagName = state.input.slice(_position, state.position);\n        ch = state.input.charCodeAt(++state.position);\n      } else {\n        throwError(state, 'unexpected end of the stream within a verbatim tag');\n      }\n    } else {\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n\n        if (ch === 0x21/* ! */) {\n          if (!isNamed) {\n            tagHandle = state.input.slice(_position - 1, state.position + 1);\n\n            if (!PATTERN_TAG_HANDLE.test(tagHandle)) {\n              throwError(state, 'named tag handle cannot contain such characters');\n            }\n\n            isNamed = true;\n            _position = state.position + 1;\n          } else {\n            throwError(state, 'tag suffix cannot contain exclamation marks');\n          }\n        }\n\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      tagName = state.input.slice(_position, state.position);\n\n      if (PATTERN_FLOW_INDICATORS.test(tagName)) {\n        throwError(state, 'tag suffix cannot contain flow indicator characters');\n      }\n    }\n\n    if (tagName && !PATTERN_TAG_URI.test(tagName)) {\n      throwError(state, 'tag name cannot contain such characters: ' + tagName);\n    }\n\n    try {\n      tagName = decodeURIComponent(tagName);\n    } catch (err) {\n      throwError(state, 'tag name is malformed: ' + tagName);\n    }\n\n    if (isVerbatim) {\n      state.tag = tagName;\n\n    } else if (_hasOwnProperty$1.call(state.tagMap, tagHandle)) {\n      state.tag = state.tagMap[tagHandle] + tagName;\n\n    } else if (tagHandle === '!') {\n      state.tag = '!' + tagName;\n\n    } else if (tagHandle === '!!') {\n      state.tag = 'tag:yaml.org,2002:' + tagName;\n\n    } else {\n      throwError(state, 'undeclared tag handle \"' + tagHandle + '\"');\n    }\n\n    return true;\n  }\n\n  function readAnchorProperty(state) {\n    var _position,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch !== 0x26/* & */) return false;\n\n    if (state.anchor !== null) {\n      throwError(state, 'duplication of an anchor property');\n    }\n\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (state.position === _position) {\n      throwError(state, 'name of an anchor node must contain at least one character');\n    }\n\n    state.anchor = state.input.slice(_position, state.position);\n    return true;\n  }\n\n  function readAlias(state) {\n    var _position, alias,\n        ch;\n\n    ch = state.input.charCodeAt(state.position);\n\n    if (ch !== 0x2A/* * */) return false;\n\n    ch = state.input.charCodeAt(++state.position);\n    _position = state.position;\n\n    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {\n      ch = state.input.charCodeAt(++state.position);\n    }\n\n    if (state.position === _position) {\n      throwError(state, 'name of an alias node must contain at least one character');\n    }\n\n    alias = state.input.slice(_position, state.position);\n\n    if (!_hasOwnProperty$1.call(state.anchorMap, alias)) {\n      throwError(state, 'unidentified alias \"' + alias + '\"');\n    }\n\n    state.result = state.anchorMap[alias];\n    skipSeparationSpace(state, true, -1);\n    return true;\n  }\n\n  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {\n    var allowBlockStyles,\n        allowBlockScalars,\n        allowBlockCollections,\n        indentStatus = 1, // 1: this>parent, 0: this=parent, -1: this<parent\n        atNewLine  = false,\n        hasContent = false,\n        typeIndex,\n        typeQuantity,\n        typeList,\n        type,\n        flowIndent,\n        blockIndent;\n\n    if (state.listener !== null) {\n      state.listener('open', state);\n    }\n\n    state.tag    = null;\n    state.anchor = null;\n    state.kind   = null;\n    state.result = null;\n\n    allowBlockStyles = allowBlockScalars = allowBlockCollections =\n      CONTEXT_BLOCK_OUT === nodeContext ||\n      CONTEXT_BLOCK_IN  === nodeContext;\n\n    if (allowToSeek) {\n      if (skipSeparationSpace(state, true, -1)) {\n        atNewLine = true;\n\n        if (state.lineIndent > parentIndent) {\n          indentStatus = 1;\n        } else if (state.lineIndent === parentIndent) {\n          indentStatus = 0;\n        } else if (state.lineIndent < parentIndent) {\n          indentStatus = -1;\n        }\n      }\n    }\n\n    if (indentStatus === 1) {\n      while (readTagProperty(state) || readAnchorProperty(state)) {\n        if (skipSeparationSpace(state, true, -1)) {\n          atNewLine = true;\n          allowBlockCollections = allowBlockStyles;\n\n          if (state.lineIndent > parentIndent) {\n            indentStatus = 1;\n          } else if (state.lineIndent === parentIndent) {\n            indentStatus = 0;\n          } else if (state.lineIndent < parentIndent) {\n            indentStatus = -1;\n          }\n        } else {\n          allowBlockCollections = false;\n        }\n      }\n    }\n\n    if (allowBlockCollections) {\n      allowBlockCollections = atNewLine || allowCompact;\n    }\n\n    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {\n      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {\n        flowIndent = parentIndent;\n      } else {\n        flowIndent = parentIndent + 1;\n      }\n\n      blockIndent = state.position - state.lineStart;\n\n      if (indentStatus === 1) {\n        if (allowBlockCollections &&\n            (readBlockSequence(state, blockIndent) ||\n             readBlockMapping(state, blockIndent, flowIndent)) ||\n            readFlowCollection(state, flowIndent)) {\n          hasContent = true;\n        } else {\n          if ((allowBlockScalars && readBlockScalar(state, flowIndent)) ||\n              readSingleQuotedScalar(state, flowIndent) ||\n              readDoubleQuotedScalar(state, flowIndent)) {\n            hasContent = true;\n\n          } else if (readAlias(state)) {\n            hasContent = true;\n\n            if (state.tag !== null || state.anchor !== null) {\n              throwError(state, 'alias node should not have any properties');\n            }\n\n          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {\n            hasContent = true;\n\n            if (state.tag === null) {\n              state.tag = '?';\n            }\n          }\n\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n        }\n      } else if (indentStatus === 0) {\n        // Special case: block sequences are allowed to have same indentation level as the parent.\n        // http://www.yaml.org/spec/1.2/spec.html#id2799784\n        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);\n      }\n    }\n\n    if (state.tag === null) {\n      if (state.anchor !== null) {\n        state.anchorMap[state.anchor] = state.result;\n      }\n\n    } else if (state.tag === '?') {\n      // Implicit resolving is not allowed for non-scalar types, and '?'\n      // non-specific tag is only automatically assigned to plain scalars.\n      //\n      // We only need to check kind conformity in case user explicitly assigns '?'\n      // tag, for example like this: \"!<?> [0]\"\n      //\n      if (state.result !== null && state.kind !== 'scalar') {\n        throwError(state, 'unacceptable node kind for !<?> tag; it should be \"scalar\", not \"' + state.kind + '\"');\n      }\n\n      for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {\n        type = state.implicitTypes[typeIndex];\n\n        if (type.resolve(state.result)) { // `state.result` updated in resolver if matched\n          state.result = type.construct(state.result);\n          state.tag = type.tag;\n          if (state.anchor !== null) {\n            state.anchorMap[state.anchor] = state.result;\n          }\n          break;\n        }\n      }\n    } else if (state.tag !== '!') {\n      if (_hasOwnProperty$1.call(state.typeMap[state.kind || 'fallback'], state.tag)) {\n        type = state.typeMap[state.kind || 'fallback'][state.tag];\n      } else {\n        // looking for multi type\n        type = null;\n        typeList = state.typeMap.multi[state.kind || 'fallback'];\n\n        for (typeIndex = 0, typeQuantity = typeList.length; typeIndex < typeQuantity; typeIndex += 1) {\n          if (state.tag.slice(0, typeList[typeIndex].tag.length) === typeList[typeIndex].tag) {\n            type = typeList[typeIndex];\n            break;\n          }\n        }\n      }\n\n      if (!type) {\n        throwError(state, 'unknown tag !<' + state.tag + '>');\n      }\n\n      if (state.result !== null && type.kind !== state.kind) {\n        throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be \"' + type.kind + '\", not \"' + state.kind + '\"');\n      }\n\n      if (!type.resolve(state.result, state.tag)) { // `state.result` updated in resolver if matched\n        throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');\n      } else {\n        state.result = type.construct(state.result, state.tag);\n        if (state.anchor !== null) {\n          state.anchorMap[state.anchor] = state.result;\n        }\n      }\n    }\n\n    if (state.listener !== null) {\n      state.listener('close', state);\n    }\n    return state.tag !== null ||  state.anchor !== null || hasContent;\n  }\n\n  function readDocument(state) {\n    var documentStart = state.position,\n        _position,\n        directiveName,\n        directiveArgs,\n        hasDirectives = false,\n        ch;\n\n    state.version = null;\n    state.checkLineBreaks = state.legacy;\n    state.tagMap = Object.create(null);\n    state.anchorMap = Object.create(null);\n\n    while ((ch = state.input.charCodeAt(state.position)) !== 0) {\n      skipSeparationSpace(state, true, -1);\n\n      ch = state.input.charCodeAt(state.position);\n\n      if (state.lineIndent > 0 || ch !== 0x25/* % */) {\n        break;\n      }\n\n      hasDirectives = true;\n      ch = state.input.charCodeAt(++state.position);\n      _position = state.position;\n\n      while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n        ch = state.input.charCodeAt(++state.position);\n      }\n\n      directiveName = state.input.slice(_position, state.position);\n      directiveArgs = [];\n\n      if (directiveName.length < 1) {\n        throwError(state, 'directive name must not be less than one character in length');\n      }\n\n      while (ch !== 0) {\n        while (is_WHITE_SPACE(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        if (ch === 0x23/* # */) {\n          do { ch = state.input.charCodeAt(++state.position); }\n          while (ch !== 0 && !is_EOL(ch));\n          break;\n        }\n\n        if (is_EOL(ch)) break;\n\n        _position = state.position;\n\n        while (ch !== 0 && !is_WS_OR_EOL(ch)) {\n          ch = state.input.charCodeAt(++state.position);\n        }\n\n        directiveArgs.push(state.input.slice(_position, state.position));\n      }\n\n      if (ch !== 0) readLineBreak(state);\n\n      if (_hasOwnProperty$1.call(directiveHandlers, directiveName)) {\n        directiveHandlers[directiveName](state, directiveName, directiveArgs);\n      } else {\n        throwWarning(state, 'unknown document directive \"' + directiveName + '\"');\n      }\n    }\n\n    skipSeparationSpace(state, true, -1);\n\n    if (state.lineIndent === 0 &&\n        state.input.charCodeAt(state.position)     === 0x2D/* - */ &&\n        state.input.charCodeAt(state.position + 1) === 0x2D/* - */ &&\n        state.input.charCodeAt(state.position + 2) === 0x2D/* - */) {\n      state.position += 3;\n      skipSeparationSpace(state, true, -1);\n\n    } else if (hasDirectives) {\n      throwError(state, 'directives end mark is expected');\n    }\n\n    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);\n    skipSeparationSpace(state, true, -1);\n\n    if (state.checkLineBreaks &&\n        PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {\n      throwWarning(state, 'non-ASCII line breaks are interpreted as content');\n    }\n\n    state.documents.push(state.result);\n\n    if (state.position === state.lineStart && testDocumentSeparator(state)) {\n\n      if (state.input.charCodeAt(state.position) === 0x2E/* . */) {\n        state.position += 3;\n        skipSeparationSpace(state, true, -1);\n      }\n      return;\n    }\n\n    if (state.position < (state.length - 1)) {\n      throwError(state, 'end of the stream or a document separator is expected');\n    } else {\n      return;\n    }\n  }\n\n\n  function loadDocuments(input, options) {\n    input = String(input);\n    options = options || {};\n\n    if (input.length !== 0) {\n\n      // Add tailing `\\n` if not exists\n      if (input.charCodeAt(input.length - 1) !== 0x0A/* LF */ &&\n          input.charCodeAt(input.length - 1) !== 0x0D/* CR */) {\n        input += '\\n';\n      }\n\n      // Strip BOM\n      if (input.charCodeAt(0) === 0xFEFF) {\n        input = input.slice(1);\n      }\n    }\n\n    var state = new State$1(input, options);\n\n    var nullpos = input.indexOf('\\0');\n\n    if (nullpos !== -1) {\n      state.position = nullpos;\n      throwError(state, 'null byte is not allowed in input');\n    }\n\n    // Use 0 as string terminator. That significantly simplifies bounds check.\n    state.input += '\\0';\n\n    while (state.input.charCodeAt(state.position) === 0x20/* Space */) {\n      state.lineIndent += 1;\n      state.position += 1;\n    }\n\n    while (state.position < (state.length - 1)) {\n      readDocument(state);\n    }\n\n    return state.documents;\n  }\n\n\n  function loadAll$1(input, iterator, options) {\n    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {\n      options = iterator;\n      iterator = null;\n    }\n\n    var documents = loadDocuments(input, options);\n\n    if (typeof iterator !== 'function') {\n      return documents;\n    }\n\n    for (var index = 0, length = documents.length; index < length; index += 1) {\n      iterator(documents[index]);\n    }\n  }\n\n\n  function load$1(input, options) {\n    var documents = loadDocuments(input, options);\n\n    if (documents.length === 0) {\n      /*eslint-disable no-undefined*/\n      return undefined;\n    } else if (documents.length === 1) {\n      return documents[0];\n    }\n    throw new exception('expected a single document in the stream, but found more');\n  }\n\n\n  var loadAll_1 = loadAll$1;\n  var load_1    = load$1;\n\n  var loader = {\n    loadAll: loadAll_1,\n    load: load_1\n  };\n\n  /*eslint-disable no-use-before-define*/\n\n\n\n\n\n  var _toString       = Object.prototype.toString;\n  var _hasOwnProperty = Object.prototype.hasOwnProperty;\n\n  var CHAR_BOM                  = 0xFEFF;\n  var CHAR_TAB                  = 0x09; /* Tab */\n  var CHAR_LINE_FEED            = 0x0A; /* LF */\n  var CHAR_CARRIAGE_RETURN      = 0x0D; /* CR */\n  var CHAR_SPACE                = 0x20; /* Space */\n  var CHAR_EXCLAMATION          = 0x21; /* ! */\n  var CHAR_DOUBLE_QUOTE         = 0x22; /* \" */\n  var CHAR_SHARP                = 0x23; /* # */\n  var CHAR_PERCENT              = 0x25; /* % */\n  var CHAR_AMPERSAND            = 0x26; /* & */\n  var CHAR_SINGLE_QUOTE         = 0x27; /* ' */\n  var CHAR_ASTERISK             = 0x2A; /* * */\n  var CHAR_COMMA                = 0x2C; /* , */\n  var CHAR_MINUS                = 0x2D; /* - */\n  var CHAR_COLON                = 0x3A; /* : */\n  var CHAR_EQUALS               = 0x3D; /* = */\n  var CHAR_GREATER_THAN         = 0x3E; /* > */\n  var CHAR_QUESTION             = 0x3F; /* ? */\n  var CHAR_COMMERCIAL_AT        = 0x40; /* @ */\n  var CHAR_LEFT_SQUARE_BRACKET  = 0x5B; /* [ */\n  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D; /* ] */\n  var CHAR_GRAVE_ACCENT         = 0x60; /* ` */\n  var CHAR_LEFT_CURLY_BRACKET   = 0x7B; /* { */\n  var CHAR_VERTICAL_LINE        = 0x7C; /* | */\n  var CHAR_RIGHT_CURLY_BRACKET  = 0x7D; /* } */\n\n  var ESCAPE_SEQUENCES = {};\n\n  ESCAPE_SEQUENCES[0x00]   = '\\\\0';\n  ESCAPE_SEQUENCES[0x07]   = '\\\\a';\n  ESCAPE_SEQUENCES[0x08]   = '\\\\b';\n  ESCAPE_SEQUENCES[0x09]   = '\\\\t';\n  ESCAPE_SEQUENCES[0x0A]   = '\\\\n';\n  ESCAPE_SEQUENCES[0x0B]   = '\\\\v';\n  ESCAPE_SEQUENCES[0x0C]   = '\\\\f';\n  ESCAPE_SEQUENCES[0x0D]   = '\\\\r';\n  ESCAPE_SEQUENCES[0x1B]   = '\\\\e';\n  ESCAPE_SEQUENCES[0x22]   = '\\\\\"';\n  ESCAPE_SEQUENCES[0x5C]   = '\\\\\\\\';\n  ESCAPE_SEQUENCES[0x85]   = '\\\\N';\n  ESCAPE_SEQUENCES[0xA0]   = '\\\\_';\n  ESCAPE_SEQUENCES[0x2028] = '\\\\L';\n  ESCAPE_SEQUENCES[0x2029] = '\\\\P';\n\n  var DEPRECATED_BOOLEANS_SYNTAX = [\n    'y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON',\n    'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'\n  ];\n\n  var DEPRECATED_BASE60_SYNTAX = /^[-+]?[0-9_]+(?::[0-9_]+)+(?:\\.[0-9_]*)?$/;\n\n  function compileStyleMap(schema, map) {\n    var result, keys, index, length, tag, style, type;\n\n    if (map === null) return {};\n\n    result = {};\n    keys = Object.keys(map);\n\n    for (index = 0, length = keys.length; index < length; index += 1) {\n      tag = keys[index];\n      style = String(map[tag]);\n\n      if (tag.slice(0, 2) === '!!') {\n        tag = 'tag:yaml.org,2002:' + tag.slice(2);\n      }\n      type = schema.compiledTypeMap['fallback'][tag];\n\n      if (type && _hasOwnProperty.call(type.styleAliases, style)) {\n        style = type.styleAliases[style];\n      }\n\n      result[tag] = style;\n    }\n\n    return result;\n  }\n\n  function encodeHex(character) {\n    var string, handle, length;\n\n    string = character.toString(16).toUpperCase();\n\n    if (character <= 0xFF) {\n      handle = 'x';\n      length = 2;\n    } else if (character <= 0xFFFF) {\n      handle = 'u';\n      length = 4;\n    } else if (character <= 0xFFFFFFFF) {\n      handle = 'U';\n      length = 8;\n    } else {\n      throw new exception('code point within a string may not be greater than 0xFFFFFFFF');\n    }\n\n    return '\\\\' + handle + common.repeat('0', length - string.length) + string;\n  }\n\n\n  var QUOTING_TYPE_SINGLE = 1,\n      QUOTING_TYPE_DOUBLE = 2;\n\n  function State(options) {\n    this.schema        = options['schema'] || _default;\n    this.indent        = Math.max(1, (options['indent'] || 2));\n    this.noArrayIndent = options['noArrayIndent'] || false;\n    this.skipInvalid   = options['skipInvalid'] || false;\n    this.flowLevel     = (common.isNothing(options['flowLevel']) ? -1 : options['flowLevel']);\n    this.styleMap      = compileStyleMap(this.schema, options['styles'] || null);\n    this.sortKeys      = options['sortKeys'] || false;\n    this.lineWidth     = options['lineWidth'] || 80;\n    this.noRefs        = options['noRefs'] || false;\n    this.noCompatMode  = options['noCompatMode'] || false;\n    this.condenseFlow  = options['condenseFlow'] || false;\n    this.quotingType   = options['quotingType'] === '\"' ? QUOTING_TYPE_DOUBLE : QUOTING_TYPE_SINGLE;\n    this.forceQuotes   = options['forceQuotes'] || false;\n    this.replacer      = typeof options['replacer'] === 'function' ? options['replacer'] : null;\n\n    this.implicitTypes = this.schema.compiledImplicit;\n    this.explicitTypes = this.schema.compiledExplicit;\n\n    this.tag = null;\n    this.result = '';\n\n    this.duplicates = [];\n    this.usedDuplicates = null;\n  }\n\n  // Indents every line in a string. Empty lines (\\n only) are not indented.\n  function indentString(string, spaces) {\n    var ind = common.repeat(' ', spaces),\n        position = 0,\n        next = -1,\n        result = '',\n        line,\n        length = string.length;\n\n    while (position < length) {\n      next = string.indexOf('\\n', position);\n      if (next === -1) {\n        line = string.slice(position);\n        position = length;\n      } else {\n        line = string.slice(position, next + 1);\n        position = next + 1;\n      }\n\n      if (line.length && line !== '\\n') result += ind;\n\n      result += line;\n    }\n\n    return result;\n  }\n\n  function generateNextLine(state, level) {\n    return '\\n' + common.repeat(' ', state.indent * level);\n  }\n\n  function testImplicitResolving(state, str) {\n    var index, length, type;\n\n    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {\n      type = state.implicitTypes[index];\n\n      if (type.resolve(str)) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // [33] s-white ::= s-space | s-tab\n  function isWhitespace(c) {\n    return c === CHAR_SPACE || c === CHAR_TAB;\n  }\n\n  // Returns true if the character can be printed without escaping.\n  // From YAML 1.2: \"any allowed characters known to be non-printable\n  // should also be escaped. [However,] This isnâ€™t mandatory\"\n  // Derived from nb-char - \\t - #x85 - #xA0 - #x2028 - #x2029.\n  function isPrintable(c) {\n    return  (0x00020 <= c && c <= 0x00007E)\n        || ((0x000A1 <= c && c <= 0x00D7FF) && c !== 0x2028 && c !== 0x2029)\n        || ((0x0E000 <= c && c <= 0x00FFFD) && c !== CHAR_BOM)\n        ||  (0x10000 <= c && c <= 0x10FFFF);\n  }\n\n  // [34] ns-char ::= nb-char - s-white\n  // [27] nb-char ::= c-printable - b-char - c-byte-order-mark\n  // [26] b-char  ::= b-line-feed | b-carriage-return\n  // Including s-white (for some reason, examples doesn't match specs in this aspect)\n  // ns-char ::= c-printable - b-line-feed - b-carriage-return - c-byte-order-mark\n  function isNsCharOrWhitespace(c) {\n    return isPrintable(c)\n      && c !== CHAR_BOM\n      // - b-char\n      && c !== CHAR_CARRIAGE_RETURN\n      && c !== CHAR_LINE_FEED;\n  }\n\n  // [127]  ns-plain-safe(c) ::= c = flow-out  â‡’ ns-plain-safe-out\n  //                             c = flow-in   â‡’ ns-plain-safe-in\n  //                             c = block-key â‡’ ns-plain-safe-out\n  //                             c = flow-key  â‡’ ns-plain-safe-in\n  // [128] ns-plain-safe-out ::= ns-char\n  // [129]  ns-plain-safe-in ::= ns-char - c-flow-indicator\n  // [130]  ns-plain-char(c) ::=  ( ns-plain-safe(c) - â€œ:â€ - â€œ#â€ )\n  //                            | ( /* An ns-char preceding */ â€œ#â€ )\n  //                            | ( â€œ:â€ /* Followed by an ns-plain-safe(c) */ )\n  function isPlainSafe(c, prev, inblock) {\n    var cIsNsCharOrWhitespace = isNsCharOrWhitespace(c);\n    var cIsNsChar = cIsNsCharOrWhitespace && !isWhitespace(c);\n    return (\n      // ns-plain-safe\n      inblock ? // c = flow-in\n        cIsNsCharOrWhitespace\n        : cIsNsCharOrWhitespace\n          // - c-flow-indicator\n          && c !== CHAR_COMMA\n          && c !== CHAR_LEFT_SQUARE_BRACKET\n          && c !== CHAR_RIGHT_SQUARE_BRACKET\n          && c !== CHAR_LEFT_CURLY_BRACKET\n          && c !== CHAR_RIGHT_CURLY_BRACKET\n    )\n      // ns-plain-char\n      && c !== CHAR_SHARP // false on '#'\n      && !(prev === CHAR_COLON && !cIsNsChar) // false on ': '\n      || (isNsCharOrWhitespace(prev) && !isWhitespace(prev) && c === CHAR_SHARP) // change to true on '[^ ]#'\n      || (prev === CHAR_COLON && cIsNsChar); // change to true on ':[^ ]'\n  }\n\n  // Simplified test for values allowed as the first character in plain style.\n  function isPlainSafeFirst(c) {\n    // Uses a subset of ns-char - c-indicator\n    // where ns-char = nb-char - s-white.\n    // No support of ( ( â€œ?â€ | â€œ:â€ | â€œ-â€ ) /* Followed by an ns-plain-safe(c)) */ ) part\n    return isPrintable(c) && c !== CHAR_BOM\n      && !isWhitespace(c) // - s-white\n      // - (c-indicator ::=\n      // â€œ-â€ | â€œ?â€ | â€œ:â€ | â€œ,â€ | â€œ[â€ | â€œ]â€ | â€œ{â€ | â€œ}â€\n      && c !== CHAR_MINUS\n      && c !== CHAR_QUESTION\n      && c !== CHAR_COLON\n      && c !== CHAR_COMMA\n      && c !== CHAR_LEFT_SQUARE_BRACKET\n      && c !== CHAR_RIGHT_SQUARE_BRACKET\n      && c !== CHAR_LEFT_CURLY_BRACKET\n      && c !== CHAR_RIGHT_CURLY_BRACKET\n      // | â€œ#â€ | â€œ&â€ | â€œ*â€ | â€œ!â€ | â€œ|â€ | â€œ=â€ | â€œ>â€ | â€œ'â€ | â€œ\"â€\n      && c !== CHAR_SHARP\n      && c !== CHAR_AMPERSAND\n      && c !== CHAR_ASTERISK\n      && c !== CHAR_EXCLAMATION\n      && c !== CHAR_VERTICAL_LINE\n      && c !== CHAR_EQUALS\n      && c !== CHAR_GREATER_THAN\n      && c !== CHAR_SINGLE_QUOTE\n      && c !== CHAR_DOUBLE_QUOTE\n      // | â€œ%â€ | â€œ@â€ | â€œ`â€)\n      && c !== CHAR_PERCENT\n      && c !== CHAR_COMMERCIAL_AT\n      && c !== CHAR_GRAVE_ACCENT;\n  }\n\n  // Simplified test for values allowed as the last character in plain style.\n  function isPlainSafeLast(c) {\n    // just not whitespace or colon, it will be checked to be plain character later\n    return !isWhitespace(c) && c !== CHAR_COLON;\n  }\n\n  // Same as 'string'.codePointAt(pos), but works in older browsers.\n  function codePointAt(string, pos) {\n    var first = string.charCodeAt(pos), second;\n    if (first >= 0xD800 && first <= 0xDBFF && pos + 1 < string.length) {\n      second = string.charCodeAt(pos + 1);\n      if (second >= 0xDC00 && second <= 0xDFFF) {\n        // https://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae\n        return (first - 0xD800) * 0x400 + second - 0xDC00 + 0x10000;\n      }\n    }\n    return first;\n  }\n\n  // Determines whether block indentation indicator is required.\n  function needIndentIndicator(string) {\n    var leadingSpaceRe = /^\\n* /;\n    return leadingSpaceRe.test(string);\n  }\n\n  var STYLE_PLAIN   = 1,\n      STYLE_SINGLE  = 2,\n      STYLE_LITERAL = 3,\n      STYLE_FOLDED  = 4,\n      STYLE_DOUBLE  = 5;\n\n  // Determines which scalar styles are possible and returns the preferred style.\n  // lineWidth = -1 => no limit.\n  // Pre-conditions: str.length > 0.\n  // Post-conditions:\n  //    STYLE_PLAIN or STYLE_SINGLE => no \\n are in the string.\n  //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).\n  //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).\n  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth,\n    testAmbiguousType, quotingType, forceQuotes, inblock) {\n\n    var i;\n    var char = 0;\n    var prevChar = null;\n    var hasLineBreak = false;\n    var hasFoldableLine = false; // only checked if shouldTrackWidth\n    var shouldTrackWidth = lineWidth !== -1;\n    var previousLineBreak = -1; // count the first line correctly\n    var plain = isPlainSafeFirst(codePointAt(string, 0))\n            && isPlainSafeLast(codePointAt(string, string.length - 1));\n\n    if (singleLineOnly || forceQuotes) {\n      // Case: no block styles.\n      // Check for disallowed characters to rule out plain and single.\n      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n        char = codePointAt(string, i);\n        if (!isPrintable(char)) {\n          return STYLE_DOUBLE;\n        }\n        plain = plain && isPlainSafe(char, prevChar, inblock);\n        prevChar = char;\n      }\n    } else {\n      // Case: block styles permitted.\n      for (i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n        char = codePointAt(string, i);\n        if (char === CHAR_LINE_FEED) {\n          hasLineBreak = true;\n          // Check if any line can be folded.\n          if (shouldTrackWidth) {\n            hasFoldableLine = hasFoldableLine ||\n              // Foldable line = too long, and not more-indented.\n              (i - previousLineBreak - 1 > lineWidth &&\n               string[previousLineBreak + 1] !== ' ');\n            previousLineBreak = i;\n          }\n        } else if (!isPrintable(char)) {\n          return STYLE_DOUBLE;\n        }\n        plain = plain && isPlainSafe(char, prevChar, inblock);\n        prevChar = char;\n      }\n      // in case the end is missing a \\n\n      hasFoldableLine = hasFoldableLine || (shouldTrackWidth &&\n        (i - previousLineBreak - 1 > lineWidth &&\n         string[previousLineBreak + 1] !== ' '));\n    }\n    // Although every style can represent \\n without escaping, prefer block styles\n    // for multiline, since they're more readable and they don't add empty lines.\n    // Also prefer folding a super-long line.\n    if (!hasLineBreak && !hasFoldableLine) {\n      // Strings interpretable as another type have to be quoted;\n      // e.g. the string 'true' vs. the boolean true.\n      if (plain && !forceQuotes && !testAmbiguousType(string)) {\n        return STYLE_PLAIN;\n      }\n      return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n    }\n    // Edge case: block indentation indicator can only have one digit.\n    if (indentPerLevel > 9 && needIndentIndicator(string)) {\n      return STYLE_DOUBLE;\n    }\n    // At this point we know block styles are valid.\n    // Prefer literal style unless we want to fold.\n    if (!forceQuotes) {\n      return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;\n    }\n    return quotingType === QUOTING_TYPE_DOUBLE ? STYLE_DOUBLE : STYLE_SINGLE;\n  }\n\n  // Note: line breaking/folding is implemented for only the folded style.\n  // NB. We drop the last trailing newline (if any) of a returned block scalar\n  //  since the dumper adds its own newline. This always works:\n  //    â€¢ No ending newline => unaffected; already using strip \"-\" chomping.\n  //    â€¢ Ending newline    => removed then restored.\n  //  Importantly, this keeps the \"+\" chomp indicator from gaining an extra line.\n  function writeScalar(state, string, level, iskey, inblock) {\n    state.dump = (function () {\n      if (string.length === 0) {\n        return state.quotingType === QUOTING_TYPE_DOUBLE ? '\"\"' : \"''\";\n      }\n      if (!state.noCompatMode) {\n        if (DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1 || DEPRECATED_BASE60_SYNTAX.test(string)) {\n          return state.quotingType === QUOTING_TYPE_DOUBLE ? ('\"' + string + '\"') : (\"'\" + string + \"'\");\n        }\n      }\n\n      var indent = state.indent * Math.max(1, level); // no 0-indent scalars\n      // As indentation gets deeper, let the width decrease monotonically\n      // to the lower bound min(state.lineWidth, 40).\n      // Note that this implies\n      //  state.lineWidth â‰¤ 40 + state.indent: width is fixed at the lower bound.\n      //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.\n      // This behaves better than a constant minimum width which disallows narrower options,\n      // or an indent threshold which causes the width to suddenly increase.\n      var lineWidth = state.lineWidth === -1\n        ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent);\n\n      // Without knowing if keys are implicit/explicit, assume implicit for safety.\n      var singleLineOnly = iskey\n        // No block styles in flow mode.\n        || (state.flowLevel > -1 && level >= state.flowLevel);\n      function testAmbiguity(string) {\n        return testImplicitResolving(state, string);\n      }\n\n      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth,\n        testAmbiguity, state.quotingType, state.forceQuotes && !iskey, inblock)) {\n\n        case STYLE_PLAIN:\n          return string;\n        case STYLE_SINGLE:\n          return \"'\" + string.replace(/'/g, \"''\") + \"'\";\n        case STYLE_LITERAL:\n          return '|' + blockHeader(string, state.indent)\n            + dropEndingNewline(indentString(string, indent));\n        case STYLE_FOLDED:\n          return '>' + blockHeader(string, state.indent)\n            + dropEndingNewline(indentString(foldString(string, lineWidth), indent));\n        case STYLE_DOUBLE:\n          return '\"' + escapeString(string) + '\"';\n        default:\n          throw new exception('impossible error: invalid scalar style');\n      }\n    }());\n  }\n\n  // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.\n  function blockHeader(string, indentPerLevel) {\n    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : '';\n\n    // note the special case: the string '\\n' counts as a \"trailing\" empty line.\n    var clip =          string[string.length - 1] === '\\n';\n    var keep = clip && (string[string.length - 2] === '\\n' || string === '\\n');\n    var chomp = keep ? '+' : (clip ? '' : '-');\n\n    return indentIndicator + chomp + '\\n';\n  }\n\n  // (See the note for writeScalar.)\n  function dropEndingNewline(string) {\n    return string[string.length - 1] === '\\n' ? string.slice(0, -1) : string;\n  }\n\n  // Note: a long line without a suitable break point will exceed the width limit.\n  // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.\n  function foldString(string, width) {\n    // In folded style, $k$ consecutive newlines output as $k+1$ newlinesâ€”\n    // unless they're before or after a more-indented line, or at the very\n    // beginning or end, in which case $k$ maps to $k$.\n    // Therefore, parse each chunk as newline(s) followed by a content line.\n    var lineRe = /(\\n+)([^\\n]*)/g;\n\n    // first line (possibly an empty line)\n    var result = (function () {\n      var nextLF = string.indexOf('\\n');\n      nextLF = nextLF !== -1 ? nextLF : string.length;\n      lineRe.lastIndex = nextLF;\n      return foldLine(string.slice(0, nextLF), width);\n    }());\n    // If we haven't reached the first content line yet, don't add an extra \\n.\n    var prevMoreIndented = string[0] === '\\n' || string[0] === ' ';\n    var moreIndented;\n\n    // rest of the lines\n    var match;\n    while ((match = lineRe.exec(string))) {\n      var prefix = match[1], line = match[2];\n      moreIndented = (line[0] === ' ');\n      result += prefix\n        + (!prevMoreIndented && !moreIndented && line !== ''\n          ? '\\n' : '')\n        + foldLine(line, width);\n      prevMoreIndented = moreIndented;\n    }\n\n    return result;\n  }\n\n  // Greedy line breaking.\n  // Picks the longest line under the limit each time,\n  // otherwise settles for the shortest line over the limit.\n  // NB. More-indented lines *cannot* be folded, as that would add an extra \\n.\n  function foldLine(line, width) {\n    if (line === '' || line[0] === ' ') return line;\n\n    // Since a more-indented line adds a \\n, breaks can't be followed by a space.\n    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.\n    var match;\n    // start is an inclusive index. end, curr, and next are exclusive.\n    var start = 0, end, curr = 0, next = 0;\n    var result = '';\n\n    // Invariants: 0 <= start <= length-1.\n    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.\n    // Inside the loop:\n    //   A match implies length >= 2, so curr and next are <= length-2.\n    while ((match = breakRe.exec(line))) {\n      next = match.index;\n      // maintain invariant: curr - start <= width\n      if (next - start > width) {\n        end = (curr > start) ? curr : next; // derive end <= length-2\n        result += '\\n' + line.slice(start, end);\n        // skip the space that was output as \\n\n        start = end + 1;                    // derive start <= length-1\n      }\n      curr = next;\n    }\n\n    // By the invariants, start <= length-1, so there is something left over.\n    // It is either the whole string or a part starting from non-whitespace.\n    result += '\\n';\n    // Insert a break if the remainder is too long and there is a break available.\n    if (line.length - start > width && curr > start) {\n      result += line.slice(start, curr) + '\\n' + line.slice(curr + 1);\n    } else {\n      result += line.slice(start);\n    }\n\n    return result.slice(1); // drop extra \\n joiner\n  }\n\n  // Escapes a double-quoted string.\n  function escapeString(string) {\n    var result = '';\n    var char = 0;\n    var escapeSeq;\n\n    for (var i = 0; i < string.length; char >= 0x10000 ? i += 2 : i++) {\n      char = codePointAt(string, i);\n      escapeSeq = ESCAPE_SEQUENCES[char];\n\n      if (!escapeSeq && isPrintable(char)) {\n        result += string[i];\n        if (char >= 0x10000) result += string[i + 1];\n      } else {\n        result += escapeSeq || encodeHex(char);\n      }\n    }\n\n    return result;\n  }\n\n  function writeFlowSequence(state, level, object) {\n    var _result = '',\n        _tag    = state.tag,\n        index,\n        length,\n        value;\n\n    for (index = 0, length = object.length; index < length; index += 1) {\n      value = object[index];\n\n      if (state.replacer) {\n        value = state.replacer.call(object, String(index), value);\n      }\n\n      // Write only valid elements, put null instead of invalid elements.\n      if (writeNode(state, level, value, false, false) ||\n          (typeof value === 'undefined' &&\n           writeNode(state, level, null, false, false))) {\n\n        if (_result !== '') _result += ',' + (!state.condenseFlow ? ' ' : '');\n        _result += state.dump;\n      }\n    }\n\n    state.tag = _tag;\n    state.dump = '[' + _result + ']';\n  }\n\n  function writeBlockSequence(state, level, object, compact) {\n    var _result = '',\n        _tag    = state.tag,\n        index,\n        length,\n        value;\n\n    for (index = 0, length = object.length; index < length; index += 1) {\n      value = object[index];\n\n      if (state.replacer) {\n        value = state.replacer.call(object, String(index), value);\n      }\n\n      // Write only valid elements, put null instead of invalid elements.\n      if (writeNode(state, level + 1, value, true, true, false, true) ||\n          (typeof value === 'undefined' &&\n           writeNode(state, level + 1, null, true, true, false, true))) {\n\n        if (!compact || _result !== '') {\n          _result += generateNextLine(state, level);\n        }\n\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n          _result += '-';\n        } else {\n          _result += '- ';\n        }\n\n        _result += state.dump;\n      }\n    }\n\n    state.tag = _tag;\n    state.dump = _result || '[]'; // Empty sequence if no valid values.\n  }\n\n  function writeFlowMapping(state, level, object) {\n    var _result       = '',\n        _tag          = state.tag,\n        objectKeyList = Object.keys(object),\n        index,\n        length,\n        objectKey,\n        objectValue,\n        pairBuffer;\n\n    for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n\n      pairBuffer = '';\n      if (_result !== '') pairBuffer += ', ';\n\n      if (state.condenseFlow) pairBuffer += '\"';\n\n      objectKey = objectKeyList[index];\n      objectValue = object[objectKey];\n\n      if (state.replacer) {\n        objectValue = state.replacer.call(object, objectKey, objectValue);\n      }\n\n      if (!writeNode(state, level, objectKey, false, false)) {\n        continue; // Skip this pair because of invalid key;\n      }\n\n      if (state.dump.length > 1024) pairBuffer += '? ';\n\n      pairBuffer += state.dump + (state.condenseFlow ? '\"' : '') + ':' + (state.condenseFlow ? '' : ' ');\n\n      if (!writeNode(state, level, objectValue, false, false)) {\n        continue; // Skip this pair because of invalid value.\n      }\n\n      pairBuffer += state.dump;\n\n      // Both key and value are valid.\n      _result += pairBuffer;\n    }\n\n    state.tag = _tag;\n    state.dump = '{' + _result + '}';\n  }\n\n  function writeBlockMapping(state, level, object, compact) {\n    var _result       = '',\n        _tag          = state.tag,\n        objectKeyList = Object.keys(object),\n        index,\n        length,\n        objectKey,\n        objectValue,\n        explicitPair,\n        pairBuffer;\n\n    // Allow sorting keys so that the output file is deterministic\n    if (state.sortKeys === true) {\n      // Default sorting\n      objectKeyList.sort();\n    } else if (typeof state.sortKeys === 'function') {\n      // Custom sort function\n      objectKeyList.sort(state.sortKeys);\n    } else if (state.sortKeys) {\n      // Something is wrong\n      throw new exception('sortKeys must be a boolean or a function');\n    }\n\n    for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n      pairBuffer = '';\n\n      if (!compact || _result !== '') {\n        pairBuffer += generateNextLine(state, level);\n      }\n\n      objectKey = objectKeyList[index];\n      objectValue = object[objectKey];\n\n      if (state.replacer) {\n        objectValue = state.replacer.call(object, objectKey, objectValue);\n      }\n\n      if (!writeNode(state, level + 1, objectKey, true, true, true)) {\n        continue; // Skip this pair because of invalid key.\n      }\n\n      explicitPair = (state.tag !== null && state.tag !== '?') ||\n                     (state.dump && state.dump.length > 1024);\n\n      if (explicitPair) {\n        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n          pairBuffer += '?';\n        } else {\n          pairBuffer += '? ';\n        }\n      }\n\n      pairBuffer += state.dump;\n\n      if (explicitPair) {\n        pairBuffer += generateNextLine(state, level);\n      }\n\n      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {\n        continue; // Skip this pair because of invalid value.\n      }\n\n      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {\n        pairBuffer += ':';\n      } else {\n        pairBuffer += ': ';\n      }\n\n      pairBuffer += state.dump;\n\n      // Both key and value are valid.\n      _result += pairBuffer;\n    }\n\n    state.tag = _tag;\n    state.dump = _result || '{}'; // Empty mapping if no valid pairs.\n  }\n\n  function detectType(state, object, explicit) {\n    var _result, typeList, index, length, type, style;\n\n    typeList = explicit ? state.explicitTypes : state.implicitTypes;\n\n    for (index = 0, length = typeList.length; index < length; index += 1) {\n      type = typeList[index];\n\n      if ((type.instanceOf  || type.predicate) &&\n          (!type.instanceOf || ((typeof object === 'object') && (object instanceof type.instanceOf))) &&\n          (!type.predicate  || type.predicate(object))) {\n\n        if (explicit) {\n          if (type.multi && type.representName) {\n            state.tag = type.representName(object);\n          } else {\n            state.tag = type.tag;\n          }\n        } else {\n          state.tag = '?';\n        }\n\n        if (type.represent) {\n          style = state.styleMap[type.tag] || type.defaultStyle;\n\n          if (_toString.call(type.represent) === '[object Function]') {\n            _result = type.represent(object, style);\n          } else if (_hasOwnProperty.call(type.represent, style)) {\n            _result = type.represent[style](object, style);\n          } else {\n            throw new exception('!<' + type.tag + '> tag resolver accepts not \"' + style + '\" style');\n          }\n\n          state.dump = _result;\n        }\n\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  // Serializes `object` and writes it to global `result`.\n  // Returns true on success, or false on invalid object.\n  //\n  function writeNode(state, level, object, block, compact, iskey, isblockseq) {\n    state.tag = null;\n    state.dump = object;\n\n    if (!detectType(state, object, false)) {\n      detectType(state, object, true);\n    }\n\n    var type = _toString.call(state.dump);\n    var inblock = block;\n    var tagStr;\n\n    if (block) {\n      block = (state.flowLevel < 0 || state.flowLevel > level);\n    }\n\n    var objectOrArray = type === '[object Object]' || type === '[object Array]',\n        duplicateIndex,\n        duplicate;\n\n    if (objectOrArray) {\n      duplicateIndex = state.duplicates.indexOf(object);\n      duplicate = duplicateIndex !== -1;\n    }\n\n    if ((state.tag !== null && state.tag !== '?') || duplicate || (state.indent !== 2 && level > 0)) {\n      compact = false;\n    }\n\n    if (duplicate && state.usedDuplicates[duplicateIndex]) {\n      state.dump = '*ref_' + duplicateIndex;\n    } else {\n      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {\n        state.usedDuplicates[duplicateIndex] = true;\n      }\n      if (type === '[object Object]') {\n        if (block && (Object.keys(state.dump).length !== 0)) {\n          writeBlockMapping(state, level, state.dump, compact);\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + state.dump;\n          }\n        } else {\n          writeFlowMapping(state, level, state.dump);\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n          }\n        }\n      } else if (type === '[object Array]') {\n        if (block && (state.dump.length !== 0)) {\n          if (state.noArrayIndent && !isblockseq && level > 0) {\n            writeBlockSequence(state, level - 1, state.dump, compact);\n          } else {\n            writeBlockSequence(state, level, state.dump, compact);\n          }\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + state.dump;\n          }\n        } else {\n          writeFlowSequence(state, level, state.dump);\n          if (duplicate) {\n            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;\n          }\n        }\n      } else if (type === '[object String]') {\n        if (state.tag !== '?') {\n          writeScalar(state, state.dump, level, iskey, inblock);\n        }\n      } else if (type === '[object Undefined]') {\n        return false;\n      } else {\n        if (state.skipInvalid) return false;\n        throw new exception('unacceptable kind of an object to dump ' + type);\n      }\n\n      if (state.tag !== null && state.tag !== '?') {\n        // Need to encode all characters except those allowed by the spec:\n        //\n        // [35] ns-dec-digit    ::=  [#x30-#x39] /* 0-9 */\n        // [36] ns-hex-digit    ::=  ns-dec-digit\n        //                         | [#x41-#x46] /* A-F */ | [#x61-#x66] /* a-f */\n        // [37] ns-ascii-letter ::=  [#x41-#x5A] /* A-Z */ | [#x61-#x7A] /* a-z */\n        // [38] ns-word-char    ::=  ns-dec-digit | ns-ascii-letter | â€œ-â€\n        // [39] ns-uri-char     ::=  â€œ%â€ ns-hex-digit ns-hex-digit | ns-word-char | â€œ#â€\n        //                         | â€œ;â€ | â€œ/â€ | â€œ?â€ | â€œ:â€ | â€œ@â€ | â€œ&â€ | â€œ=â€ | â€œ+â€ | â€œ$â€ | â€œ,â€\n        //                         | â€œ_â€ | â€œ.â€ | â€œ!â€ | â€œ~â€ | â€œ*â€ | â€œ'â€ | â€œ(â€ | â€œ)â€ | â€œ[â€ | â€œ]â€\n        //\n        // Also need to encode '!' because it has special meaning (end of tag prefix).\n        //\n        tagStr = encodeURI(\n          state.tag[0] === '!' ? state.tag.slice(1) : state.tag\n        ).replace(/!/g, '%21');\n\n        if (state.tag[0] === '!') {\n          tagStr = '!' + tagStr;\n        } else if (tagStr.slice(0, 18) === 'tag:yaml.org,2002:') {\n          tagStr = '!!' + tagStr.slice(18);\n        } else {\n          tagStr = '!<' + tagStr + '>';\n        }\n\n        state.dump = tagStr + ' ' + state.dump;\n      }\n    }\n\n    return true;\n  }\n\n  function getDuplicateReferences(object, state) {\n    var objects = [],\n        duplicatesIndexes = [],\n        index,\n        length;\n\n    inspectNode(object, objects, duplicatesIndexes);\n\n    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {\n      state.duplicates.push(objects[duplicatesIndexes[index]]);\n    }\n    state.usedDuplicates = new Array(length);\n  }\n\n  function inspectNode(object, objects, duplicatesIndexes) {\n    var objectKeyList,\n        index,\n        length;\n\n    if (object !== null && typeof object === 'object') {\n      index = objects.indexOf(object);\n      if (index !== -1) {\n        if (duplicatesIndexes.indexOf(index) === -1) {\n          duplicatesIndexes.push(index);\n        }\n      } else {\n        objects.push(object);\n\n        if (Array.isArray(object)) {\n          for (index = 0, length = object.length; index < length; index += 1) {\n            inspectNode(object[index], objects, duplicatesIndexes);\n          }\n        } else {\n          objectKeyList = Object.keys(object);\n\n          for (index = 0, length = objectKeyList.length; index < length; index += 1) {\n            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);\n          }\n        }\n      }\n    }\n  }\n\n  function dump$1(input, options) {\n    options = options || {};\n\n    var state = new State(options);\n\n    if (!state.noRefs) getDuplicateReferences(input, state);\n\n    var value = input;\n\n    if (state.replacer) {\n      value = state.replacer.call({ '': value }, '', value);\n    }\n\n    if (writeNode(state, 0, value, true, true)) return state.dump + '\\n';\n\n    return '';\n  }\n\n  var dump_1 = dump$1;\n\n  var dumper = {\n    dump: dump_1\n  };\n\n  function renamed(from, to) {\n    return function () {\n      throw new Error('Function yaml.' + from + ' is removed in js-yaml 4. ' +\n        'Use yaml.' + to + ' instead, which is now safe by default.');\n    };\n  }\n\n\n  var Type                = type;\n  var Schema              = schema;\n  var FAILSAFE_SCHEMA     = failsafe;\n  var JSON_SCHEMA         = json;\n  var CORE_SCHEMA         = core;\n  var DEFAULT_SCHEMA      = _default;\n  var load                = loader.load;\n  var loadAll             = loader.loadAll;\n  export const dump = dumper.dump;\n  var YAMLException       = exception;\n\n  // Re-export all types in case user wants to create custom schema\n  var types = {\n    binary:    binary,\n    float:     float,\n    map:       map,\n    null:      _null,\n    pairs:     pairs,\n    set:       set,\n    timestamp: timestamp,\n    bool:      bool,\n    int:       int,\n    merge:     merge,\n    omap:      omap,\n    seq:       seq,\n    str:       str\n  };\n\n  // Removed functions from JS-YAML 3.0.x\n  var safeLoad            = renamed('safeLoad', 'load');\n  var safeLoadAll         = renamed('safeLoadAll', 'loadAll');\n  var safeDump            = renamed('safeDump', 'dump');\n\n  var jsYaml = {\n    Type: Type,\n    Schema: Schema,\n    FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,\n    JSON_SCHEMA: JSON_SCHEMA,\n    CORE_SCHEMA: CORE_SCHEMA,\n    DEFAULT_SCHEMA: DEFAULT_SCHEMA,\n    load: load,\n    loadAll: loadAll,\n    dump: dump,\n    YAMLException: YAMLException,\n    types: types,\n    safeLoad: safeLoad,\n    safeLoadAll: safeLoadAll,\n    safeDump: safeDump\n  };\n;"],"names":["isNothing","subject","common","isObject","toArray","sequence","Array","isArray","repeat","string","count","cycle","result","isNegativeZero","number","Number","NEGATIVE_INFINITY","extend","target","source","index","length","key","sourceKeys","Object","keys","formatError","exception","compact","where","message","reason","mark","name","line","column","snippet","YAMLException$1","Error","call","this","captureStackTrace","constructor","stack","prototype","create","toString","TYPE_CONSTRUCTOR_OPTIONS","YAML_NODE_KINDS","type","tag","options","forEach","indexOf","kind","resolve","construct","data","instanceOf","predicate","represent","representName","defaultStyle","multi","styleAliases","map","style","alias","String","compileStyleAliases","compileList","schema","currentType","newIndex","previousType","previousIndex","Schema$1","definition","implicit","explicit","push","concat","type$1","loadKind","compiledImplicit","compiledExplicit","compiledTypeMap","scalar","mapping","fallback","collectType","arguments","compileMap","str","seq","failsafe","_null","max","object","canonical","lowercase","uppercase","camelcase","empty","bool","isOctCode","c","isDecCode","int","ch","hasDigits","charCodeAt","value","sign","replace","slice","parseInt","binary","obj","octal","decimal","hexadecimal","toUpperCase","YAML_FLOAT_PATTERN","RegExp","SCIENTIFIC_WITHOUT_DOT","float","test","toLowerCase","POSITIVE_INFINITY","NaN","parseFloat","res","isNaN","json","core","YAML_DATE_REGEXP","YAML_TIMESTAMP_REGEXP","timestamp","exec","match","year","month","day","hour","minute","second","date","fraction","delta","Date","UTC","setTime","getTime","toISOString","merge","BASE64_MAP","code","idx","bitlen","charAt","tailbits","input","bits","Uint8Array","tail","_hasOwnProperty$3","hasOwnProperty","_toString$2","omap","pair","pairKey","pairHasKey","objectKeys","_toString$1","pairs","_hasOwnProperty$2","set","_default","simpleEscapeSequence","simpleEscapeCheck","simpleEscapeMap","i","_toString","_hasOwnProperty","ESCAPE_SEQUENCES","DEPRECATED_BOOLEANS_SYNTAX","DEPRECATED_BASE60_SYNTAX","encodeHex","character","handle","State","indent","Math","noArrayIndent","skipInvalid","flowLevel","styleMap","compileStyleMap","sortKeys","lineWidth","noRefs","noCompatMode","condenseFlow","quotingType","forceQuotes","replacer","implicitTypes","explicitTypes","duplicates","usedDuplicates","indentString","spaces","ind","position","next","generateNextLine","state","level","isWhitespace","isPrintable","isNsCharOrWhitespace","isPlainSafe","prev","inblock","cIsNsCharOrWhitespace","cIsNsChar","codePointAt","pos","first","needIndentIndicator","chooseScalarStyle","singleLineOnly","indentPerLevel","testAmbiguousType","char","prevChar","hasLineBreak","hasFoldableLine","shouldTrackWidth","previousLineBreak","plain","isPlainSafeLast","writeScalar","iskey","dump","min","testImplicitResolving","blockHeader","dropEndingNewline","width","moreIndented","lineRe","nextLF","lastIndex","foldLine","prevMoreIndented","prefix","foldString","escapeSeq","escapeString","indentIndicator","clip","end","breakRe","start","curr","writeBlockSequence","_result","_tag","writeNode","detectType","typeList","block","isblockseq","tagStr","duplicateIndex","duplicate","objectOrArray","objectKey","objectValue","explicitPair","pairBuffer","objectKeyList","sort","writeBlockMapping","writeFlowMapping","writeFlowSequence","encodeURI","getDuplicateReferences","objects","duplicatesIndexes","inspectNode","renamed","from","to"],"mappings":"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"}