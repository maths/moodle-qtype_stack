{"version":3,"file":"mutations.min.js","sources":["../../src/metadata/mutations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Default mutation manager\n *\n * @module     qtype_stack/metadata\n * @copyright  2025 University of Edinburgh\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later.\n */\nimport {metadata} from 'qtype_stack/metadata/metadata';\n\nclass Mutations {\n    /**\n     * Update state from array of input field information.\n     *\n     * Inputs have ids in form smdi-id-category-field e.g. smdi-1-contributor-year.\n     * id is row entry id in state. 0 is used for single elements e.g. license.\n     * Multi-elements begin counting from 1.\n     * For scope, row id is for one of the matching additional info rows.\n     * @param {*} stateManager\n     * @param {*} inputArray [['smdi-1-contributor-year', 2025], ...]\n     */\n    updateAll(stateManager, inputArray) {\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        for (const field of inputArray) {\n            const parts = field[0].split('_');\n            const id = parts[1];\n            const property = parts[2];\n            const subproperty = parts[3];\n            if (subproperty === 'scope') {\n                // Scope input updates multiple rows.\n                // We find all entries for that scope and update.\n                const existingScope = state.additional.get(id).scope;\n                if (existingScope !== field[1]) {\n                    state.additional.forEach((addInfo) => {\n                        if (addInfo.scope === existingScope) {\n                            addInfo.scope = field[1];\n                        }\n                    });\n                }\n            } else if (id != 0) {\n                const existing = state[property].get(id);\n                if (existing) {\n                    existing[subproperty] = field[1];\n                }\n            } else {\n                state[property][subproperty] = field[1];\n            }\n        }\n        // Force display refresh in odd circumstances where state has not changed\n        // but JSON needs to be updated.\n        state.metadataTicker.value += 1;\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Delete a row from the metadata form.\n     *\n     * @param {*} stateManager\n     * @param {*} property type to be deleted\n     * @param {*} id of instance to be deleted. Form will be refreshed and ids reset.\n     */\n    deleteRow(stateManager, property, id) {\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        if (property === 'scope') {\n            const matchingAddInfo = [];\n            const scope = state.additional.get(id).scope;\n            // Need to delete ALL entries with the same scope\n            // as the supplied additional info.\n            state.additional.forEach((addInfo) => {\n                if (addInfo.scope === scope) {\n                    matchingAddInfo.push(addInfo.id);\n                }\n            });\n            for (const current of matchingAddInfo) {\n                state.additional.delete(current);\n            }\n        } else {\n            state[property].delete(id);\n        }\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Add a row\n     *\n     * @param {*} stateManager\n     * @param {*} category\n     * @param {*} id Only required for additional info. Allows us to get relevant scope.\n     */\n    addItem(stateManager, category, id) {\n        const state = stateManager.state;\n        let addCategory = category;\n        let newItem = null;\n        let existingProperty = null;\n        switch (category) {\n            case 'language':\n                newItem = {\n                    value: \"\"\n                };\n                break;\n            case 'contributor':\n                newItem = {\n                    firstName: (id === 'user') ? metadata.lib.user.firstname : \"\",\n                    lastName: (id === 'user') ? metadata.lib.user.lastname : \"\",\n                    institution: (id === 'user') ? metadata.lib.user.institution : \"\",\n                    year: String(new Date().getFullYear())\n                };\n                break;\n            case 'scope':\n                newItem = {\n                    scope: '',\n                    property: '',\n                    qualifier: '',\n                    value: ''\n                };\n                addCategory = 'additional';\n                break;\n            case 'property':\n                existingProperty = state.additional.get(id);\n                newItem = {\n                    scope: existingProperty.scope,\n                    property: '',\n                    qualifier: '',\n                    value: ''\n                };\n                addCategory = 'additional';\n                break;\n            default:\n        }\n\n        // Ids are required for all objects. We add one to highest existing id.\n        const keys = Array.from(state[addCategory]);\n        if (keys.length === 0) {\n            newItem.id = 1;\n        } else {\n            keys.sort((a, b) => b[0] - a[0]);\n            newItem.id = 1 + parseInt(keys[0][0]);\n        }\n        stateManager.setReadOnly(false);\n        state[addCategory].add(newItem);\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * Straight update of state.\n     *\n     * @param {*} stateManager\n     * @param {object} data Output of metadata.jsonToState\n     */\n    updateFromJson(stateManager, data) {\n        const state = stateManager.state;\n        stateManager.setReadOnly(false);\n        for (const prop in data) {\n            state[prop] = data[prop];\n        }\n        // Force display refresh in case inputs have been altered but JSON not changed.\n        // Inputs will be matched to JSON.\n        state.metadataTicker.value += 1;\n        stateManager.setReadOnly(true);\n    }\n}\n\nexport const mutations = new Mutations();"],"names":["mutations","updateAll","stateManager","inputArray","state","setReadOnly","field","parts","split","id","property","subproperty","existingScope","additional","get","scope","forEach","addInfo","existing","metadataTicker","value","deleteRow","matchingAddInfo","push","current","delete","addItem","category","addCategory","newItem","existingProperty","firstName","metadata","lib","user","firstname","lastName","lastname","institution","year","String","Date","getFullYear","qualifier","keys","Array","from","length","sort","a","b","parseInt","add","updateFromJson","data","prop"],"mappings":"0MAkLaA,UAAY;;;;;;;;MA/IrBC,UAAUC,aAAcC,kBACdC,MAAQF,aAAaE,MAC3BF,aAAaG,aAAY,OACpB,MAAMC,SAASH,WAAY,OACtBI,MAAQD,MAAM,GAAGE,MAAM,KACvBC,GAAKF,MAAM,GACXG,SAAWH,MAAM,GACjBI,YAAcJ,MAAM,MACN,UAAhBI,YAAyB,OAGnBC,cAAgBR,MAAMS,WAAWC,IAAIL,IAAIM,MAC3CH,gBAAkBN,MAAM,IACxBF,MAAMS,WAAWG,SAASC,UAClBA,QAAQF,QAAUH,gBAClBK,QAAQF,MAAQT,MAAM,YAI/B,GAAU,GAANG,GAAS,OACVS,SAAWd,MAAMM,UAAUI,IAAIL,IACjCS,WACAA,SAASP,aAAeL,MAAM,SAGlCF,MAAMM,UAAUC,aAAeL,MAAM,GAK7CF,MAAMe,eAAeC,OAAS,EAC9BlB,aAAaG,aAAY,GAU7BgB,UAAUnB,aAAcQ,SAAUD,UACxBL,MAAQF,aAAaE,SAC3BF,aAAaG,aAAY,GACR,UAAbK,SAAsB,OAChBY,gBAAkB,GAClBP,MAAQX,MAAMS,WAAWC,IAAIL,IAAIM,MAGvCX,MAAMS,WAAWG,SAASC,UAClBA,QAAQF,QAAUA,OAClBO,gBAAgBC,KAAKN,QAAQR,WAGhC,MAAMe,WAAWF,gBAClBlB,MAAMS,WAAWY,OAAOD,cAG5BpB,MAAMM,UAAUe,OAAOhB,IAE3BP,aAAaG,aAAY,GAU7BqB,QAAQxB,aAAcyB,SAAUlB,UACtBL,MAAQF,aAAaE,UACvBwB,YAAcD,SACdE,QAAU,KACVC,iBAAmB,YACfH,cACC,WACDE,QAAU,CACNT,MAAO,cAGV,cACDS,QAAU,CACNE,UAAmB,SAAPtB,GAAiBuB,mBAASC,IAAIC,KAAKC,UAAY,GAC3DC,SAAkB,SAAP3B,GAAiBuB,mBAASC,IAAIC,KAAKG,SAAW,GACzDC,YAAqB,SAAP7B,GAAiBuB,mBAASC,IAAIC,KAAKI,YAAc,GAC/DC,KAAMC,QAAO,IAAIC,MAAOC,0BAG3B,QACDb,QAAU,CACNd,MAAO,GACPL,SAAU,GACViC,UAAW,GACXvB,MAAO,IAEXQ,YAAc,uBAEb,WACDE,iBAAmB1B,MAAMS,WAAWC,IAAIL,IACxCoB,QAAU,CACNd,MAAOe,iBAAiBf,MACxBL,SAAU,GACViC,UAAW,GACXvB,MAAO,IAEXQ,YAAc,mBAMhBgB,KAAOC,MAAMC,KAAK1C,MAAMwB,cACV,IAAhBgB,KAAKG,OACLlB,QAAQpB,GAAK,GAEbmC,KAAKI,MAAK,CAACC,EAAGC,IAAMA,EAAE,GAAKD,EAAE,KAC7BpB,QAAQpB,GAAK,EAAI0C,SAASP,KAAK,GAAG,KAEtC1C,aAAaG,aAAY,GACzBD,MAAMwB,aAAawB,IAAIvB,SACvB3B,aAAaG,aAAY,GAS7BgD,eAAenD,aAAcoD,YACnBlD,MAAQF,aAAaE,MAC3BF,aAAaG,aAAY,OACpB,MAAMkD,QAAQD,KACflD,MAAMmD,MAAQD,KAAKC,MAIvBnD,MAAMe,eAAeC,OAAS,EAC9BlB,aAAaG,aAAY"}