{"version":3,"file":"mutations.min.js","sources":["../../src/metadata/mutations.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Default mutation manager\n *\n * @module     mod_nosferatu/local/beginner/mutations\n * @class     mod_nosferatu/local/beginner/mutations\n * @copyright  2021 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nclass Mutations {\n    /**\n     * Bite a person.\n     *\n     * All mutations recive a StateManager object as a first parameter. Whith this object the mutation\n     * can acces the state (stateManager.state) but also set the read mode (statemanager.setReadOnly(true|false)).\n     * In next steps we will see some other stateManager features. But for now you don't need them.\n     *\n     * @param {StateManager} stateManager the current state manager\n     * @param {Number} personId the person id to bite\n     */\n    bite(stateManager, personId) {\n        // The first thing we need to do is get the current state.\n        const state = stateManager.state;\n        // State is always on read mode. To change any value first we need to unlock it.\n        stateManager.setReadOnly(false);\n        // Now we do as many state changes as we need.\n        state.people.get(personId).bitten = true;\n        // All mutations should restore the read mode. This will trigger all the reactive events.\n        stateManager.setReadOnly(true);\n    }\n\n    /**\n     * The cureAll mutation.\n     *\n     * @param {StateManager} stateManager the current state manager\n     */\n    cureAll(stateManager) {\n        // We call our hipotetical webservice.\n        const result = this._callCureAll(stateManager.state);\n        // And now we send the results to the stateManager.\n        stateManager.processUpdates(result);\n    }\n    /**\n     * Ok. we don't have a webservice yet, so we fake it.\n     *\n     * @param {object} state if this was a real webservice we probably won't need the full state.\n     * @returns {array} the state updates object.\n     */\n    _callCureAll(state) {\n        const result = [];\n        state.people.forEach(person => {\n            result.push({\n                name: 'people',\n                action: 'update',\n                fields: {\n                    ...person,\n                    bitten: false,\n                }\n            });\n        });\n        return result;\n    }\n}\n\nexport const mutations = new Mutations();"],"names":["mutations","bite","stateManager","personId","state","setReadOnly","people","get","bitten","cureAll","result","this","_callCureAll","processUpdates","forEach","person","push","name","action","fields"],"mappings":"gKA8EaA,UAAY;;;;;;;;;MA5CrBC,KAAKC,aAAcC,gBAETC,MAAQF,aAAaE,MAE3BF,aAAaG,aAAY,GAEzBD,MAAME,OAAOC,IAAIJ,UAAUK,QAAS,EAEpCN,aAAaG,aAAY,GAQ7BI,QAAQP,oBAEEQ,OAASC,KAAKC,aAAaV,aAAaE,OAE9CF,aAAaW,eAAeH,QAQhCE,aAAaR,aACHM,OAAS,UACfN,MAAME,OAAOQ,SAAQC,SACjBL,OAAOM,KAAK,CACRC,KAAM,SACNC,OAAQ,SACRC,OAAQ,IACDJ,OACHP,QAAQ,QAIbE"}