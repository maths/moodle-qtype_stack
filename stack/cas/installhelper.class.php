<?php
// This file is part of Stack - http://stack.maths.ed.ac.uk/
//
// Stack is free software: you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation, either version 3 of the License, or
// (at your option) any later version.
//
// Stack is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with Stack.  If not, see <http://www.gnu.org/licenses/>.

defined('MOODLE_INTERNAL') || die();

// The file provides helper code for creating the files needed to connect to the CAS.

require_once(__DIR__.'/../../../../../config.php');

require_once(__DIR__ . '/../../locallib.php');
require_once(__DIR__ . '/../utils.class.php');
require_once(__DIR__ . '/casstring.units.class.php');
require_once(__DIR__ . '/connectorhelper.class.php');
require_once(__DIR__ . '/cassession.class.php');
require_once(__DIR__ . '/platforms.php');


class stack_cas_configuration {
    protected static $instance = null;

    /** @var array This variable controls which optional packages are supported by STACK. */
    public static $maximalibraries = array('stats', 'distrib', 'descriptive', 'simplex');

    protected $settings;

    /** @var string the date when these settings were worked out. */
    protected $date;

    protected $maximacodepath;

    protected $logpath;

    protected $vnum;

    protected $blocksettings;

    /**
     * Constructor, initialises all the settings.
     */
    public function __construct() {
        global $CFG;
        $this->settings = stack_utils::get_config();
        /* @var stack_platform_base $platform */
        $platform = stack_platform_base::get_current();
        $this->date = date("F j, Y, g:i a");

        $this->maximacodepath = stack_utils::convert_slash_paths(
                $CFG->dirroot . '/question/type/stack/stack/maxima');

        $this->logpath = stack_utils::convert_slash_paths($CFG->dataroot . '/stack/logs');

        $this->vnum = (float) substr($this->settings->maximaversion, 2);

        $this->blocksettings = array();
        $this->blocksettings['MAXIMA_PLATFORM'] = $platform->get_name();
        $this->blocksettings['maxima_tempdir'] = stack_utils::convert_slash_paths($CFG->dataroot . '/stack/tmp/');
        $this->blocksettings['IMAGE_DIR']     = stack_utils::convert_slash_paths($CFG->dataroot . '/stack/plots/');

        $this->blocksettings['PLOT_SIZE'] = '[450,300]';
        // These are used by the GNUplot "set terminal" command. Currently no user interface...
        $this->blocksettings['PLOT_TERMINAL'] = 'png';
        $this->blocksettings['PLOT_TERM_OPT'] = 'large transparent';
        $this->blocksettings['PLOT_TERMINAL'] = 'svg';
        // Note, the quotes need to be protected below.
        $this->blocksettings['PLOT_TERM_OPT'] = 'dynamic font \",11\" linewidth 1.2';
        
        $this->blocksettings['DEL_CMD'] = $platform->get_remove_command();
        
        $maximacommand = $platform->get_maxima_command();
        if($maximacommand == NULL) {
            throw new stack_exception('Could not locate Maxima.');
        } else {
            $plotcommand = $platform->get_plot_command();
            if($plotcommand == NULL) {
                throw new stack_exception('Could not locate GNUPLOT.');
            } else {
                $this->blocksettings['GNUPLOT_CMD'] = $plotcommand;
                $this->blocksettings['DEL_CMD']     = $platform->get_remove_command();
            }
        }

        // Loop over this array to format them correctly...
        if (! $platform->are_all_pathnames_portable()) {
            foreach ($this->blocksettings as $var => $val) {
                // Only escape variables that refer to paths; e.g. leave font in PLOT_TERM_OPT alone.
                if(preg_match("/([^A-Za-z]|^)(CMD|PATH|FILE|DIR)([^A-Za-z]|$)/", $var) > 0) {
                    $this->blocksettings[$var] = addslashes($platform->pathname_to_native($val));
                }
            }
        }

        $this->blocksettings['MAXIMA_VERSION_EXPECTED'] = $this->settings->maximaversion;
        $this->blocksettings['URL_BASE']       = '!ploturl!';
//        if ($this->settings->platform === 'win') {
//            $this->blocksettings['URL_BASE']       = '!ploturl!/';
//        }
    }


    public function get_maximalocal_contents() {
        $platform = stack_platform_base::get_current();
        $contents = <<<END
/* ***********************************************************************/
/* This file is automatically generated at installation time.            */
/* The purpose is to transfer configuration settings to Maxima.          */
/* Hence, you should not edit this file.  Edit your configuration.       */
/* This file is regularly overwritten, so your changes will be lost.     */
/* ***********************************************************************/

/* File generated on {$this->date} */

/* Add the location to Maxima's search path */
file_search_maxima:append( [sconcat("{$this->maximacodepath}/###.{mac,mc}")] , file_search_maxima)$
file_search_lisp:append( [sconcat("{$this->maximacodepath}/###.{lisp}")] , file_search_lisp)$
file_search_maxima:append( [sconcat("{$this->logpath}/###.{mac,mc}")] , file_search_maxima)$
file_search_lisp:append( [sconcat("{$this->logpath}/###.{lisp}")] , file_search_lisp)$

STACK_SETUP(ex):=block(
    MAXIMA_VERSION_NUM_EXPECTED:{$this->vnum},

END;
        foreach ($this->blocksettings as $name => $value) {
            if ($name == 'PLOT_SIZE') {
                $contents .= <<<END
    {$name}:{$value},

END;
            } else {
                $contents .= <<<END
    {$name}:"{$value}",

END;
            }
        }
        $contents .= stack_cas_casstring_units::maximalocal_units();
        $contents .= <<<END
    true)$

END;

        if ($platform->is_optimised()) {
            $contents .= <<<END
/* We are using an optimised lisp image with maxima and the stack libraries
   pre-loaded. That is why you don't see the familiar load("stackmaxima.mac")$ here.
   We do need to ensure the values of the variables is reset now.
*/
STACK_SETUP(true);
END;

        } else {
            $contents .= <<<END
/* Load the main libraries. */
load("stackmaxima.mac")$

END;
            $maximalib = explode(', ', $this->settings->maximalibraries);
            foreach ($maximalib as $lib) {
                $lib = trim($lib);
                // Only include and load supported libraries.
                if (in_array($lib, self::$maximalibraries)) {
                    $contents .= 'load("'.$lib.'")$'."\n";
                }
            }

        }

        $contents .= 'print(sconcat("[ STACK-Maxima started, library version ", stackmaximaversion, " ]"))$'."\n";

        return $contents;
    }

    /**
     * @return stack_cas_configuration the singleton instance of this class.
     */
    protected static function get_instance() {
        if (is_null(self::$instance)) {
            self::$instance = new self();
        }
        return self::$instance;
    }

    /**
     * Get the full path for the maximalocal.mac file.
     * @return string the full path to where the maximalocal.mac file should be stored.
     */
    public static function maximalocal_location() {
        global $CFG;
        return stack_utils::convert_slash_paths($CFG->dataroot . '/stack/maximalocal.mac');
    }

    /**
     * Get the full path to the folder where plot files are stored.
     * @return string the full path to where the maximalocal.mac file should be stored.
     */
    public static function images_location() {
        global $CFG;
        return stack_utils::convert_slash_paths($CFG->dataroot . '/stack/plots');
    }

    /**
     * Create the maximalocal.mac file, overwriting it if it already exists.
     */
    public static function create_maximalocal() {
        $platform = stack_platform_base::get_current();
        $errors = array(); $cmiRW = $platform->check_maxima_install();
        extract($cmiRW);
        if($errors) {
            throw new stack_exception(stack_string('errormaximalocalunresolvederrors'));
        }
        
        make_upload_directory('stack');
        make_upload_directory('stack/logs');
        make_upload_directory('stack/plots');
        make_upload_directory('stack/tmp');

        if (!file_put_contents(self::maximalocal_location(), self::generate_maximalocal_contents())) {
            throw new stack_exception('Failed to write Maxima configuration file.');
        }
    }

    public static function check_maximalocal() {
        $instance = self::get_instance();
        $cts = (empty($instance->settings->criticalsettingsupdated) || !$instance->settings->criticalsettingsupdated) ?
                0 : (int)$instance->settings->criticalsettingsupdated;
        $mlfn = self::maximalocal_location();
        $mlts = is_file($mlfn) ? filemtime($mlfn) : 0;
        return $mlts > $cts;
    }
    
    /**
     * Generate the contents for the maximalocal configuration file.
     * @return string the contents that the maximalocal.mac file should have.
     */
    public static function generate_maximalocal_contents() {
        return self::get_instance()->get_maximalocal_contents();
    }

    /**
     * This function checks the current setting match to the supported packages.
     */
    protected function get_validate_maximalibraries() {

        $valid = true;
        $message = '';
        $maximalib = explode(', ', $this->settings->maximalibraries);
        foreach ($maximalib as $lib) {
            $lib = trim($lib);
            // Only include and load supported libraries.
            if ($lib !== '' && !in_array($lib, self::$maximalibraries)) {
                $valid = false;
                $a = $lib;
                $message .= stack_string('settingmaximalibraries_error', $a);
            }
        }
        return(array($valid, $message));
    }

    /**
     * This function checks the current setting match to the supported packages.
     */
    public static function validate_maximalibraries() {
        return self::get_instance()->get_validate_maximalibraries();
    }

    /**
     * This function genuinely recreates the maxima image and stores the results in
     * the configuration settings.
     * 
     * @return array Returns an array [0] => TRUE if successful, FALSE otherwise; [1] => error message.
     */
    public static function create_auto_maxima_image() {
        $config = stack_utils::get_config();
        $platform = stack_platform_base::get_current();
        $rv = $platform->can_be_auto_optimised();
            // Do not try to generate the optimised image on platforms that do not support it, e.g.
            // MS + GCL platforms.
        if (TRUE !== $rv) {
            return array(false, $platform->get_no_opt_reason());
        }

        /*
         * Revert to the non-optimised platform.  This will genuinely call the CAS, and
         * as a result create a new image.
         */
        $oldplatform = $platform->get_name();
        $oldmaximacommand = $config->maximacommand;
        $oldlibraries = $config->maximalibraries;
        $nonoptplatform = $platform->non_optimised()->get_name();
        $config->platform =  $nonoptplatform;
        $config->maximacommand =  $platform->get_maxima_preopt_command();

        // Try to make a new version of the maxima local file.
        self::create_maximalocal();
        if($platform->requires_launch_script() && ! $config->bypasslaunchscript) {
            $platform->generate_launch_script();
        }
        // Try to actually connect to Maxima.
        list($message, $genuinedebug, $result) = stack_connection_helper::stackmaxima_genuine_connect();

        // Check if the libraries look like they are messing things up.
        if (strpos($genuinedebug, 'eval_string not found') > 0) {
            // If so, get rid of the libraries and try again.
            $config->maximalibraries =  '';
            list($message, $genuinedebug, $result) = stack_connection_helper::stackmaxima_genuine_connect();
        }

        $revert = false;
        if ($result) {
            // Try to auto make the optimised image.
            list($message, $genuinedebug, $result, )
                 = stack_connection_helper::stackmaxima_auto_maxima_optimise($genuinedebug);

            if ($result) {
                $optplatform = $platform->optimised();
                $optplatformname = $optplatform->get_name();
                $config->platform =  $optplatformname;
                $config->maximacommand =  '';

                self::create_maximalocal();
                if($optplatform->requires_launch_script() && ! $config->bypasslaunchscript) {
                    $optplatform->generate_launch_script();
                }

                // Now we need to check this actually works.
                $cs = new stack_cas_casstring('a:1+1');
                $ts = new stack_cas_session(array($cs));
                $ts->instantiate();
                if ($ts->get_value_key('a') != '2') {
                    $errors = $ts->get_errors();
                    $errmsg = "Evaluation test failed, errors:$errors";
                    $revert = true;
                }
            } else {
                $errmsg = "Automake failed";
                $revert = true;
            }
        } else {
            $errmsg = "Uncached connection failed.";
            $revert = true;
        }

        if ($revert) {
            $config->platform =  $oldplatform;
            $config->maximacommand =  $oldmaximacommand;
            $config->maximalibraries =  $oldlibraries;
            self::create_maximalocal();
            if($platform->requires_launch_script() && ! $config->bypasslaunchscript) {
                $platform->generate_launch_script();
            }
            return array(false, $errmsg);
        } else {
            return array(true, "DONE.");
        }
    }
}
