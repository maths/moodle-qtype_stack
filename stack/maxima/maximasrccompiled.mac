/* Result of compilation do not edit. */
sbasen_convert_to_binary(%_si1,%_si2):=block([%_si3],%_si3:if integerp(%_si1) then sbasen_construct_from_base10(%_si1,%_si2,2) else (%_si1:sbasen_convert_to_base10(%_si1),sbasen_construct_from_base10(%_si1,%_si2,2)),return(%_si3))$
sbasen_bitwise_eval(%_si16):=block([simp,%_si17,%_si18,%_si19,%_si20,%_si21,%_si22,%_si23],%_si17:1,for %_si18 in extract_matching_parts(lambda([%_si14],is(safe_op(%_si14) = "stackbasen")),%_si16) do (if is(third(%_si18) = 2) then (%_si17:ev(max(%_si17,length(sbasen_convert_to_digits(%_si18))),simp)) elseif is(third(%_si18) = 8) then (%_si17:ev(max(%_si17,3*length(sbasen_convert_to_digits(%_si18))),simp)) elseif is(third(%_si18) = 16) then (%_si17:ev(max(%_si17,4*length(sbasen_convert_to_digits(%_si18))),simp))),%_si19:lambda([%_si1],member(safe_op(%_si1),["not","and","or","nand","nor","xor","xnor"]) and all_listp(lambda([%_si13],is(safe_op(%_si13) = "stackbasen") and (is(third(%_si13) = 2) or is(third(%_si13) = 8) or is(third(%_si13) = 16))),args(%_si1))),%_si21:true,while %_si21 do (%_si21:false,for %_si18 in extract_matching_parts(%_si19,%_si16) do (%_si20:map(lambda([%_si12],map(lambda([%_si15],is(%_si15 > 0)),sbasen_convert_to_digits(sbasen_pad(sbasen_convert_to_binary(%_si12,"S"),%_si17)))),args(%_si18)),%_si23:makelist(false,%_si22,1,%_si17),if is(safe_op(%_si18) = "not") then (%_si21:stackbasen(sconcat(simplode(map(lambda([%_si11],if %_si11 then "0" else "1"),%_si20[1])),"_2"),"S",2),%_si16:subst(%_si21,%_si18,%_si16)) elseif is(safe_op(%_si18) = "nand") then (for %_si22:1 thru %_si17 do (%_si23[%_si22]:not apply("and",map(lambda([%_si10],%_si10[%_si22]),%_si20))),%_si21:stackbasen(sconcat(simplode(map(lambda([%_si9],if %_si9 then "1" else "0"),%_si23)),"_2"),"S",2),%_si16:subst(%_si21,%_si18,%_si16)) elseif is(safe_op(%_si18) = "nor") then (for %_si22:1 thru %_si17 do (%_si23[%_si22]:not apply("or",map(lambda([%_si8],%_si8[%_si22]),%_si20))),%_si21:stackbasen(sconcat(simplode(map(lambda([%_si7],if %_si7 then "1" else "0"),%_si23)),"_2"),"S",2),%_si16:subst(%_si21,%_si18,%_si16)) elseif is(safe_op(%_si18) = "xor") or is(safe_op(%_si18) = "xnor") then (for %_si22:1 thru %_si17 do (%_si23[%_si22]:is(mod(apply("+",map(lambda([%_si6],if %_si6[%_si22] then 1 else 0),%_si20)),2) = 1)),%_si21:if is(safe_op(%_si18) = "xor") then stackbasen(sconcat(simplode(map(lambda([%_si5],if %_si5 then "1" else "0"),%_si23)),"_2"),"S",2) else stackbasen(sconcat(simplode(map(lambda([%_si4],if %_si4 then "0" else "1"),%_si23)),"_2"),"S",2),%_si16:subst(%_si21,%_si18,%_si16)) else (for %_si22:1 thru %_si17 do (%_si23[%_si22]:apply(safe_op(%_si18),map(lambda([%_si3],%_si3[%_si22]),%_si20))),%_si21:stackbasen(sconcat(simplode(map(lambda([%_si2],if %_si2 then "1" else "0"),%_si23)),"_2"),"S",2),%_si16:subst(%_si21,%_si18,%_si16)),%_si21:true)),return(%_si16))$
sbasen_pad(%_si2,%_si3):=block([simp,%_si4,%_si5,%_si6,%_si7,%_si8],simp:true,[%_si4,%_si5,%_si6]:args(%_si2),%_si8:"",%_si7:"",if is(%_si5 = "S") then (%_si8:sconcat("_",%_si6),%_si4:split(%_si4,"_")[1]) elseif is(%_si5 = "C") and is(%_si6 = 8) then (%_si7:"0",%_si4:substring(%_si4,2)) elseif is(%_si5 = "C") and is(%_si6 = 16) then (%_si7:"0x",%_si4:substring(%_si4,3)) elseif is(%_si5 = "C") then (%_si7:"0b",%_si4:substring(%_si4,3)),if is(slength(%_si4) >= %_si3) then return(%_si2),%_si4:sconcat(simplode(makelist("0",%_si1,1,%_si3-slength(%_si4))),%_si4),return(stackbasen(sconcat(%_si7,%_si4,%_si8),%_si5,%_si6)))$
sbasen_truncate_left(%_si1,%_si2):=block([simp,%_si3,%_si4,%_si5,%_si6,%_si7],simp:true,[%_si3,%_si4,%_si5]:args(%_si1),%_si7:"",%_si6:"",if is(%_si4 = "S") then (%_si7:sconcat("_",%_si5),%_si3:split(%_si3,"_")[1]) elseif is(%_si4 = "C") and is(%_si5 = 8) then (%_si6:"0",substring(%_si3,2)) elseif is(%_si4 = "C") and is(%_si5 = 16) then (%_si6:"0x",substring(%_si3,3)) elseif is(%_si4 = "C") then (%_si6:"0b",substring(%_si3,3)),if is(slength(%_si3) <= %_si2) then return(%_si1),%_si3:substring(%_si3,slength(%_si3)-%_si2+1),return(stackbasen(sconcat(%_si6,%_si3,%_si7),%_si4,%_si5)))$
sbasen_truncate_right(%_si1,%_si2):=block([simp,%_si3,%_si4,%_si5,%_si6,%_si7],simp:true,[%_si3,%_si4,%_si5]:args(%_si1),%_si7:"",%_si6:"",if is(%_si4 = "S") then (%_si7:sconcat("_",%_si5),%_si3:split(%_si3,"_")[1]) elseif is(%_si4 = "C") and is(%_si5 = 8) then (%_si6:"0",substring(%_si3,2)) elseif is(%_si4 = "C") and is(%_si5 = 16) then (%_si6:"0x",substring(%_si3,3)) elseif is(%_si4 = "C") then (%_si6:"0b",substring(%_si3,3)),if is(slength(%_si3) <= %_si2) then return(%_si1),%_si3:substring(%_si3,1,%_si2+1),return(stackbasen(sconcat(%_si6,%_si3,%_si7),%_si4,%_si5)))$
sbasen_char_to_digit(%_si1):=block([%_si2],if slength(%_si1)#1 then return(false),%_si2:sposition(%_si1,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"),if is(%_si2 = false) then return(false) else %_si2:ev(%_si2-1,simp),if %_si2 > 35 then %_si2:ev(%_si2-26,simp),return(%_si2))$
sbasen_convert_to_base10(%_si2):=block([%_si3,%_si4,%_si5,%_si6,%_si7,%_si8,%_si9],%_si3:%_si2,for %_si4 in extract_matching_parts(lambda([%_si1],is(safe_op(%_si1) = "stackbasen")),%_si2) do (%_si5:0,%_si8:third(%_si4),%_si6:sbasen_convert_to_digits_lsd(%_si4),%_si7:0,for %_si9 in %_si6 do (%_si5:ev(%_si5+%_si9*(%_si8^%_si7),simp),%_si7:ev(%_si7+1,simp)),%_si3:subst(%_si5,%_si4,%_si3)),return(%_si3))$
sbasen_convert_to_digits(%_si1):=block([%_si2,%_si3,%_si4],[%_si2,%_si3,%_si4]:args(%_si1),%_si2:if is(%_si3 = "S") then split(%_si2,"_")[1] elseif is(%_si3 = "C") and is(%_si4 = 8) then substring(%_si2,2) elseif is(%_si3 = "C") then substring(%_si2,3),%_si2:map('sbasen_char_to_digit,charlist(%_si2)),return(%_si2))$
sbasen_convert_to_digits_lsd(%_si1):=block([%_si2,%_si3,%_si4],[%_si2,%_si3,%_si4]:args(%_si1),%_si2:if is(%_si3 = "S") then split(%_si2,"_")[1] elseif is(%_si3 = "C") and is(%_si4 = 8) then substring(%_si2,2) elseif is(%_si3 = "C") then substring(%_si2,3),%_si2:reverse(map('sbasen_char_to_digit,charlist(%_si2))),return(%_si2))$
sbasen_construct_default_case:"upper"$
sbasen_construct_from_base10(%_si3,%_si4,%_si5):=block([simp,%_si6,%_si7,%_si8],simp:true,if not integerp(%_si5) or is(%_si5 < 2) or is(%_si5 > 36) then error("Base-N support only available for integer bases 2-36."),if not is(%_si4 = "C") and not is(%_si4 = "S") then error("Only formats C and S supported."),if is(%_si3 < 0) or not integerp(%_si3) then error("This function only support positive integer numbers."),%_si8:%_si3,%_si6:[],if %_si8 = 0 then %_si6:[0],while is(%_si8 > 0) do (%_si7:mod(%_si8,%_si5),%_si8:(%_si8-%_si7)/%_si5,%_si6:append([%_si7],%_si6)),if is(sbasen_construct_default_case = "lower") then %_si6:map(lambda([%_si2],charat("0123456789abcdefghijklmnopqrstuvwxyz",%_si2+1)),%_si6) else %_si6:map(lambda([%_si1],charat("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",%_si1+1)),%_si6),if is(%_si4 = "S") then %_si6:sconcat(simplode(%_si6),"_",%_si5) elseif is(%_si4 = "C") and %_si5 = 2 then %_si6:sconcat("0b",simplode(%_si6)) elseif is(%_si4 = "C") and %_si5 = 8 then %_si6:sconcat("0",simplode(%_si6)) elseif is(%_si4 = "C") and %_si5 = 16 then %_si6:sconcat("0x",simplode(%_si6)),return(stackbasen(%_si6,%_si4,%_si5)))$
texput("stackbasen",lambda([sbasen_num],block([digits,type,base],[digits,type,base]:args(sbasen_num),if type = "S" then return(sbasen_texput_suffix(sbasen_num)) elseif type = "C" and base = 2 then return(sbasen_texput_C_binary(sbasen_num)) elseif type = "C" and base = 8 then return(sbasen_texput_C_octal(sbasen_num)) elseif type = "C" and base = 16 then return(sbasen_texput_C_hex(sbasen_num)),return("'unknown base-N format'"))))$
sbasen_output_force_case:"preserve"$
sbasen_texput_suffix(%_si1):=block([%_si2],%_si2:split(first(%_si1),"_"),if sbasen_output_force_case = "upper" then return(sconcat("{\\textrm{",supcase(%_si2[1]),"}}_{",%_si2[2],"}")) elseif sbasen_output_force_case = "lower" then return(sconcat("{\\textrm{",sdowncase(%_si2[1]),"}}_{",%_si2[2],"}")) else return(sconcat("{\\textrm{",%_si2[1],"}}_{",%_si2[2],"}")))$
sbasen_texput_C_binary(%_si1):=block([%_si2],%_si2:sconcat("{\\texttt{",first(%_si1),"}}"),return(%_si2))$
sbasen_texput_C_octal(%_si1):=block([%_si2],%_si2:sconcat("{\\texttt{",first(%_si1),"}}"),return(%_si2))$
sbasen_texput_C_hex(%_si1):=block([%_si2],%_si2:if sbasen_output_force_case = "upper" then supcase(first(%_si1),3) elseif sbasen_output_force_case = "lower" then sdowncase(first(%_si1),3) else first(%_si1),%_si2:sconcat("{\\texttt{",%_si2,"}}"),return(%_si2))$
sbasen_validate(%_si2):=block([simp,%_si3,%_si4,%_si5],simp:true,if safe_op(%_si2)#"stackbasen" then return(["%root",["%cs","sbasen_validate_not_basen"]]),[%_si3,%_si4,%_si5]:args(%_si2),if %_si5 > 36 then return(["%root",["%cs","sbasen_validate_base_too_big","base",block([%_si6],_EC(errcatch(%_si6:%_si5),"maximasrc/basen/sbasen_validate.mac/1:1-1:69"),string(%_si6))]]),%_si3:sbasen_convert_to_digits(%_si2),if all_listp(lambda([%_si1],is(%_si1#false) and is(%_si1 < %_si5)),%_si3) then return(true) else return(castext_simplify(block(local(simp),["%root",["%cs","sbasen_validate_invalid_digits","num",block([%_si7,%_si9],%_si9:simp,_EC(errcatch(%_si6:%_si2),"maximasrc/basen/sbasen_validate.mac/1:1-1:88"),simp:false,%_si6:ct2_latex(%_si6,"i",%_si9),simp:%_si9,%_si6),"base",block([%_si8],_EC(errcatch(%_si6:%_si5),"maximasrc/basen/sbasen_validate.mac/1:1-1:88"),string(%_si6))]]))))$
sbasen_validate_tree(%_si2):=block([%_si3,%_si4,%_si5],%_si3:true,for %_si4 in extract_matching_parts(lambda([%_si1],is(safe_op(%_si1) = "stackbasen")),%_si2) do (%_si5:sbasen_validate(%_si4),if is(%_si5#true) then (if is(%_si3 = true) then %_si3:%_si5 else %_si3:castext_concat(castext_concat(%_si3," "),%_si5))),return(%_si3))$
extract_matching_parts(predicate,%_si1):=block([%_si2,%_si3],%_C(predicate),%_si2:if is(predicate(%_si1) = true) then [%_si1] else [],if not atom(%_si1) then (for %_si3 in args(%_si1) do %_si2:append(%_si2,extract_matching_parts(predicate,%_si3))),return(%_si2))$
