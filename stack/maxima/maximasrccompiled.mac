/* Result of compilation do not edit. */
sbasen_convert_to_binary(num,fmt):=block([_out],_out:if integerp(num) then sbasen_construct_from_base10(num,fmt,2) else (num:sbasen_convert_to_base10(num),sbasen_construct_from_base10(num,fmt,2)),return(_out))$
sbasen_bitwise_eval(ex):=block([simp,_bw,_ex,_l,_args,_changed,_i,_bits],_bw:1,for _ex in extract_matching_parts(lambda([x],is(safe_op(x) = "stackbasen")),ex) do (if is(third(_ex) = 2) then (_bw:ev(max(_bw,length(sbasen_convert_to_digits(_ex))),simp)) elseif is(third(_ex) = 8) then (_bw:ev(max(_bw,3*length(sbasen_convert_to_digits(_ex))),simp)) elseif is(third(_ex) = 16) then (_bw:ev(max(_bw,4*length(sbasen_convert_to_digits(_ex))),simp))),_l:lambda([_ex],member(safe_op(_ex),["not","and","or","nand","nor","xor","xnor"]) and all_listp(lambda([_x],is(safe_op(_x) = "stackbasen") and (is(third(_x) = 2) or is(third(_x) = 8) or is(third(_x) = 16))),args(_ex))),_changed:true,while _changed do (_changed:false,for _ex in extract_matching_parts(_l,ex) do (_args:map(lambda([_x],map(lambda([_y],is(_y > 0)),sbasen_convert_to_digits(sbasen_pad(sbasen_convert_to_binary(_x,"S"),_bw)))),args(_ex)),_bits:makelist(false,_i,1,_bw),if is(safe_op(_ex) = "not") then (_changed:stackbasen(sconcat(simplode(map(lambda([_x],if _x then "0" else "1"),_args[1])),"_2"),"S",2),ex:subst(_changed,_ex,ex)) elseif is(safe_op(_ex) = "nand") then (for _i:1 thru _bw do (_bits[_i]:not apply("and",map(lambda([_x],_x[_i]),_args))),_changed:stackbasen(sconcat(simplode(map(lambda([_x],if _x then "1" else "0"),_bits)),"_2"),"S",2),ex:subst(_changed,_ex,ex)) elseif is(safe_op(_ex) = "nor") then (for _i:1 thru _bw do (_bits[_i]:not apply("or",map(lambda([_x],_x[_i]),_args))),_changed:stackbasen(sconcat(simplode(map(lambda([_x],if _x then "1" else "0"),_bits)),"_2"),"S",2),ex:subst(_changed,_ex,ex)) elseif is(safe_op(_ex) = "xor") or is(safe_op(_ex) = "xnor") then (for _i:1 thru _bw do (_bits[_i]:is(mod(apply("+",map(lambda([_x],if _x[_i] then 1 else 0),_args)),2) = 1)),_changed:if is(safe_op(_ex) = "xor") then stackbasen(sconcat(simplode(map(lambda([_x],if _x then "1" else "0"),_bits)),"_2"),"S",2) else stackbasen(sconcat(simplode(map(lambda([_x],if _x then "0" else "1"),_bits)),"_2"),"S",2),ex:subst(_changed,_ex,ex)) else (for _i:1 thru _bw do (_bits[_i]:apply(safe_op(_ex),map(lambda([_x],_x[_i]),_args))),_changed:stackbasen(sconcat(simplode(map(lambda([_x],if _x then "1" else "0"),_bits)),"_2"),"S",2),ex:subst(_changed,_ex,ex)),_changed:true)),return(ex))$
sbasen_pad(num,w):=block([simp,_d,_t,_b,_pre,_suf],simp:true,[_d,_t,_b]:args(num),_suf:"",_pre:"",if is(_t = "S") then (_suf:sconcat("_",_b),_d:split(_d,"_")[1]) elseif is(_t = "C") and is(_b = 8) then (_pre:"0",_d:substring(_d,2)) elseif is(_t = "C") and is(_b = 16) then (_pre:"0x",_d:substring(_d,3)) elseif is(_t = "C") then (_pre:"0b",_d:substring(_d,3)),if is(slength(_d) >= w) then return(num),_d:sconcat(simplode(makelist("0",x,1,w-slength(_d))),_d),return(stackbasen(sconcat(_pre,_d,_suf),_t,_b)))$
sbasen_truncate_left(num,w):=block([simp,_d,_t,_b,_pre,_suf],simp:true,[_d,_t,_b]:args(num),_suf:"",_pre:"",if is(_t = "S") then (_suf:sconcat("_",_b),_d:split(_d,"_")[1]) elseif is(_t = "C") and is(_b = 8) then (_pre:"0",substring(_d,2)) elseif is(_t = "C") and is(_b = 16) then (_pre:"0x",substring(_d,3)) elseif is(_t = "C") then (_pre:"0b",substring(_d,3)),if is(slength(_d) <= w) then return(num),_d:substring(_d,slength(_d)-w+1),return(stackbasen(sconcat(_pre,_d,_suf),_t,_b)))$
sbasen_truncate_right(num,w):=block([simp,_d,_t,_b,_pre,_suf],simp:true,[_d,_t,_b]:args(num),_suf:"",_pre:"",if is(_t = "S") then (_suf:sconcat("_",_b),_d:split(_d,"_")[1]) elseif is(_t = "C") and is(_b = 8) then (_pre:"0",substring(_d,2)) elseif is(_t = "C") and is(_b = 16) then (_pre:"0x",substring(_d,3)) elseif is(_t = "C") then (_pre:"0b",substring(_d,3)),if is(slength(_d) <= w) then return(num),_d:substring(_d,1,w+1),return(stackbasen(sconcat(_pre,_d,_suf),_t,_b)))$
sbasen_char_to_digit(c):=block([_i],if slength(c)#1 then return(false),_i:sposition(c,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"),if is(_i = false) then return(false) else _i:ev(_i-1,simp),if _i > 35 then _i:ev(_i-26,simp),return(_i))$
sbasen_convert_to_base10(ex):=block([_out,_ex,_tmp,_d,_t,_b,_D],_out:ex,for _ex in extract_matching_parts(lambda([x],is(safe_op(x) = "stackbasen")),ex) do (_tmp:0,_b:third(_ex),_d:sbasen_convert_to_digits_lsd(_ex),_t:0,for _D in _d do (_tmp:ev(_tmp+_D*(_b^_t),simp),_t:ev(_t+1,simp)),_out:subst(_tmp,_ex,_out)),return(_out))$
sbasen_convert_to_digits(ex):=block([_tmp,_d,_t,_b],[_d,_t,_b]:args(ex),_d:if is(_t = "S") then split(_d,"_")[1] elseif is(_t = "C") and is(_b = 8) then substring(_d,2) elseif is(_t = "C") then substring(_d,3),_d:map('sbasen_char_to_digit,charlist(_d)),return(_d))$
sbasen_convert_to_digits_lsd(ex):=block([_d,_t,_b],[_d,_t,_b]:args(ex),_d:if is(_t = "S") then split(_d,"_")[1] elseif is(_t = "C") and is(_b = 8) then substring(_d,2) elseif is(_t = "C") then substring(_d,3),_d:reverse(map('sbasen_char_to_digit,charlist(_d))),return(_d))$
sbasen_construct_default_case:"upper"$
sbasen_construct_from_base10(b10,fmt,base):=block([simp,digits,m,rem],simp:true,if not integerp(base) or is(base < 2) or is(base > 36) then error("Base-N support only available for integer bases 2-36."),if not is(fmt = "C") and not is(fmt = "S") then error("Only formats C and S supported."),if is(b10 < 0) or not integerp(b10) then error("This function only support positive integer numbers."),rem:b10,digits:[],if rem = 0 then digits:[0],while is(rem > 0) do (m:mod(rem,base),rem:(rem-m)/base,digits:append([m],digits)),if is(sbasen_construct_default_case = "lower") then digits:map(lambda([n],charat("0123456789abcdefghijklmnopqrstuvwxyz",n+1)),digits) else digits:map(lambda([n],charat("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ",n+1)),digits),if is(fmt = "S") then digits:sconcat(simplode(digits),"_",base) elseif is(fmt = "C") and base = 2 then digits:sconcat("0b",simplode(digits)) elseif is(fmt = "C") and base = 8 then digits:sconcat("0",simplode(digits)) elseif is(fmt = "C") and base = 16 then digits:sconcat("0x",simplode(digits)),return(stackbasen(digits,fmt,base)))$
texput("stackbasen",lambda([ex],block([digits,type,base],[digits,type,base]:args(ex),if type = "S" then return(sbasen_texput_suffix(ex)) elseif type = "C" and base = 2 then return(sbasen_texput_C_binary(ex)) elseif type = "C" and base = 8 then return(sbasen_texput_C_octal(ex)) elseif type = "C" and base = 16 then return(sbasen_texput_C_hex(ex)),return("'unknown base-N format'"))))$
sbasen_output_force_case:"preserve"$
sbasen_texput_suffix(bn):=block([splt],splt:split(first(bn),"_"),if sbasen_output_force_case = "upper" then return(sconcat("{\\textrm{",supcase(splt[1]),"}}_{",splt[2],"}")) elseif sbasen_output_force_case = "lower" then return(sconcat("{\\textrm{",sdowncase(splt[1]),"}}_{",splt[2],"}")) else return(sconcat("{\\textrm{",splt[1],"}}_{",splt[2],"}")))$
sbasen_texput_C_binary(bn):=block([tmp],tmp:sconcat("{\\texttt{",first(bn),"}}"),return(tmp))$
sbasen_texput_C_octal(bn):=block([tmp],tmp:sconcat("{\\texttt{",first(bn),"}}"),return(tmp))$
sbasen_texput_C_hex(bn):=block([tmp],tmp:if sbasen_output_force_case = "upper" then supcase(first(bn),3) elseif sbasen_output_force_case = "lower" then sdowncase(first(bn),3) else first(bn),tmp:sconcat("{\\texttt{",tmp,"}}"),return(tmp))$
sbasen_validate(ex):=block([simp,digits,type,base],simp:true,if safe_op(ex)#"stackbasen" then return(["%root",["%cs","sbasen_validate_not_basen"]]),[digits,type,base]:args(ex),if base > 36 then return(["%root",["%cs","sbasen_validate_base_too_big","base",block([_ct2_tmp],_EC(errcatch(_ct2_tmp:base),"maximasrc/basen/sbasen_validate.mac/1:1-1:69"),string(_ct2_tmp))]]),digits:sbasen_convert_to_digits(ex),if all_listp(lambda([x],is(x#false) and is(x < base)),digits) then return(true) else return(castext_simplify(block(local(simp),["%root",["%cs","sbasen_validate_invalid_digits","num",block([_ct2_tmp,_ct2_simp],_ct2_simp:simp,_EC(errcatch(_ct2_tmp:ex),"maximasrc/basen/sbasen_validate.mac/1:1-1:80"),simp:false,_ct2_tmp:ct2_latex(_ct2_tmp,"i",_ct2_simp),simp:_ct2_simp,_ct2_tmp),"base",block([_ct2_tmp],_EC(errcatch(_ct2_tmp:base),"maximasrc/basen/sbasen_validate.mac/1:1-1:80"),string(_ct2_tmp))]]))))$
sbasen_validate_tree(ex):=block([_out,_ex,_tmp],_out:true,for _ex in extract_matching_parts(lambda([x],is(safe_op(x) = "stackbasen")),ex) do (_tmp:sbasen_validate(_ex),if is(_tmp#true) then (if is(_out = true) then _out:_tmp else _out:castext_concat(castext_concat(_out," "),_tmp))),return(_out))$
extract_matching_parts(pred,ex):=block([_r,_ex],%_C(pred),_r:if is(pred(ex) = true) then [ex] else [],if not atom(ex) then (for _ex in args(ex) do _r:append(_r,extract_matching_parts(pred,_ex))),return(_r))$
