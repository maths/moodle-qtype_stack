/*  Author Chris Sangwin
    Loughborough University
    Copyright (C) 2014 Chris Sangwin

    This program is free software: you can redistribute it or modify
    it under the terms of the GNU General Public License version two.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
    GNU General Public License for details.

    You should have received a copy of the GNU General Public License
    along with this program. If not, see <http://www.gnu.org/licenses/>. */


/* ********************************** */
/* Global variable options            */
/* ********************************** */

stack_reset(rand_seed) := block(
  kill(allbut [functions]),
  kill(trigsimp),
  /* We need some kind of numerical number to compare against.  */
  /* This does not work in Maxima 5.13.0, but keep for future reference */
  /* MAXIMA_VERSION_NUM:parse_string(?subseq(MAXIMA_VERSION,2)) */
  /*      */
  simpsum:true,
  negdistrib:true,  /* When negdistrib is true, -1 distributes over an expression. E.g., -(x + y) becomes - y - x. */
  display2d:false,
  nolabels:true,
  logabs:true,
  exptdispflag:true,
  linsolvewarn:false,
  ratprint:false,
  fpprintprec:12,     /* print only 12 digits */
  fpprec:20,          /* work with 20 digits */
  %E_TO_NUMLOG:true,  /* "r" some rational number, and "x" some expression, %E^(r*LOG(x)) => x^r .*/
  /* Synonyms to help students */
  e:exp(1),
  pi:%pi, Pi:%pi, PI:%pi,
  pi():=%pi,  /* Why does Excel do this?! */
  /* Display of matrixes */
  lmxchar:"[",
  /* Sets up randomization, using Maxima's internal random command */
  stack_randseed(10000),

  /*Reload local settings*/
  STACK_SETUP(true),

  MAXIMA_VERSION:map(parse_string, tokens(?\*autoconf\-version\*, 'digitcharp)),
  MAXIMA_VERSION_NUM:float(MAXIMA_VERSION[2]+MAXIMA_VERSION[3]/10),

  /*      */
  OPT_OUTPUT:"LaTeX",
  /*      */
  DIV_OP:"//",
  if MAXIMA_VERSION_NUM>=15.0 then DIV_OP:"/",

  true
)$

/* Sometimes we need i,j,e etc to be *symbols*, not values.... */
stack_reset_vars(ex) := block(kill(i, j, e, pi, Pi, PI));

/* Execute this command to ensure values have been set */
stack_reset(1000);

alias(int,integrate);        /* Allows integrate to be called with int()    */
alias(cosec,csc);            /* Corresponds to current student expectations */

simplify(ex) := ev(fullratsimp(ex), simp); /* Allows simplify to be something */
degree(ex,v) := ev(hipow(expand(ex), v), simp); /*See notes on hipow*/


/* ********************************** */
/* Logarithms                         */
/* ********************************** */
alias(ln, log);
load("log10");
texput(log10, "\\log\\mathrm{10}", prefix);
alias(lg, log10);
texput(lg, "\\mathrm{lg}", prefix);
load ("functs");

/* We don't want to allow people to put boxes round things. */
box(ex):=ex;

/* ********************************** */
/* Load contributed packages          */
/* ********************************** */

/* Statistics support */

load("stats");
load("distrib");
load("descriptive");

/* Although this works well in MAXIMA, |'s are not allowed in STACK */
/* The heuristics to catch the various errors do not work, since | is symmetrical */
matchfix("|", "|");
"|"([a]) := apply(abs, a);

/* Does not quite work yet ..... */
/* load("noninteractive.mac"); */


/*load("expandfeedback.mac");*/

/*load("sqdnst")*/
sqrtdenest(a) :=
  subst("^" = lambda([a, b],
     block([discr, max, min],
       if evenp(denom(b)) and not atom(a) and inpart(a, 0) = "+"
           and (max:max(first(a), rest(a)),
                   min:a-max,
                   numberp(discr:sqrt(1-(min/max)^2)))
      then (sqrt(max*(1+discr)/2)+signum(min)*sqrt(max*(1-discr)/2))^(2*b)
      else a^b)),
      a
)$

/* ********************************** */
/* Load stack packages                */
/* ********************************** */

load("assessment.mac"); /* Currently part of the STACK distribution */

load("stacktex.lisp"); /* Loads LaTeX changes and preferences */
texput(QMCHAR, "\\color{red}{?}");

alias(arccos, acos);          /* At the request of the OU, 4 Feb 2013 */
alias(arcsin, asin);           
alias(arctan, atan);           

load("mathml.lisp");   /* loads MathML */

make_complexJ(OPT_COMPLEXJ) := block(
  if OPT_COMPLEXJ = "i" then 
    (i:%i,load("complexi.lisp")) 
  else if OPT_COMPLEXJ = "j" then
    (%j:%i,j:%i,load("complexj.lisp"))
  else if OPT_COMPLEXJ = "symi" then
    (load("complexi.lisp")) 
  else if OPT_COMPLEXJ = "symj" then
    (load("complexj.lisp"))
  else true
);

/* Makes multiplication signs look correct */
make_multsgn(OPT_MULTSGN) := block(
    if OPT_MULTSGN = "cross" then load("multiply_cross.lisp"),
    if OPT_MULTSGN = "dot" then load("multiply_dot.lisp"),
    if OPT_MULTSGN = "blank" then load("multiply_blank.lisp")
);

/* Options for cos^(-1), acos or arccos */
make_arccos(OPT_ACOS) := block(
    if OPT_ACOS = "cos-1" then load("cos-1.lisp"),
    if OPT_ACOS = "arccos" then load("arccos.lisp")
);

/* This is needed to tweak the display of noun derivatives. */
nary("blankmult", 0, 0);
texput("blankmult", " # ", nary);

/* ****************************************************** */
/* Random numbers                                         */
/* ****************************************************** */
/* http://random.mat.sbg.ac.at/generators/                */
/* ****************************************************** */
/* Developer warning: random functions determining        */
/* whether a question is a singleton.                     */
/* When adding new "random" functions, also update        */
/* question->has_random_variants()                        */
/* ****************************************************** */

/* Change the random seed */
stack_randseed(s) := block(RANDOM_STATE:make_random_state(s), errcatch(ev(set_random_state(RANDOM_STATE), simp)))$

/* The top level function */
rand(ex) := block(
  ex:ev(ex, simp),
  if (integerp(ex)) then return(random(ex)),
  if (floatnump(ex)) then return(random(ex)),
  if (matrixp(ex)) then return(matrixmap(random, ex)),
  if (listp(ex)) then return(randlist(ex))
)$

randlist(ex) := block(
  if (length(ex) > 0) then return(ev(ex[(1+random(length(ex)))], simp)) else return([]) 
)$

/* Returns a random number from the set {lower, lower+step, lower+2*step, ... , final}. */
/* Jarno Ruokokoski, 29/10/2009                                                         */
rand_with_step(lower, upper, step_parameter) := block([temprand],
  temprand:rand(floor((upper-lower)/step_parameter)+1),
  return(step_parameter*temprand+lower)
)$

/* Returns a random integer from the set [lower,upper] such that it cannot be any value in list. This list can include values which are also random variables, for example, generated by rand_with_step. */
/* Jarno Ruokokoski, 29/10/2009 */
rand_with_prohib(lower, upper, list) := block([currents, retVal],
   currents:ev((makelist(i, i, lower, upper)), simp),
   for i:1 thru length(list) do block( 
       currents:simplify(delete(list[i], currents))
   ),
   retVal:rand(currents),
   return(retVal)
)$

/* ********************************** */
/* Display                            */
/* ********************************** */
/* expr - expression to be displayed  */
/* m    - mode, either                */
/*        "i" inline or               */
/*        "d" for displayed, or       */
/*        "" for no delimiters.       */

StackDISP(expr,m) := block([str:""],
    /* LaTeX display */
    if OPT_OUTPUT = "LaTeX" then
        if not(ev(elementp(m, {"", "i", "d"}), simp)) then print(concat("ERROR: illegal delimiter option found: ", m)),
    str:block([expru, expstr, offset, ld, rd],
        ld:"", 
        rd:"",
        if m = "i" then block(ld:"\\(", rd:"\\)"),
        if m = "d" then block(ld:"\\[", rd:"\\]"),
        expru:unary_minus_sort(expr),   
        expstr:tex(expru, false),
        /* Remove $$'s from Maxima's TEX command */
        if ?subseq(expstr, 0, 2) = "$$" then 
            expstr:concat(ld, ?subseq(expstr, 2, ev(?length(expstr)-3, simp)), rd) 
            /* Remove \begin{verbatim}'s from Maxima's TEX command */
        else if ?length(expstr) > 17 and ?subseq(expstr,1,17) = "\\begin{verbatim}" then 
            expstr:concat(ld, ?subseq(expstr, 18, ev(?length(expstr)-18, simp)), rd), 
        expstr
    ),
    /* MathML display */
    if OPT_OUTPUT = "MathML" then
        str:mathml(expr, false),
    /* String display */
    if OPT_OUTPUT="String" then str:string(expr),
    /* If no correct options have been set */
    if str = "" then str:string(expr),
    return(str)
)$

COLOR_LIST:["red", "Blue"  , "YellowOrange", "Bittersweet"  , "BlueViolet" , "Aquamarine", "BrickRed" , 
    "Apricot" , "Brown" , "BurntOrange", "CadetBlue" , "CarnationPink" , "Cerulean" , "CornflowerBlue" , 
    "CyanDandelion" , "DarkOrchid" , "Emerald" , "ForestGreen" , "Fuchsia", "Goldenrod" , "Gray" , 
    "Green" , "JungleGreen", "Lavender" , "LimeGreen" , "Magenta" , "Mahogany" , "Maroon" , "Melon", 
    "MidnightBlue" , "Mulberry" , "NavyBlue" , "OliveGreen" , "Orange", "OrangeRed" , "Orchid" , 
    "Peach" , "Periwinkle" , "PineGreen" , "Plum", "ProcessBlue" , "Purple" , "RawSienna" , "Red" , 
    "RedOrange" , "RedViolet" , "Rhodamine" , "RoyalBlue" , "RoyalPurple" , "RubineRed", "Salmon" , 
    "SeaGreen" , "Sepia" , "SkyBlue" , "SpringGreen" , "Tan", "TealBlue" , "Thistle" , "Turquoise" , 
    "Violet" , "VioletRed" ,"WildStrawberry" , "Yellow" , "YellowGreen" , "BlueGreen"]$
COLOR_LIST_LENGTH:length(COLOR_LIST)$

/* Decolour function */
detexcolor(ex) := block([argsex],
  if mapatom(ex) then return(ex),
  argsex:args(ex),
  if op(ex) = texcolor then return(detexcolor(argsex[2])),
  if op(ex) = "/" then return(detexcolor(argsex[1])/detexcolor(argsex[2])),
  map(detexcolor, ex)
)$

detexdecorate(ex) := block([argsex],
  if mapatom(ex) then return(ex),
  argsex:args(ex),
  if op(ex) = texdecorate then return(detexdecorate(argsex[2])),
  if op(ex) = "/" then return(detexdecorate(argsex[1])/detexdecorate(argsex[2])),
  map(detexdecorate, ex)
)$

/* Assume all non-numeric atoms are to be displayed in bold. */
texboldatoms(ex) := block(
  if numberp(ex) then return(ex),
  if atom(ex) then return(texdecorate("\\bf", ex)),
  apply(op(ex), maplist(texboldatoms, args(ex)))
)$

/* We only display matrices with the following matching pairs of delimiters.  
   Mismatching pairs ruins the API, so we can't have lmxchar and rmxchar as arbitrary.
   The list has three arguments, the first is the search string, the second is the left 
   parentheses, and the third is the right parentheses.
*/
stack_matrix_pairs:[ ["[", "[", "]"], ["(", "(", ")"], ["\{", "\\{", "\\}"], ["{", "\\{", "\\}"], ["", "", ""], [".", "", ""], ["|", "|", "|"]] $  

stack_matrix_disp(m):= block([ret, lp, rp, parens],
  if not(matrixp(m)) then (print("\\mbox{ERROR: argument to stack_matrix_disp must be a matrix.} "), return("")),
  if not(stringp(lmxchar)) then (print("\\mbox{ERROR: stack_matrix_disp requires lmxchar to be a string. }"), return("")), 
  parens:sublist(stack_matrix_pairs, lambda([ex],is(first(ex)=lmxchar))),
  if emptyp(parens) then (print(concat("\\mbox{ERROR: stack_matrix_disp cannot display matrices with parentheses ", string(lmxchar), "}")), return("")),
  parens:first(parens),
  lp:second(parens),
  rp:third(parens), 
  ret:maplist(lambda([ex], maplist(tex1, args(ex))), args(m)),
  ret:maplist(lambda([ex], simplode(ex, " & ")), ret),
  ret:simplode(ret, " \\\\ "),
  ret:sconcat("\\begin{array}{", simplode(maplist(lambda([ex], "c"), first(args(m)))), "} ", ret, " \\end{array}"),
  if ""#lp then
    ret:sconcat("\\left", lp, ret),
  if ""#rp then
    ret:sconcat(ret, "\\right", rp),
  ret
)$

texput(matrix, stack_matrix_disp)$

/* ********************************** */
/* Display: Sort out the unary minus  */
/* ********************************** */

/* To see an interesting example, see the following.
   simp:false;
   p:y^3-2*y^2-8*y;
   ?print(p);
   
   In the structure of this expression the first negative coefficient is -(2y^2) BUT the second is -(8)*y.

   ((MPLUS) ((MEXPT) $Y 3) ((MMINUS) ((MTIMES) 2 ((MEXPT) $Y 2))) ((MTIMES) ((MMINUS) 8) $Y))

   This again is a crucial but subtle difference....

   The following functions sort this out, pulling "-" out the front in a specific situation: that of
   a product with a negative number at the front.
   
   Another interesting example.  This illustrates the interaction with quotients.
   simp:false;
   p:x^7/7-2*x^6/3-4*x^3/3;
*/

/* Traverses an entire expression and ensures that "-"(number) really is the negative number.  */
/* Although we ultimately need to transform all integers back into "-"(number) for correct display */
/* this function gives us a definite form for comparison purposes in the interim.*/
unary_minus_traverse(ex) := block(
  if mapatom(ex) then return(ex),
  if op(ex) = "-" and numberp(first(args(ex))) then return(ev(ex,simp)),
  apply(op(ex), map(unary_minus_traverse, args(ex)) )
)$


/* Pulls out "-" to the front of any expression in a sum of products which needs it. */
/* For example,   -(2*y^2) is ok                                                     */
/* But            (-3)*7 is not.                                                     */
unary_minus_pull(ex) := block([ex2],
  if mapatom(ex) then return(ex),
  ex2:apply(op(ex), map(unary_minus_pull, args(ex))),
  if op(ex) = "+" then ex2:apply("+", map(unary_minus_pull_helper, args(ex2))),
  if op(ex) = "*" then ex2:unary_minus_pull_helper(ex2),
  return(ex2)
)$

/* Looks for                                     */
/* - a negative number                           */
/* - a product of an number and something.       */
/* - a quotient of an number and something.       */
/* Makes sure any minus sign is the top element  */
unary_minus_pull_helper(ex) := block([fe],
  if numberp(ex) and is(ex<0) then return(-(ev(-1*ex,simp))),  /* Turns -8 into "-"(8) */
  if mapatom(ex) then return(ex),
  fe:first(args(ex)), /* First element of the arguments.  Is this a negative number? */
  if op(ex) = "*" then
     if numberp(fe) and is(fe<0) 
         then return(-(apply("*", append([ev(-fe,simp)], rest(args(ex)))))),
  /* (-4*x^3)/4 is transformed into -(4*x^3)/4 */
  if op(ex) = "/" and safe_op(fe) = "-" then 
      return(-(apply("/",append(args(fe),[second(args(ex))])))),
  return(ex)
)$


/* Sorts out display of expressions in the case simp:false */
unary_minus_sort(ex) := block([ex2],
  if simp or mapatom(ex) then return(ex),
  if op(ex) = ":=" then return(ex),
  ex2:unary_minus_traverse(ex),
  return(unary_minus_pull(ex2))
)$



/* ****************************************************************** */
/* Evaluate variables are return errors, display, and content forms   */
/* ****************************************************************** */

/* This function executes ex, which is assumed to be a stack expression  */
/* which is surrounded by errcatch.  Hence we end up with a list.        */
cte(var,ex) := block([str],
    print("], key= ["),
    print(var),
    print("]"),
    if ex = [] then block(
        ex:STACKERROR, 
        print(", value = [], display = []")
    )
    else block(
        print(", value = ["),
        print(string(ex[1])),
        print("], display = ["),
        print(StackDISP(ex[1], "")),
        print("]"), 
        ex:ex[1]
    ),
    print("], "),
    return(ex)
)$

/* ********************************** */
/* Generate feedback                  */
/* ********************************** */

StackAddFeedback(fb, key, [ex]) := block([str, exprs, j],
    /* Note, the ex's are assumed to already be strings.
       There would be no other way to sort out the $ vs $$'s */
    /* Loop over the expressions */
    exprs:"",
    ev(for j:1 thru length(ex) do
        /* HACK: !quot! needs to be replaced with " when we get into PHP.  */
        exprs:concat(exprs, " , !quot!", ex[j], "!quot! "), simp),
    str:concat(fb, "stack_trans('", key, "'", exprs, "); "),
    return(str)
)$

/* Separate notes with puncutation, to enable clearer reading 
   and the possibility to split them. */
StackAddNote(exnote, newnote) := concat(exnote, newnote, ". ")$

StackTrimNote(ex) := strim(". ", ex)$

/* In many situations we just need the most basic object. */
StackBasicReturn(validity, result, note) := [validity, result, StackAddNote("", note), StackAddFeedback("", note)]$

/* ********************************************************* */
/*  Turns answertest output to a STACK return object string  */
/*                                                           */
/* ex[1] =  validity should be true/false                    */
/* ex[2] =  result should be true/false,                     */
/* ex[3] =  feedback, a string                               */
/* ex[4] =  answernote, is for teacher stats                 */
/*                                                           */
/* ********************************************************* */

StackReturn(ex) := block([str],
  if not(listp(ex)) then (print("StackReturn failed: argument not a list: "), print(string(ex)), return("")),
  if length(ex)#4 then (print("StackReturn failed: argument wrong length: "), print(string(ex)), return("")),
  print(" ], valid = [ "),
  if ex[1] then print(1) else print(0),
  print(" ], answernote = [ "),
  print(ex[3]),
  print(" ], feedback = [ "),
  print(ex[4]),
  return(ex[2])
)$

/* note the extra closing ] here.  The corresponding opening [ is generated in PHP */
/* This is about the most ugly API ever, but there we go.....                      */

/* ******************************************* */
/* Validate an expression                      */
/* ******************************************* */

stack_validate(expr, ForbidFloats, LowestTerms, TAns) := block( [simp:false, exs, SameType],
  /* Try to simply the expression to catch CAS errors */
  exs:errcatch(ev(expr, simp)),
  if exs=[] then return(false),
  if length(expr)#1 then print(StackAddFeedback("", "CommaError",string(expr), string(setify(expr)))),
  expr:first(expr),
  /* Check for floats, and if there are any then throw an error */
  if ForbidFloats and anyfloatex(expr) then
    print(StackAddFeedback("", "Illegal_floats")),
  /* Checks fractions are in lowest terms */
  if LowestTerms and all_lowest_termsex(expr)=false then
    print(StackAddFeedback("", "Lowest_Terms")),
  /* Check if the student's answer is the same type as the Teachers */
  SameType:ATSameTypefun(expr, TAns),
  if SameType[2]#true then print(SameType[4]),
  /* Now display the result */
  simp:false,
  expr:detexcolor(expr),
  expr:detexdecorate(expr),
  return(expr)
)$

/* Validate an expression without type checking. Floats and mathematical errors only. */
stack_validate_typeless(expr, ForbidFloats, LowestTerms) := block( [simp:false, exs],
  /* Try to simply the expression to catch CAS errors */
  exs:errcatch(ev(expr, simp)),
  if exs = [] then return(false),
  if length(expr)#1 then print(StackAddFeedback("", "CommaError", expr, setify(expr))),
  expr:first(expr),
  /* Check for floats, and if there are any then throw an error */
  if ForbidFloats and anyfloatex(expr) then
    print(StackAddFeedback("", "Illegal_floats")),
  /* Checks fractions are in lowest terms */
  if LowestTerms and all_lowest_termsex(expr) = false then
    print(StackAddFeedback("", "Lowest_Terms")),
  /* Now display the result */
  simp:false,
  return(expr)
)$

/* This function replaces all variables starting with a % sign with elements from var */
stack_strip_percent(ex,var) := block([lv1, lv2, subcount, indx,exs], 
    subcount:0,
    lv2:[],
    lv1:listofvars(ex),
    if [] = lv then return(ex),
    for indx:1 thru length(lv1) do (
        if cequal(charat(string(lv1[indx]), 1),"%") then block(
            subcount:subcount+1,
            lv2:append(lv2, [lv1[indx] = var[subcount]])
        )
    ),
    if not(emptyp(lv2)) then exs:subst(lv2, ex) else exs:ex,
    return(exs)
)$

/* These functions convert all variables in an expression to products of single letter variable names. */
stack_singlevar_make_helper(ex) := block([s],
  s:maplist(eval_string, charlist(string(ex))),
  apply("*", s)
)$

stack_singlevar_make(ex) := block([vars, subs],
  vars:sublist(listofvars(ex), lambda([ex], if slength(string(ex))>1 then true else false)),
  if emptyp(vars) then return(ex),
  vars:maplist(lambda([ex], ex=stack_singlevar_make_helper(ex)), vars),
  sublis(vars, ex)
)$


/* *************************************/
/* Output graphics,                    */
/* *************************************/

set_plot_option([run_viewer, false]);
set_plot_option([plot_format, gnuplot]);
set_plot_option([nticks, 50]);
set_plot_option([adapt_depth, 10]);
set_plot_option([gnuplot_default_term_command, ""]);

plot(ex,[ra]) :=  /*stack_web_plot*/
    block([simp:true, tfn, tfnp1, tfnp2, tfnp3, afn, ufn, lvs, preamble, sysp, sysr, filename, tn, alt, altc, alttext, ral, ralforbid, pltargs, plotfunmake, plotdebug],
    plotdebug:false,
    /* Arguments to plot must be lists */
    ral:sublist(ra, listp), /* The actual arguments used by plot */
    /* Check expressions to be plotted has/have only one variable. */
    ex:ev(ex, nouns, simp),
    lvs:listofvars(ex),
    lvs:sublist(lvs,lambda([ex],not(ex=discrete or ex=parametric))),
    if length(lvs)>1 then
       (print(concat("Plot error: Can't create a plot with more than one variable, whereas you have: \\(",string(lvs),"\\)")),
       return("<center>[Empty plot]</center>")),
    /* Sort out alt-text */
    kill(alt),
    alttext:concat("STACK auto-generated plot of ", string(ex), " with parameters ", string(ral)),
    altc:sublist(ral, lambda([ex], if listp(ex) then is(first(ex)=alt) else false)),
    if not(emptyp(altc)) then (ral:delete(first(altc), ral), alttext:second(first(altc))),
    if not(stringp(alttext)) then (alttext:"ERROR", print("Plot error: the alt tag definition must be a string, but is not."), return("")),
    /* remove from option list ral any non-permitted options */
    kill(y),
    permitted_options: [y, xlabel, ylabel, legend, color, style, point_type, nticks, logx, logy, axes, box, plot_realpart],
    if not(emptyp(lvs)) then permitted_options:append([first(lvs)], permitted_options), 
    ralforbid:sublist(ral, lambda([ex], not(member(first(ex), permitted_options)))),
    if not(emptyp(ralforbid)) then 
        (print(concat("Plot error: STACK does not currently support the following plot2d options: \\(",string(ralforbid),"\\)")), 
         return("<center>[Empty plot]</center>")),
    /* Create a unique identifier for the plot. */
    tn:string(absolute_real_time()),
    filename:concat("stackplot","-",tn,"-",string(rand(10^8))),
    /* Sort out the name of the image file and its url. */
    afn:concat("'", IMAGE_DIR, filename, ".", PLOT_TERMINAL, "'"),
    ufn:concat("<div class=\"stack_plot\"><img src='", URL_BASE, filename, ".", PLOT_TERMINAL, "' alt='", alttext, "' /></div>"),
    if OPT_OUTPUT#"MathML" then
      ufn:concat(" <html>", ufn, "</html> "),
    /* Sort out plot_options and preamble*/
    preamble:"",
    if not(member(xlabel, maplist(first, ral))) then ral:append(ral, [[xlabel, ""]]),
    if not(member(ylabel, maplist(first, ral))) then ral:append(ral, [[ylabel, ""]]),
    if member(legend, maplist(first, ral)) then block([lv],
            /* If we have [legend, true] then we should use the default legend */
            lv:sublist(ral, lambda([ex], (first(ex)=legend))),
            if second(first(lv))=true then ral:delete([legend, true], ral)
        ) else block(
            ral:append(ral, [[legend, false]])
        ),
    if not(member(axes, maplist(first, ral))) then block([lv],
            preamble:"set zeroaxis
set grid
"
        ),
    /* Note, the axes option in Maxima doesn't seem to work.... */
    preamble:concat(preamble, "set terminal ", PLOT_TERMINAL, "  ", PLOT_TERM_OPT, "
set output ", afn), 
    set_plot_option([gnuplot_preamble, preamble]),
    /* Sort out the name and location of temporary Gnuplot files. */
    tfn:concat(filename, ".plt"),
    /* Temporary file is referred to three times.            */
    /* 1. when Maxima writes it.                             */
    /* 2. when Gnuplot receives its location as an argument. */
    /* 3. when we delete it.                                 */
    /* On linux these are the same: the full path.           */
    tfnp1:concat(maxima_tempdir, filename, ".plt"),
    tfnp2:tfnp1, 
    tfnp3:tfnp1,
    /* On Windows, for more recent versions of Maxima, add slashes to the filename for Gnuplot. */
    if MAXIMA_PLATFORM="win" and MAXIMA_VERSION_NUM>35 then block(
        tfnp1:concat(filename, ".plt"),
        tfnp2:ssubst("\\\\", "\\", tfnp2)
        ),
    set_plot_option([gnuplot_out_file, tfnp1]),
    if plotdebug then print(plot_options),
    /* Create and execute the actual plot commands. */
    pltargs:append([ex], ral),
    if plotdebug then print(pltargs),
    plotfunmake:funmake(plot2d, pltargs),
    ev(plotfunmake),
    sysp:concat(GNUPLOT_CMD, " ", tfnp2),
    sysr:concat(DEL_CMD, " ", tfnp3),
    if plotdebug then print([sysp,sysr]),   
    system(sysp),
    if not(plotdebug) then system(sysr),
    simp:old_simp,
    return(ufn)
)$

/* ********************************** */
/* Numerical operations               */
/* ********************************** */

ATNumAbsolute(SA, SB) := ATNumerical(SA, SB, "ABSOLUTE")$
ATNumRelative(SA, SB) := ATNumerical(SA, SB, "RELATIVE")$


ATNumerical(SA, SB, numtype) := block([simp:true, RawMark, FeedBack, AnswerNote, ret, SAN, tol],
    Validity:false, RawMark:false, 
    FeedBack:StackAddFeedback("", "ATNumerical_FAILED"),
    AnswerNote:StackAddNote("", "ATNumerical_FAILED"),
    /* Turn on simplification and error catch */
    SA:errcatch(ev(float(SA), simp, nouns)),
    if is(SA = [STACKERROR]) then return(StackBasicReturn(false, false, "ATNumerical_STACKERROR_SAns")),
    SA:SA[1],
    SAN:copy(SA), /* Need this for when we have lists etc */
    SB:errcatch(ev(float(SB), simp, nouns, rat)),
    if is(SB = [STACKERROR]) then return(StackBasicReturn(false, false, "ATNumerical_STACKERROR_TAns")),
    SB:SB[1], 
    if not(listp(SB)) then (print("TEST_FAILED"), return(StackBasicReturn(false, false, "ATNumerical_STACKERROR_TA_not_list"))),
    if not(is(length(SB)=2)) then (print("TEST_FAILED"), return(StackBasicReturn(false, false, "ATNumerical_STACKERROR_TA_wrong_length"))),
    tol:SB[2],
    if not(numberp(tol)) then (print("TEST_FAILED"), return(StackBasicReturn(false, false, "ATNumerical_STACKERROR_tol"))),
    if not(elementp(numtype, {"ABSOLUTE", "RELATIVE"})) then (print("TEST_FAILED"), return(StackBasicReturn(false, false, "ATNumerical_testname_invalid"))),
    SB:SB[1], 
    
    /* Are we dealing with lists? */
    if listp(SB) then
      if listp(SAN)#true then 
        return(StackBasicReturn(false, false, "ATNumerical_SA_not_list"))
      else 
        return(ATNumerical_list(SA, SB, numtype, tol)),

    /* Are we dealing with lists? */
    if setp(SB) then
      if setp(SAN)=false then
        return(StackBasicReturn(false, false, "ATNumerical_SA_not_set"))
      else
        return(ATNumerical_set(SA, SB, numtype, tol)),

    /* Are we dealing with numbers? */
    /*print(ev(abs(float(SA-SB)), simp)),
    print(ev(abs(tol)+STACK_NUM_TOL, simp)),*/
    if numberp(SAN) then
      if numberp(TA) then
        return(StackBasicReturn(false, false, "ATNumerical_SA_not_number"))
      else
        if numtype = "ABSOLUTE" then
            return([false, numabsolutep(SA, SB, tol), "", ""])
        else 
            return([false, numrelativep(SA, SB, tol), "", ""]),

    ret:[Validity, RawMark, AnswerNote, FeedBack],
    return(ret)
)$

/* We have to define our own working precision. */
STACK_NUM_TOL:10E-10$
numabsolutep(sa,ta,tol) :=  if ev(abs(float(sa-ta)), simp) < ev(abs(tol)+STACK_NUM_TOL, simp)  then true else false;
numrelativep(sa,ta,tol) :=  if ev(abs(float(sa-ta)), simp) < ev(abs(ta*tol)+STACK_NUM_TOL, simp) then true else false;

ATNumerical_list(SA, SB, numtype, tol) := block([SAl, SBl, cl, res, fb:"", an:""],
    SAl:length(SA),
    SBl:length(SB),
    if (SAl#SBl) then
        return([true, false, StackAddNote("","ATNumerical_wronglen"), StackAddFeedback("", "ATList_wronglen", StackDISP(SBl, "i"), StackDISP(SAl, "i"))]),

    if numtype = "ABSOLUTE" then
       cl:zip_with(lambda([ex1,ex2], numabsolutep(ex1, ex2, tol)), SA, SB)      
    else 
       cl:zip_with(lambda([ex1,ex2], numrelativep(ex1, ex2, tol)), SA, SB),      

    res:apply("and", cl),
    if not(res) then block([we],
        fb:zip_with(lambda([ex1,ex2],if ex1 then ex2 else texcolor("red", ex2)), cl, SA),
        we:maplist(second, sublist(zip_with("[", cl, SA), lambda([ex], not(first(ex))))),
        an:StackAddNote("", concat("ATNumerical_wrongentries SA/TA=", string(we))),        
        fb:StackAddFeedback("", "ATList_wrongentries", StackDISP(fb, "d"))
    ),
          
    return([true, res, an, fb])
)$

ATNumerical_set(SA, SB, numtype, tol) := block([SAl, SBl, cl, res, fbl, fb:"", an:""],
    SAl:length(SA),
    SBl:length(SB),
    if (SAl#SBl) then
        return([true, false, StackAddNote("","ATNumerical_wronglen"), StackAddFeedback("", "ATSet_wrongsz", StackDISP(SBl, "i"), StackDISP(SAl, "i"))]),

    SA:sort(float(listify(SA))),
    SB:sort(float(listify(SB))),
    fbl:num_compare_helper(SA, SB, [], [], tol, numtype),
    if emptyp(first(fbl)) and emptyp(second(fbl)) then res:true else res:false,

    if not(res) then block(
        fb:setify(reverse(maplist(lambda([ex], texcolor("red", ex)), second(fbl)))),
        fb:StackAddFeedback("", "ATList_wrongentries", StackDISP(fb, "d")),
        an:StackAddNote("", concat("ATNumerical_wrongentries: TA/SA=", string(reverse(first(fbl))), ", SA/TA=", string(reverse(second(fbl)))))        
    ),
          
    return([true, res, an, fb])
)$

/***************************************************
Need a function which identifies which elements of the student's set, fall within "tolerance-balls" of elements of the teacher's set.

Takes various arguments
(1) student's list
(2) teacher's list
(3) numbers in the student's list, not within appropriate tolerance of any in the teacher's list
(4) numbers in the teacher's list, which do not occur (approximated) in the student's
(5) tolerance - whether this is absolute or relative to the teacher's answer needs to be sorted out internally to the function.
(6) type - either "ABSOLUTE" or "RELATIVE"

Returns all of the above + a feedback list.

All arguments 1-2 are ordered lists of floats, smallest to largest.

Want sa to lie between
(ta-tol,ta+tol) or (ta-ta*tol,ta+ta*tol) depending on "ABSOLUTE" or "RELATIVE" (respectively) 
****************************************************/
num_compare_helper(sal, tal, missing, excessive, tol, type) := block([sa, ta, f1, f2],
  /* If we've run out of answers */
  if emptyp(sal) and emptyp(tal) then return([missing, excessive]),
  if emptyp(sal) then return([append(tal, missing), excessive]),
  if emptyp(tal) then return([missing, append(sal, excessive)]),
  /* Otherwise, we take the first element of the list and calculate */
  /* if sa<ta-tol,  then f1<0.                                      */ 
  /* if abs(sa-ta)<abs(tol), then f2<0.                             */
  /* We appear to need to calulate f1 & f2 as variables,            */
  /* otherwise Maxima's is complains "undefined".  Odd...           */ 
  sa:first(sal),
  ta:first(tal),
  if type="ABSOLUTE" then 
       (f1:ev(float(sa-ta+tol),simp),
        f2:ev(float(abs(sa-ta)-abs(tol)), simp)) 
  else 
       (f1:ev(float(sa-ta*(1-tol)),simp),
        f2:ev(float(abs(sa-ta)-abs(ta*tol)), simp)), 
  /*print([sa,ta,f1,f2]),*/
  if is(f1<0) then return(num_compare_helper(rest(sal), tal, missing, append([sa], excessive), tol, type)),
  if is(f2<0)  
      then return(num_compare_helper(rest(sal), rest(tal), missing, excessive, tol, type)),
  return(num_compare_helper(sal, rest(tal), append([ta], missing), excessive, tol, type))
)$



ATNumSigFigs(SA,SBL) := block([Validity, RawMark, FeedBack, AnswerNote, ret, ol, nsf, asf, c0, c1, c2, SAA, SBB],
    Validity:true, RawMark:true, FeedBack:"", AnswerNote:"",

    SAA:errcatch(ev(SA, simp, nouns)),
    if (is(SAA = [STACKERROR]) or is(SAA = [])) then return([false, false, StackAddNote("","ATNumSigFigs_STACKERROR_SAns"), ""]),
    SBB:errcatch(ev(SBL, simp, nouns)),
    if (is(SBB = [STACKERROR]) or is(SBB = [])) then return([false, false, StackAddNote("","ATNumSigFigs_STACKERROR_TAns"), ""]),

    /* SBL is a list: the teacher's answer, the variable, and whether formative feedback is to be provided. */
    /* Sort out options */
    if listp(SBL) then (SB:SBL[1], ol:SBL[2]) else 
        (print("TEST_FAILED"), return([false, false, StackAddNote("", "ATNumSigFigs_STACKERROR_no_option"), StackAddFeedback("", "TEST_FAILED_Q")])),
    if listp(ol) then 
          if length(ol)#2 then 
             (print("TEST_FAILED"), return([false, false, StackAddNote("", "ATNumSigFigs_STACKERROR_list_wrong_length"), StackAddFeedback("", "TEST_FAILED_Q")]))
          else 
             (nsf:ol[1], asf:ol[2]) 
       else (nsf:ol, asf:ol),
    if not(integerp(nsf) and integerp(asf)) then
             (print("TEST_FAILED"),return([false, false, StackAddNote("", "ATNumSigFigs_STACKERROR_not_integer"), StackAddFeedback("", "TEST_FAILED_Q")])),
    /* SA should be only a number. */
    SA:errcatch(ev(SA, simp, nouns)),
    if is(SA = [STACKERROR]) then return([false, false, StackAddNote("", "ATNumSigFigs_Error simplifying SAns"),""]),
    SA:SA[1],
    if (not(floatnump(SA)) and not(integerp(SA))) then
        return([false, false, StackAddNote("", "ATNumSigFigs_NotDecimal"), StackAddFeedback("", "ATNumSigFigs_NotDecimal")]),
    /* Puts Teacher's answer between 0 & 1 */
    c0:-floor(log(abs(float(SB)))/log(10)+1),
    c1:SA*10^(c0+floor(nsf)),
    if is(float(c1-floor(c1))=0.0)=false then block(
        Validity:true, 
        RawMark:false, 
        FeedBack:StackAddFeedback(FeedBack, "ATNumSigFigs_WrongDigits"), 
        AnswerNote:StackAddNote(AnswerNote, "ATNumSigFigs_WrongDigits")
    ), 
    c2:abs(abs(SA*10^(c0+floor(asf)))-abs(SB*10^(c0+floor(asf)))),
    if not(is(c2<0.5)) then block(
        Validity:true, 
        RawMark:false, 
        FeedBack:StackAddFeedback(FeedBack, "ATNumSigFigs_Inaccurate"), 
        AnswerNote:StackAddNote(AnswerNote, "ATNumSigFigs_Inaccurate")
    ), 
    if RawMark = true then AnswerNote:"",
    ret: [Validity, RawMark, AnswerNote, FeedBack],
    return(ret)
)$

/* ********************************** */
/* Algebraic tests                    */
/* ********************************** */

/* A general, all purpose answer test based maximum simplification.
   This function is a wrapper for AtAlgEquivfun(SA,SB)
*/
ATAlgEquiv(SA,SB) := block([simp:true, ret, newret, SAN],
    /* Turn on simplification and error catch */
    SA:errcatch(ev(SA, simp, nouns)),
    if is(SA = [STACKERROR]) then return([false, false, StackAddNote("", "ATAlgEquiv_STACKERROR_SAns"), ""]),
    SA:SA[1],
    SAN:copy(SA), /* Need this for when we have lists etc */
    SB:errcatch(ev(SB, simp, nouns, rat)),
    if is(SB = [STACKERROR]) then return([false, false, StackAddNote("", "ATAlgEquiv_STACKERROR_TAns"),""]),
    SB:SB[1],
    /* Start recursive process */
    ret:ATAlgEquivfun(SA, SB),
    /* Can we find a permutation of the variables? */
    if ret[2]=0 then block([p1],
        p1:subst_equiv(SAN, SB),
        /* Actually, at this point 2008/7/7, we don't want to give this feedback.  Just leave an answer note. */
        /* if p1#[] and p1#false then ret:[ret[1], ret[2], StackAddNote(ret[3], concat("ATAlgEquiv_Subst ", string(p1))), StackAddFeedback(ret[4], "Subst", StackDISP(p1, "d"))] */
        if p1#[] and p1#false then ret:[ret[1], ret[2], StackAddNote(ret[3], concat("ATAlgEquiv_Subst ", string(p1))), ret[4]]
    ),
    return(ret)
)$

/* ATAlgEquivfun is a recursive "thing" comparing function.   It is designed to
   cope with a variety of different objects, eg lists of inequalities etc.

   Returns [valid, RawMark, AnswerNote, FeedBack]
   where valid = true/false
   RawMark     = true or false
   AnswerNote  = "string",
   FeedBack    = StackFeedback
*/
ATAlgEquivfun(SA, SB) :=  block([keepfloat, RawMark, FeedBack, AnswerNote, ret],
    Validity:true, RawMark:false, FeedBack:"", AnswerNote:"",
    keepfloat:true,
    /* Are we dealing with matrices? */
    if matrixp(SB) then
      if matrixp(SA)#true then
        return(StackBasicReturn(false, false, "ATAlgEquiv_SA_not_matrix"))
      else
        return(ATMatrix(SA, SB)),
    /* Are we dealing with lists? */
    if listp(SB) then
      if listp(SA)#true then
        return(StackBasicReturn(false, false, "ATAlgEquiv_SA_not_list"))
      else
        return(ATList(SA, SB)),
    /* Are we dealing with a function? */
    if functionp(SB) then
      if functionp(SA)#true then
        return(StackBasicReturn(false, false, "ATAlgEquiv_SA_not_function"))
      else
        return(ATFunction(SA, SB)),
    /* Are we dealing with an equation? */
    if equationp(SB) then
      if equationp(SA)#true then
        return(StackBasicReturn(false, false, "ATAlgEquiv_SA_not_equation"))
      else
        return(ATEquation(SA, SB)),
    /* Did the student type in an equation, but the teacher did not? */
    if equationp(SA) then return(StackBasicReturn(false, false, "ATAlgEquiv_TA_not_equation")),
    /* Are we dealing with an inequality? */
    if inequalityp(SB) then
      if inequalityp(SA)#true then
        return(StackBasicReturn(false, false, "ATAlgEquiv_SA_not_inequality"))
      else
        return(ATInequality(SA, SB)),
    /* Are we dealing with lists? */
    if setp(SB) then
      if setp(SA)=false then
        return(StackBasicReturn(false, false, "ATAlgEquiv_SA_not_set"))
      else
        return(ATSet(SA, SB)),
    /* Has the student typed in the wrong type?*/
    if expressionp(SA)=false then
        return(StackBasicReturn(false, false, "ATAlgEquiv_SA_not_expression")),
    /* Otherwise we have two expressions*/
    if algebraic_equivalence(SA, SB) then
       RawMark:true
    else if algebraic_equivalence(exdowncase(SA), exdowncase(SB)) then 
       AnswerNote:StackAddNote("", "ATAlgEquiv_WrongCase"),
    ret:[Validity, RawMark, AnswerNote, FeedBack],
    return(ret)
    )$

/* An answer test based on two lists for SA and SB */
ATList(SA,SB) := block([AddFeedBack, SAN, SAl, SBl, ret, retnew, k, AnsNotes],
    /* Get sizes of lists */
    SAN:SA,
    SAl:length(SA),
    SBl:length(SB),
    if (SAl#SBl) then
        return([true, false, StackAddNote("","ATList_wronglen"), StackAddFeedback("", "ATList_wronglen", StackDISP(SBl, "i"), StackDISP(SAl, "i"))]),

    /*  Apply ATAlgEquivfun to each element pair */
    ret:[true, true, "", ""],
    AddFeedBack:false,
    AnsNotes:[],
    for k:1 thru SAl do block([retnew],
        retnew:ATAlgEquivfun(SA[k], SB[k]),
        ret[1]:ret[1] and retnew[1],
        ret[2]:ret[2] and retnew[2],
        if not(retnew[3]="") then 
            AnsNotes:cons(concat(string(k), ": ", StackTrimNote(retnew[3])), AnsNotes)
        else if retnew[2]=false then 
            AnsNotes:cons(string(k), AnsNotes),
        if retnew[2] = false then block(
            /* ret[4]:concat(ret[4],retnew[4]), */
            if not(listp(SA[k]) or matrixp(SK[k]) or setp(SK[k])) then block(
                SAN[k]:texcolor("red", SA[k])
            ),
            AddFeedBack:true
        )
    ),
    if AddFeedBack = true then block(
        ret[3]:StackAddNote("", concat("(ATList_wrongentries ", simplode(reverse(AnsNotes), ", "), ")") ),
        ret[4]:concat(StackAddFeedback("", "ATList_wrongentries", StackDISP(SAN, "d")), ret[4])
    ),
    return(ret)
)$

/* Equations */
/* Note, this uses expand, which will break large expressions. */
stack_eqnprepare(ex) := block([ret, keepfloat],
  keepfloat:true,
  ret:fullratsimp(trigexpand(rhs(ex)-lhs(ex))),
  ret:ret*denom(ret),
  return(expand(ret))
)$

stack_eqncompare(SA, SB, sl) := block([ret,G0,G1],
  G0 :poly_buchberger(SA, sl), 
  G1 :poly_buchberger(SB ,sl), 
  ret:poly_grobner_equal(G0, G1, sl),
  return(ret)
)$

stack_assignmentp(ex) := block(
  if atom(ex) then return(false) 
  else if op(ex)#"=" then return(false)
  else if atom(lhs(ex)) and not(real_numberp(lhs(ex))) and real_numberp(rhs(ex)) then return(true)
  else return(false) 
)$

stack_assignmentrev(ex) := block(
  if atom(ex) then return(ex) 
  else if op(ex)#"=" then return(ex)
  else if real_numberp(lhs(ex)) and not(real_numberp(rhs(ex))) then return(rhs(ex)=lhs(ex))
  else return(ex) 
)$

/* Take a list of equations, and re-evaluate it in the context of any assignments of the form d=10 
   This is needed in practice with systems of equations, as students may write [d=10, d=v*t] */
stack_eval_assignments(ex) := block([asl, sl],
  if not(listp(ex)) then return(ex),
  sl:maplist(stack_assignmentrev, ex),
  asl:sublist(sl, stack_assignmentp),
  if not(emptyp(asl)) then block(
      sl:listify(setdifference(setify(sl), setify(asl))),
      sl:ev(sl, asl)
  ),
  return(sl)
)$

/* Two equations are the "same" when they have identical roots
   with identical multiplicities. */
ATEquation(SA, SB) := block([keepfloat, RawMark, SA1, SB1, SB2, R1, R2, R],
    keepfloat:false,
    RawMark:false,

    /* That said in lots of situations students will be asked to enter an equation.  */
    /* First we try the obvious of checking equivalence of each side!                */
    /* This catches lots of otherwise problematic cases.                             */
    if algebraic_equivalence(lhs(SA), lhs(SB)) then 
        if algebraic_equivalence(rhs(SA), rhs(SB)) then
             return([true, true, "ATEquation_sides", ""]) 
        else return([true, false, "ATEquation_lhs_notrhs", ""]),
    if algebraic_equivalence(lhs(SA), rhs(SB)) then 
        if algebraic_equivalence(lhs(SA), rhs(SB)) then
             return([true, true, "ATEquation_sides_op", ""]) 
        else return([true, false, "ATEquation_lhs_notrhs_op", ""]),
    /* First try without expanding out the equations */
    R1:ev(lhs(factor(SA))-rhs(factor(SA)), simp),
    R2:ev(lhs(factor(SB))-rhs(factor(SB)), simp),
    if algebraic_equivalence(R2, 0) then
        if algebraic_equivalence(R1, 0) then
             return([true, true, "ATEquation_zero", ""]) 
        else return([true, false, "ATEquation_zero", ""]),
    if numberp(float(abs(R1/R2))) then 
-        return([true, true, "", ""]),    R1:num(ratsimp(R1)),
    R2:num(ratsimp(R2)),
    if algebraic_equivalence(abs(R1/R2), 1) then 
        return([true, true, "ATEquation_ratio", ""]),
    R:ratsimp(R1/R2),
    if numberp(float(abs(R))) then 
        return([true, true, "ATEquation_num", ""]),
    return([true, false, "ATEquation_default", ""])
    )$

ATInequality(SA, SB) := block([RawMark, FeedBack, AnswerNote, SA1, SB1, samex],
    RawMark:false, FeedBack:"", AnswerNote:"",
    /* Write the inequalities in canonical form then compare. */
    SA:ineqorder(SA),
    SB:ineqorder(SB),
    if SA = SB then RawMark:true,
    /* Now try to give some basic feedback: potential for more work to recurse over complex expressions... */
    if op(SA) = ">"  and op(SB) =">=" then block(
        AnswerNote:StackAddNote("", "ATInequality_strict"),
        FeedBack:StackAddFeedback("", "ATInequality_strict")
    ),
    if op(SA) = ">=" and op(SB) =">" then block(
        AnswerNote:StackAddNote("", "ATInequality_nonstrict"),
        FeedBack:StackAddFeedback("", "ATInequality_nonstrict")
    ),
    if (">" = op(SA) or ">=" = op(SA)) and  (">" = op(SB) or ">=" = op(SB)) then block(
        SA1:ev(part(SA, 1), simp),
        SB1:ev(part(SB, 1), simp),
        if algebraic_equivalence(-1*SA1,SB1) then block(
            AnswerNote:StackAddNote(AnswerNote, "ATInequality_backwards"),
            FeedBack:StackAddFeedback(FeedBack, "ATInequality_backwards")
        )
    ),
    return([true, RawMark, AnswerNote, FeedBack])
)$


/* This (experimental) code decides if two functions are the same.  Strict notion currently. */
ATFunction(SA, SB) := block([RawMark, FeedBack, AnswerNote, df, SA1, SB1, SAd1, SBd1],
    RawMark:true, FeedBack:"", AnswerNote:"",
    if not(functionp(SA)) then return([false, 0, "ATFunction_SA_not_function", FeedBack]),
    if not(functionp(SB)) then return([false, 0, "ATFunction_TA_not_function", FeedBack]),
    SA1:args(SA),  SAd1:second(SA1),
    SB1:args(SB),  SBd1:second(SB1),
    /* Are the functions the same name? */
    if not(is(op(first(SA1)) = op(first(SB1)))) then block(
        AnswerNote:StackAddNote("", "ATFunction_wrongname"),
        RawMark:false
    ),
    /* Are the arguments the same? */
    if is(length(args(first(SA1))) = length(args(first(SB1)))) then block(
        if not(is(args(first(SA1)) = args(first(SB1)))) then block(
            AnswerNote:StackAddNote(AnswerNote, "ATFunction_arguments_different"),
            SAd1:subst(zip_with("=", args(first(SA1)), args(first(SB1))), SAd1)
        )
    ) else block(
        AnswerNote:StackAddNote(AnswerNote, "ATFunction_length_args"),
        RawMark:false
    ),
    df:ATAlgEquivfun(SAd1, SBd1),
    if second(df) then block(
        AnswerNote:StackAddNote(AnswerNote, "ATFunction_true")
    ) else block (
        AnswerNote:StackAddNote(AnswerNote, "ATFunction_false"),
        RawMark:false
    ),
    return([true, RawMark, AnswerNote, FeedBack])
)$

/* An answer test based on two matrices for SA and SB. */
ATMatrix(SA, SB) := block([RawMark, FeedBack, AnswerNote, str, ret, SAr, SAc, SBr, SBc, k, AddFeedBack],
    RawMark:true, FeedBack:"", AnswerNote:"",
    /* Get sizes of matrices */
    SAr:length(SA),
    SAc:length(SA[1]),
    SBr:length(SB),
    SBc:length(SB[1]),
    FeedBack:StackAddFeedback("", "ATMatrix_wrongsz", StackDISP(SBr, "i"), StackDISP(SBc, "i"), StackDISP(SAr, "i"), StackDISP(SAc, "i")),
    if (SAr#SBr) then
        return([true, false, StackAddNote("", "ATMatrix_wrongsz_rows"), FeedBack]),
    if (SAc#SBc) then
        return([true, false, StackAddNote("", "ATMatrix_wrongsz_columns"), FeedBack]),
    FeedBack:"",
    /* Check they are equal */
    ret:[true, true, "", ""],
    AddFeedBack:false,
    for k:1 thru SAr do block([retnew],
        retnew:ATAlgEquivfun(SA[k],SB[k]),
        ret[1]:ret[1] and retnew[1],
        ret[2]:ret[2] and retnew[2],
        ret[3]:concat(ret[3], " ", retnew[3]),
        if retnew[2]=false then AddFeedBack:true
    ),
    if AddFeedBack = true then block(
        /* TODO: better answernotes for matrices */
        ret[3]:StackAddNote("", "ATMatrix_wrongentries"),
        ret[4]:StackAddFeedback("", "ATMatrix_wrongentries", StackDISP(SA, "d"))
    ),
    return(ret)
    )$

/* An answer test based on two sets for SA and SB. */
ATSet(SA, SB) := block([RawMark, FeedBack, AnswerNote, str, SAl, SBl, ZM],
    RawMark:true, FeedBack:"", AnswerNote:"",
    /* Get sizes of matrices */
    SAl:cardinality(SA),
    SBl:cardinality(SB),
    FeedBack:StackAddFeedback("", "ATSet_wrongsz", StackDISP(SBl, "i"), StackDISP(SAl, "i")),
    if (SAl#SBl) then
        return([true, false, StackAddNote("", "ATSet_wrongsz"), FeedBack]),
    FeedBack:"",
    /* Check they are equal */
    SA:map(ineqprepare, map(trigreduce, SA)),
    SB:map(ineqprepare, map(trigreduce, SB)),
    if (subsetp(SA, SB) and subsetp(SB, SA)) then
        return([true, true, AnswerNote, FeedBack]),
    /* Can we give feedback on which are wrong */
    FeedBack:StackAddFeedback("", "ATSet_wrongentries", StackDISP(setdifference(SA, SB), "d")),
    return([true, false, StackAddNote("","ATSet_wrongentries"), FeedBack])
)$

/* A wrapper for an all purpose answer test which checks things are of the
   same "type".   Based upon the results of AtAlgEquivfun(SA,SB)
*/
ATSameType(SA, SB) := block([ret],
    ret:ATSameTypefun(SA,SB),
    /* This test gives no feedback */
    ret[3]:"",
    ret[4]:"",
    return([true, ret[2], ret[3], ret[4]])
)$


/* A general, all purpose answer test which checks things are of the
   same "type".   Based upon the results of AtAlgEquivfun(SA,SB)
*/
ATSameTypefun(SA, SB) := block([simp:true, ret],
    /* Turn on simplification and error catch */
    SA:errcatch(ev(SA, simp, nouns)),
    if is(SA = [STACKERROR]) then return([false, false, StackAddNote("", "ATSameTypefun_STACKERROR_SAns"), ""]),
    SA:SA[1],
    SB:errcatch(ev(SB, simp, nouns)),
    if is(SB = [STACKERROR]) then return([false, false, StackAddNote("", "ATSameTypefun_STACKERROR_TAns"), ""]),
    SB:SB[1],
    /* Start recursive process */
    ret:ATAlgEquivfun(SA, SB),
    /* Send back result */
    if ret[1] then
        return([true, true, ret[3], ret[4]])
    else
        return([true, false, ret[3], ret[4]])
)$

/* Tests if the SA equals SB in lowest terms, and gives feedback.
   Note, this is identical to ATAlgEquiv with simp:false otherwise. */
ATLowestTerms(SA, SB) := block([simp:false, ret, validity, mark, FeedBack, AnswerNote, SAA],
    /* Turn on simplification and error catch */
    SAA:errcatch(ev(SA, simp, nouns)),
    if (is(SAA = [STACKERROR]) or is(SAA = [])) then 
        return([false, false, StackAddNote("", "ATLowestTerms_STACKERROR_SAns"), ""]),
    SB:errcatch(ev(SB, simp, nouns)),
    if (is(SB = [STACKERROR]) or is(SB = [])) then 
        return([false, false, StackAddNote("", "ATLowestTerms_STACKERROR_TAns"), ""]),
    SB:SB[1],
    /* Unpack and check other property */
    validity:true,
    mark:true,
    AnswerNote:"",
    FeedBack:"",
    if all_lowest_termsex(SA) = false then block([badNos,a],
        mark:false,
        badNos:list_expression_numbers(SA),
        badNos:sublist(badNos,lambda([ex], if lowesttermsp(ex) then false else true)),
        AnswerNote:StackAddNote(AnswerNote, "ATLowestTerms_entries"),
        if badNos=[] then
            FeedBack:StackAddFeedback("", "ATLowestTerms_wrong", "")
        else
            FeedBack:StackAddFeedback("", "ATLowestTerms_entries", StackDISP(badNos, "d"))
    ),
    return([validity, mark, AnswerNote, FeedBack])
)$



ATSubstEquiv(SA,SB) := block([simp:true, ret],
    /* Turn on simplification and error catch */
    SA:errcatch(ev(SA, simp, nouns)),
    if is(SA=[STACKERROR]) then return([false, false, StackAddNote("", "ATSubstEquiv_STACKERROR_SAns"), ""]),
    SA:SA[1],
    SB:errcatch(ev(SB, simp, nouns)),
    if is(SB=[STACKERROR]) then return([false, false, StackAddNote("", "ATSubstEquiv_STACKERROR_TAns"), ""]),
    SB:SB[1],
    ret:ATAlgEquivfun(SA, SB),
    /* Can we find a permutation of the variables? */
    if ret[2]=false then block([p1],
        p1:subst_equiv(SA, SB),
        if p1#[] and p1#false then ret:[true, true, StackAddNote("", concat("ATSubstEquiv_Subst: ", string(p1))), StackAddFeedback("", "Subst", StackDISP(p1, "d"))]
    ),
    /* Send back result */
    return(ret)
)$

/* A general, all purpose answer test based maximum simplification.
   This function is a wrapper for AtAlgEquivfun(SA,SB)
*/
ATAlgEquiv(SA,SB) := block([simp:true, ret, newret, SAN],
    /* Turn on simplification and error catch */
    SA:errcatch(ev(SA, simp, nouns)),
    if is(SA = [STACKERROR]) then return([false, false, StackAddNote("", "ATAlgEquiv_STACKERROR_SAns"), ""]),
    SA:SA[1],
    SAN:copy(SA), /* Need this for when we have lists etc */
    SB:errcatch(ev(SB, simp, nouns, rat)),
    if is(SB = [STACKERROR]) then return([false, false, StackAddNote("", "ATAlgEquiv_STACKERROR_TAns"),""]),
    SB:SB[1],
    /* Start recursive process */
    ret:ATAlgEquivfun(SA, SB),
    /* Can we find a permutation of the variables? */
    if ret[2]=0 then block([p1],
        p1:subst_equiv(SAN, SB),
        /* Actually, at this point 2008/7/7, we don't want to give this feedback.  Just leave an answer note. */
        /* if p1#[] and p1#false then ret:[ret[1], ret[2], StackAddNote(ret[3], concat("ATAlgEquiv_Subst ", string(p1))), StackAddFeedback(ret[4], "Subst", StackDISP(p1, "d"))] */
        if p1#[] and p1#false then ret:[ret[1], ret[2], StackAddNote(ret[3], concat("ATAlgEquiv_Subst ", string(p1))), ret[4]]
    ),
    return(ret)
)$


/**********************************************/
/*                                            */
/*          System Equivalence Test           */
/*                                            */
/*  An addition to STACK using Grobner Bases  */
/*                                            */
/*  Matthew Badger, 2011                      */
/*                                            */
/**********************************************/

/*

	What these functions do:
	
	- Determine whether the student's and teacher's answers are systems of equations
	- Convert the two systems of equations into two systems of expressions
	- Determine whether both systems are systems of multivariate polynomials
	- Compare the variables in student's and teacher's answers, if they're not the same tell the student
	- Find their Buchberger polynomials of the two systems
	- Use the Buchberger polynomials to compare the Grobner bases of the two systems
	- If the Grobner bases are not equal, determine whether the student's is a subset of the teacher's
	- If student's system has equations which should not be there, tell them which ones.
*/



/*
	Main function of the System Equivalence test
    
    Takes two inputs, checks whether they are
    lists of polynomials and delegates everything
    else to other functions.

	Process:
	
	- Is each answer a list?
	- Is each list element not an atom?
	- Is each list element an equation?
	- Is each list element a polynomial?
*/

/* Edited files: SysEquiv.php, AnsTestcontroller.php, lang/en/stack.php */

ATSysEquiv(SA,SB):=block([keepfloat,Validity, RawMark, FeedBack, AnswerNote, SAA, SAB, S1, S2, varlist, GA, GB, ret],
	Validity:true, RawMark:false, FeedBack:"", AnswerNote:"",
	keepfloat:true,
	
	/* Turn on simplification and error catch */
    SAA:errcatch(ev(SA, simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then 
        return([false, false, StackAddNote("", "ATSysEquiv_STACKERROR_SAns"), ""]),
    SAB:errcatch(ev(SB, simp, nouns)),
    if (is(SAB=[STACKERROR]) or is(SAB=[])) 
        then return([false, false, StackAddNote("", "ATSysEquiv_STACKERROR_TAns"), ""]),
	
	/* Are both answers lists? */
	if not listp(SA) then
		return(StackBasicReturn(false, false, "ATSysEquiv_SA_not_list")),
	if not listp(SB) then
		return(StackBasicReturn(false,false,"ATSysEquiv_SB_not_list")),

	/* Are all list elements not atoms? */
	if ev(all_listp(atom,SA),simp) then
		return(StackBasicReturn(false,false,"ATSysEquiv_SA_not_eq_list")),
	if ev(all_listp(atom,SB),simp) then
		return(StackBasicReturn(false,false,"ATSysEquiv_SB_not_eq_list")),

	/* Are all list elements equations? */
	if ev(not all_listp(equationp, SA), simp) then
		return(StackBasicReturn(false, false, "ATSysEquiv_SA_not_eq_list")),
	if ev(not all_listp(equationp,SB), simp) then
		return(StackBasicReturn(false, false, "ATSysEquiv_SB_not_eq_list")),

	/* Turn our equations into expressions */
	S1: ev(maplist(stack_eqnprepare, stack_eval_assignments(SA)), simp),
	S2: ev(maplist(stack_eqnprepare, stack_eval_assignments(SB)), simp),

    /* Is S1 is empty?  This means we only had assignments in the answer, 
       i.e. the answer was in a "solved" form, e.g. x=1. */
    if emptyp(S1) and ev(equal(setify(maplist(stack_eqnprepare, SA)), setify(maplist(stack_eqnprepare, flatten(solve(S2,listofvars(S2)))))),simp) then
		    return([true,true,StackAddNote("","ATSysEquiv_SA_Completely_solved"),""]),
    if emptyp(S1) then 
		    return([true,false,StackAddNote("","ATSysEquiv_SA_Not_completely_solved"),""]),
           
	/* Is each expression a polynomial? */
	if not all_listp(polynomialpsimp, S1) then
		return(StackBasicReturn(false,false,"ATSysEquiv_SA_not_poly_eq_list")),
	if not all_listp(polynomialpsimp, S2) then
		return(StackBasicReturn(false,false,"ATSysEquiv_SB_not_poly_eq_list")),

	/*
		At this point have two lists of polynomials. We now check whether the
		student's and teacher's polynomials have the same variables. If they do,
		we find their Grobner bases and determine whether the systems of
		equations have the same solutions
	*/

	varlist: listofvars(S2),
	if not is(ev(setify(listofvars(S1)),simp)=ev(setify(varlist), simp)) then
		return(ATSysEquivVars(S1,S2)),

	GA :ev(poly_buchberger(S1,varlist),simp), 
	GB :ev(poly_buchberger(S2,varlist),simp),
	kill(S1,S2),

	/* Determine whether our two lists of polynomials have the same Grobner Bases */
	if poly_grobner_equal(GA, GB, varlist) then
		return([true,true,"",""]),

	/* 
		We now know the student's answer is in the correct form but there is
		something wrong with it. From here we use the grobner package to
		determine which, if any, of their equations is correct.
	*/

	return(ATSysEquivGrob(GA, GB, SA, varlist))
)$


/* Takes two lists of expressions and compares the variables in each */

ATSysEquivVars(S1,S2):=block([XA,XB],
	XA: setify(listofvars(S1)),
	XB: setify(listofvars(S2)),
	if subsetp(XA,XB) then
		return(StackBasicReturn(true,false,"ATSysEquiv_SA_missing_variables")),
	if subsetp(XB,XA) then
		return(StackBasicReturn(true,false,"ATSysEquiv_SA_extra_variables")),
	return(StackBasicReturn(true,false,"ATSysEquiv_SA_wrong_variables"))
)$

/*
	Grobner basis comparison

	This function takes two Grobner bases and a set of variables and determines
	whether the student's system is underdetermined or overdetermined. It also
	takes the student's original system so that if it is overdetermined it can
	tell them which equations should not be there.
*/

ATSysEquivGrob(GA,GB,SA,varlist):=block([retl,ret],

	/* Is the student's system underdetermined? */

	if poly_grobner_subsetp(GA,GB,varlist) then
		return(StackBasicReturn(true,false,"ATSysEquiv_SA_system_underdetermined")),

	/* 
		Given that the student's system is neither underdetermined nor equal to
		the teacher's, we need to find which equations do not belong in the system.
	*/
	
	ret:[],
	
	for k:1 thru length(SA) do block([],
		if ev(poly_grobner_member(stack_eqnprepare(stack_eval_assignments(SA[k])), GB, varlist),simp) then
			ret:append(ret,[SA[ev(k,simp)]])
		else
			ret:append(ret,[texcolor("red", SA[ev(k,simp)])])),

	return([true,false,StackAddNote("","ATSysEquiv_SA_system_overdetermined"),StackAddFeedback("","ATSysEquiv_SA_system_overdetermined", StackDISP(ret, "d"))])
)$

/*****************************************************************/

/* An answer test based on the Maxima's notion of equals. */
ATCASEqual(SA,SB) :=
    block([keepfloat:true, Validity:true, RawMark:false, FeedBack:"", AnswerNote:"", SAA, SBB],

    SAA:errcatch(ev(SA, simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then return([false,false,StackAddNote("","ATCASEqual_STACKERROR_SAns"),""]),
    SBB:errcatch(ev(SB, simp, nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then return([false,false,StackAddNote("","ATCASEqual_STACKERROR_TAns"),""]),

    /* Now actually apply this test */
    if equals_commute_associate(sa,sb) then 
        (RawMark:true, AnswerNote:"")
    else
        (RawMark:false, AnswerNote:StackAddNote("","ATEqualComAss: (AlgEquiv:true)")),

    if SA=SB then
       return([Validity, true, StackAddNote("","ATCASEqual_true"), FeedBack]),

    /* We need to check things are of the same type */
    ret:ATSameTypefun(SA,SB),
    if ret[2]=false then    
        return([true, false, StackAddNote("ATCASEqual: ", StackTrimNote(ret[3])), ret[4]]),
    ret:block([simp:true, ret], ATAlgEquivfun(SA, SB)),
    if ret[2]=true then    
        return([true, false, StackAddNote("ATCASEqual: (AlgEquiv:true)", StackTrimNote(ret[3])), ""]),

    AnswerNote:"ATCASEqual_false",
    return([Validity, RawMark, StackAddNote("",AnswerNote),FeedBack])
    )$

/* SA>SB? */
ATGT(SA,SB) :=
    block([keepfloat, Validity, RawMark, FeedBack, AnswerNote, str, ex],
    Validity:true, RawMark:false, FeedBack:"", AnswerNote:"Not number",
    keepfloat:true,               /* See pg 23 */

    SAA:errcatch(ev(SA, simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then 
        return([false, false, StackAddNote("", "ATGT_STACKERROR_SAns"), ""]),
    SBB:errcatch(ev(SB, simp, nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then 
        return([false, false, StackAddNote("", "ATGT_STACKERROR_TAns"), ""]),

    ex:ev(float(trigreduce(trigexpand(SA-SB))),simp),
    if numberp(ex) then
    if ex>0 then
       (RawMark:true, AnswerNote:StackAddNote("","ATGT_true"))
    else
       ( AnswerNote:StackAddNote("","ATGT_false")),
    return([Validity,RawMark,AnswerNote,FeedBack])
    )$

/* SA>=SB? */
ATGTE(SA,SB) :=
    block([keepfloat, Validity, RawMark, FeedBack, AnswerNote, str, ex, SAA, SBB],
    Validity:true, RawMark:false, FeedBack:"", AnswerNote:"Not number",
    keepfloat:true,

    SAA:errcatch(ev(SA, simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then 
        return([false, false, StackAddNote("", "ATGTE_STACKERROR_SAns"), ""]),
    SBB:errcatch(ev(SB, simp, nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then 
        return([false, false, StackAddNote("", "ATGTE_STACKERROR_TAns"), ""]),

    ex:ev(float(trigreduce(trigexpand(SA-SB))),simp),
    if numberp(ex) then
    if ex>=0 then
       (RawMark:true, AnswerNote:StackAddNote("","ATGTE_true") )
    else
       ( AnswerNote:StackAddNote("","ATGTE_false")),
    return([Validity,RawMark,AnswerNote,FeedBack])
    )$


/* irred_Q(p,v) is true iff */
/* (1) p is degree 0 in v                                               */
/* (2.1) p is linear in v, and the coefficients have no common factors  */
/* (2.2) p is linear in v, and the coefficients of v is -1              */
/* (3) p is quadratic, the coefficients have no common factors          */
/*     and p does not factor over the **rational numberss**             */

/* Is p an irreducible term in v, over the rationals Q? */
/* Returns a list, of [true/false, FeedBack, true/false] */
/* The third argument is the special case when we just have an integer factor to pull out. Needed for PartFrac. */
irred_Q(p,v) := block([ret,deg,cl,ci],
  deg:ev(hipow(expand(p),v),simp),
  /* Now perform the general test */
  cl:ev(map(second,coeff_list_nz(expand(p),v)),simp),
  /* all coefficients of p are integers?  (note, negative number don't count as integers here!)  */
  ci:all_listp(lambda([ex],integerp(ev(abs(ex),simp))),cl),
  /* General starting position */
  ret:[factorp(p),"",false],
  /* Special cases */
  if deg=0 then ret:[true,"",false],
  /* Special situation for the linear case to avoid strange results */
  if deg=1 then block([lt],
    lt:ev(bothcoef(p,v),simp),
    if lt[1]=1 or lt[2]=1 then ret:[true,"",false]
  ),
  /* Special case of quadratics, which are irreducible over the rationals */
  if deg=2 then block([a,b,c,q],
       q:ev(expand(p),simp),
       a:ev(coeff(q,v,2),simp),
       b:ev(coeff(q,v,1),simp),
       c:ev(coeff(q,v,0),simp),
       if (b=0 and c=0 and a>1 and ratnump(ev(sqrt(a),simp))) then ret:[true,StackAddFeedback("","irred_Q_optional_fac",StackDISP(p,"i")),false]
       else if (b=0 and c=0) then ret:[true,"",false]
       else if ratnump(ev(sqrt(b^2-4*a*c),simp)) then ret:[false,"",false]
  ),
  /* Check we have a common integer factor: note can't use GCD function which only allows 2 arguments */
  if length(cl)>1 and ci and commonfaclist(cl)>1 then ret:[false,StackAddFeedback("","irred_Q_commonint"),true],
  if deg>2 then block([q],
    /* take out any integer common factor */
    q:p,
    if length(cl)>1 and ci then q:ev(expand(p/commonfaclist(cl)),simp),
    if is(ev(q#factor(q),simp)) then ret:[false,ret[2],false]
  ),
  return(ret)
);

/* Is p a power of an irreducible term in v, over the rationals Q, disregarding the special case of a numerical factor? */ 
/* Only used by ATPartFrac */ 
/* Returns true/false */ 
irred_power_Qp(p,v) := block([ret],
 if safe_op(p)="^" then ret:irred_Q(first(args(p)),v) else ret:irred_Q(p,v),
 if third(ret) then true else first(ret)
); 

/* Picks apart an expression p of v, and gives some feedback */
/* on why this is not a factored expression */
FacForm_UnPick(p,v) := block([negdistrib,PARTSWITCH,fb,i,irred,res],
  negdistrib:false,
  partswitch:true,
  fb:"",
  res:true,
  if atom(p) then return([true,""]) else
    if op(p)="+" then return(irred_Q(p,v)) else
      if op(p)="^" then return(irred_Q(part(p,1),v)),
  /* So we have a *, or a / */
  for i:1 step 1 while ev(part(p,i),simp)#end do
    ( /* We just need to go one level down! */
            irred:block([q], q:part(p,ev(i,simp)),
            if atom(q) then return([true,""]) else
              if op(q)="+" then return(irred_Q(q,v)) else
                if op(q)="^" then return(irred_Q(part(q,1),v)) else return([false,""])
                 ),
      res:res and irred[1],
      if irred[1]=false then
         (fb:StackAddFeedback(fb,"FacForm_UnPick_morework",StackDISP(part(p,ev(i,simp)),"i")),
          fb:concat(fb,irred[2])
    )
    ),
  return([res,fb])
  )$


/* Factored form of a polynomial? */
/* Assumes all coefficients are integers */

ATFacForm(SA,SBL) := block([negdistrib,RawMark,FeedBack,AnswerNote,ret,str,SB,v,SAA,SBB,coefl,facdum],
    negdistrib:false,
    /* include facdum:'facdum, as in partfrac? */
    Validity:true, RawMark:true, FeedBack:"", AnswerNote:"",

    SAA:errcatch(ev(SA, simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then 
        return([false, false, StackAddNote("", "ATFacForm_STACKERROR_SAns"), ""]),
    SBB:errcatch(ev(SBL, simp, nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then 
        return([false, false, StackAddNote("", "ATFacForm_STACKERROR_TAns"), ""]),

    /* SBL is a list: the teacher's answer, the variable, and whether formative feedback is to be provided. */
    if listp(SBL) then (SB:SBL[1], v:SBL[2])  else
        return([false, false, StackAddNote("", "ATFacForm_STACKERROR_LIST"), StackAddFeedback("", "TEST_FAILED")]),

    /* SA should be only an expression. */
    if expressionp(SA)=false then
        return([false,false,StackAddNote("","ATFacForm_SA_not_expression"), StackAddFeedback("","ATAlgEquiv_SA_not_expression")]),

    /* If we don't have an atom as the teacher's variable, then we need to make a substitution */
    if atom(v)#true then (SA:subst(facdum, v, SA),SB:subst(facdum, v, SB), v:facdum),
    ret: FacFormfun(SA,SB,v),
    return(ret)
    )$

FacFormfun(SA,SB,v) := block([val, rawmk, ansnote, fb, ret, deg, aequiv, up, cont],
    val:true, rawmk:true, fb: "", ansnote: "",
    ret:[val,rawmk,ansnote,fb],
    if errcatch(deg:hipow(expand(SA), v)) = [] then block(
        val: false,
        rawmk: false,
        ansnote: StackAddNote("", "ATFacForm_error_degreeSA"),
        fb: StackAddFeedback("", "ATFacForm_error_degreeSA")
        ),
    aequiv:algebraic_equivalence(SA,SB),
    /* An integer answer is always correct. */
    if (integerp(SA)) then
        if (SA=SB) then
            ansnote: StackAddNote("","ATFacForm_int_true")
        else block(
            rawmk: false,
            ansnote: StackAddNote("","ATFacForm_int_false")
            )
    else block(
        /* Check for the correct answer. */
        if (aequiv and factorp(SA)) then
            ansnote: StackAddNote("","ATFacForm_true")
        else block(
            if (factorp(SA)) then ( /* We need to provide some feedback, if possible */
                ansnote:StackAddNote(ansnote,"ATFacForm_isfactored"),
                fb:StackAddFeedback(fb,"ATFacForm_isfactored")
                )
            else
                ( up:FacForm_UnPick(SA,v) ),
            if (up[1]=false) then (
               rawmk: false,
               ansnote:StackAddNote(ansnote,"ATFacForm_notfactored"),
               fb:StackAddFeedback(fb,"ATFacForm_notfactored"),
               fb:concat(fb,up[2])
               )
            else
               ( ansnote:StackAddNote(ansnote,"ATFacForm_default_true") ),
            /* Check for algebraic equivalence */
            if (true#aequiv) then (
              rawmk:false,
              ansnote:StackAddNote(ansnote,"ATFacForm_notalgequiv"),
              fb:StackAddFeedback(fb,"ATFacForm_notalgequiv"),
              cont:false       /* Unsure what this is for - not used anywhere, or returned, in original code! */
              )
            )
        ),
    ret: [val, rawmk, ansnote,fb],
    return(ret)
    )$

/* An answer test based expandp(sa). */
/* Note, the SB is a dummy to allow one mechanism for calling functions */
ATExpanded(SA,SB) :=
    block([keepfloat, Validity, RawMark, FeedBack, AnswerNote, SA1],
    Validity:true, RawMark:false, FeedBack:"", AnswerNote:"", SA1:[],
    keepfloat:true,

    /* SA should be only an expression. */
    SA1:errcatch(ev(SA, simp, nouns)),
    if is(SA1=[STACKERROR]) then return([false, false, StackAddNote("", "ATExpanded_STACKERROR_SAns"), ""]),
    /*   */
    if expressionp(SA)=false then
        return([false, false, StackAddNote("", "ATExpanded_SA_not_expression"), StackAddFeedback("", "ATAlgEquiv_SA_not_expression")]),
    if expandp(SA) then
            return([true, true, StackAddNote("", "ATExpanded_TRUE"), ""])
        else
            return([true, false, StackAddNote("", "ATExpanded_FALSE"), ""])
    )$


/* *************************ATPartFrac Test**************************** */
/* requires:    Student Answer,                                         */
/*              [Teachers Question,                                     */
/*              Respect To which the fractions are parted,              */
/*              Formative Feedback]                                     */
/* returns: StackReturn                                               */
/*      CASE 1: topOp is divisor - single fraction                      */
/*      CASE 2: CORRECT answer - true                                   */
/*      CASE 3: Different Variables - diff vars                         */
/*      CASE 4: Different amount of parts - Diff parts                  */
/*      CASE 5: Different Numerator - ret factored expression           */
/*      CASE 6: Different Denominator - ret sDenom and tDenom           */
/* ******************************************************************** */

ATPartFrac(SA,SBL) := block([negdistrib,Validity,rawmk,fb,ansnote,ret,SB,v,facdum,wrt,tExpr,sExpr,SAA,SBB],
    negdistrib:false,
    facdum:'facdum,
    Validity:true, rawmk:true, fb:StackAddFeedback("",""), ansnote:"",

    SAA:errcatch(ev(SA, simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then 
        return([false, false, StackAddNote("", "ATPartFrac_STACKERROR_SAns"), ""]),
    SBB:errcatch(ev(SBL, simp, nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then 
        return([false, false, StackAddNote("", "ATPartFrac_STACKERROR_TAns"), ""]),

    /* SBL is a list: the teacher's answer, the variable, and whether formative feedback is to be provided. */
    if listp(SBL) then (tExpr:SBL[1], wrt:SBL[2])  else
        return([false,false,StackAddNote("","ATFacForm_STACKERROR_LIST"),StackAddFeedback("","TEST_FAILED")]),

    /* SA should be only an expression. */
    if expressionp(SA)=false then
        return([false, false, StackAddNote("", "ATPartFrac_SA_not_expression"), StackAddFeedback("", "ATAlgEquiv_SA_not_expression")]),

    /* tExpr should be only an expression. */
    if expressionp(tExpr)=false then
        return([false, false, StackAddNote("", "ATPartFrac_TA_not_expression"), StackAddFeedback("", "ATPartFrac_error_list")]),
        
    /* If we don't have an atom as the teacher's variable, then we need to make a substitution */
    if atom(v)#true then (SA:subst(facdum,wrt,SA),tExpr:subst(facdum,wrt,tExpr),wrt:facdum),
    ret: PartFracfun(SA,tExpr,wrt),
    return(ret)
    )$

/* An expression is in partial fraction form when     */
/* it is a sum of rational terms.   In each term      */
/* - the denominator of each term is a power of an    */
/*   irreducible (not factorable) polynomial and      */
/* - the numerator is a polynomial of smaller degree  */
/*   than that irreducible polynomial.                */
PartFracfun(sExpr,tExpr,wrt) := block([val, rawmk, ansnote, fb],
        val:true, rawmk:true, fb: "", ansnote: "",
        ret:[val,rawmk,ansnote,fb],
        if algebraic_equivalence(sExpr,tExpr) then
                block([topOp, list],
                    topOp: op( sExpr ),
                    list: args( sExpr ),
                    /* Sort out any factors the student may have pulled out */
                    if topOp = "*" then block(
                                              sExpr:expand(sExpr),
                                              topOp: op(sExpr),
                                              list: args(sExpr)
                                              ),
                    if topOp = DIV_OP then list:[sExpr] else list: args( sExpr ),
                    block([sargs,sdenoms],
                                    val:true,
                                    rawmk: true,
                                    ansnote:StackAddNote("","ATPartFrac_true"),
                                    /* We need to check that each term in the student's sum is in lowest terms ... */
                                    if not all_listp(lambda([ex], real_numberp(gcd(num(ex),denom(ex)))),list) then
                                                     block(
                                                           rawmk: false,
                                                           ansnote:StackAddNote("","ATPartFrac_false_lowestterms")
                                                           ),
                                    /* ... with the degree(num)<degree(den) */
                                    if not all_listp(lambda([ex],if denom(ex)=1 then true else is(ev(hipow(expand(num(ex)),wrt)<hipow(expand(denom(ex)),wrt),simp))),list) then
                                                     block(
                                                           rawmk: false,
                                                           ansnote:StackAddNote("","ATPartFrac_false_degree")
                                                           ),
                                    /* We need to check that each denominator is the power of an irreducible factor */
                                    /* Note the slight cludge to check if we have a numerical factor */
                                    if not all_listp(lambda([ex],irred_power_Qp(denom(ex),wrt)), list) then
                                                     block(
                                                          rawmk: false,
                                                          ansnote:StackAddNote("","ATPartFrac_false_factor")
                                                          )
                                    ),
                    ret: [val,rawmk,ansnote,fb],
                    return(ret)
                    )
        else if sameVars(sExpr, tExpr) then
             block([sDeg,tDeg,sNDeg,tNDeg],
                sDeg: ev(hipow(expand(denom(factor(sExpr))),wrt),simp),
                tDeg: ev(hipow(expand(denom(factor(tExpr))),wrt),simp),
                sNDeg: ev(hipow(expand(num(factor(sExpr))),wrt),simp),
                tNDeg: ev(hipow(expand(num(factor(tExpr))),wrt),simp),
                if tDeg # sDeg then
                    block(
                        val:true,
                        rawmk: false,
                        ansnote: StackAddNote("","ATPartFrac_denom_ret"),
                        fb: StackAddFeedback("","ATPartFrac_denom_ret", StackDISP(denom(factor(sExpr)),"i"), StackDISP(denom(factor(tExpr)),"i")),
                        ret: [val,rawmk,ansnote,fb],
                        return(ret)
                    )
                else
                   block(
                        val: true,
                        rawmk: false,
                        ansnote: StackAddNote("","ATPartFrac_ret_expression"),
                        fb: StackAddFeedback("", "ATPartFrac_ret_expression", StackDISP(factor(sExpr),"i")),
                        ret: [val,rawmk,ansnote,fb]
                   )
              )
             else
             block(
                val: false,
                rawmk: false,
                ansnote : StackAddNote("","ATPartFrac_diff_variables"),
                fb:StackAddFeedback("","ATPartFrac_diff_variables"),
                ret: [val, rawmk, ansnote,fb]
             ),
     return(ret)
     )$

/* ************************ATSingFracTest****************************** */
/* requires:    Student Answer                                          */
/*      List:   [Teachers Answer, variable with which partial           */
/*              fraction occurs, whether Formative Feedback is required */
/* returns:     StackReturn                                             */
/*     Cases:                                                           */
/*              Returns True iff algebraic equivalence with TList[1]    */
/*     and Division is the Top Operator.                                */
/*              False if Division not the top operator                  */
/*              False if different Variables are used                   */
/*              True(0) otherwise                                       */
/* ******************************************************************** */
ATSingleFrac(SA, SB):= block(
    [simp:false,negdistrib, validity, rawmk, fb, fbn, ansnote, ret,SAA,SBB],
    negdistrib: false,
    validity:true, rawmk:false, fb:"", ansnote:"",

    SAA:errcatch(ev(SA, simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then 
        return([false, false, StackAddNote("", "ATSingleFrac_STACKERROR_SAns"), ""]),
    SBB:errcatch(ev(SB, simp, nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then 
        return([false, false, StackAddNote("", "ATSingleFrac_STACKERROR_TAns"), ""]),

    /* sExpr should be only an expression. */
    if expressionp(SA)=false then
         return([false,false,StackAddNote("","ATSingleFrac_SA_not_expression"),StackAddFeedback("","ATAlgEquiv_SA_not_expression")]),

    if atom(SA) then
        if algebraic_equivalence(SA,SB) then
            return([true,true,"",""])
        else
            return(StackBasicReturn(true,false,"ATSingleFrac_ret_exp")),

    /* Check for single fraction */
    fbn:"",
    if op(SA) = DIV_OP then block(
        if (freeof(DIV_OP,num(SA)) and freeof(DIV_OP,denom(SA))) then block(
            rawmk:true,
            ansnote:"ATSingleFrac_true")
        else block(
            rawmk:false,
            ansnote:"ATSingleFrac_div")
        )
    else block(
        rawmk:false,
        ansnote:"ATSingleFrac_part"),
    fb: StackAddFeedback(fb,ansnote),
    ansnote:StackAddNote("",ansnote),
    /* Check for algebraic equivalence */
    if not(algebraic_equivalence(SA,SB)) then block(
            rawmk:false,
            fbn:"ATSingleFrac_ret_exp",
            fb: StackAddFeedback(fb,fbn),
            ansnote:StackAddNote(ansnote,fbn)
    ),
    return([validity,rawmk,ansnote,fb])
)$


/*****************************************************************/
/* Useful function for Partial Fractions                         */
/*****************************************************************/

divthru(q):=
       if (not atom(q) and part(q,0)=DIV_OP)
       then
         block([num,den,div,quo,rem],
           num:part(q,1),
           den:part(q,2),
           div:divide(num,den) ,
           quo:div[1],
           rem:div[2],
           quo+rem/ den )
       else q;

/*****************************************************************/
/* Partial Fractions answer Test functions                       */
/*****************************************************************/

/* *******Functions Used******** */
/* isDenomSame(sExpr, tExpr)     */
/* isNumSame(sExpr, tExpr)       */
/* isPartFrac(sExpr, tExpr, wrt) */
/* sameVars(expr1, expr2)        */
/* ***************************** */

/* ************Denominator Same Test*************************** */
/* requires:    Students partial Fraction part                  */
/*      Teachers Partial Fraction part                          */
/* returns: Boolean true iff denominators are equivalent        */
/*      false otherwise                                         */
/* ************************************************************ */

isDenomSame(sPFrac,tPFrac):=
    (
        if denom(expand(sPFrac)) = denom(expand(tPFrac))
            then true
        else
            false
    );


/* When checking the form of a partial fraction, we need to ensure that the
   *form* of the demoninators are the same.  That is to say that the sets
   of expressions on the denominators are equal, up to +/-1.  For example,
   we could have 1/(n+1)+1/(1-n) or 1/(n+1)-1/(n-1).   This makes life harder!
*/
sameDenoms(SA,TA) := block([k,ret,sAargs,sAset,tAargs,tAset,dTA,dTB],
      tAargs:args(TA),
      tAset:set(),
      /* Create a set of +-1*denoms in the teacher's expression */
      for k:1 thru length(tAargs) do block(
                  dTA : ev(expand(denom(tAargs[k])),simp),
                  dTB : ev(expand(-1*denom(tAargs[k])),simp),
                  tAset : union(set(dTA,dTB),tAset)
                  ),
      /* Create a set of +-1*denoms in the student's expression */
      sAargs:args(SA),
      sAset:set(),
      for k:1 thru length(sAargs) do block(
                  dTA : ev(expand(denom(sAargs[k])),simp),
                  dTB : ev(expand(-1*denom(sAargs[k])),simp),
                  sAset : union(set(dTA,dTB),sAset)
                  ),
      ret:(subsetp(sAset,tAset) and subsetp(sAset,tAset)),
      return(ret)
)$


/* **************Numerator Same Test*************************** */
/* requires:    Students partial Fraction part                  */
/*      Teachers Partial Fraction part                          */
/* returns: Boolean true iff numerators are equivalent          */
/*      false otherwise                                         */
/* ************************************************************ */

isNumSame(sPFrac, tPFrac):=
    (
        if num(expand(sPFrac)) = num(expand(tPFrac))
            then true
        else
            false
    );


/* ***************Variables used the Same********************** */
/* requires:    2 Expressions                                   */
/* returns:     true: iff expr 1 and expr2 contain same vars    */
/*      false: otherwise                                        */
/* ************************************************************ */

sameVars(expr1, expr2):=
    block([list1,list2],
        list1: listofvars(expr1),
        list2: listofvars(expr2),
        if list1=list2 then true
        else false
    );

/* ********************************** */
/* Completed squares                  */
/* ********************************** */

ATCompSquare(SA,SBL) := block([Validity,RawMark,FeedBack,AnswerNote,ret,wrt,SB,SAA,SBB,facdum,opa,argsa,deg,cform,ae],
    Validity:true,RawMark:true, FeedBack:"", AnswerNote:"", cform:false,
    SAA:errcatch(ev(SA,simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then 
        return([false, false, StackAddNote("", "ATCompSquare_STACKERROR_SAns"), ""]),
    SBB:errcatch(ev(SBL,simp, nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then 
        return([false, false, StackAddNote("", "ATCompSquare_STACKERROR_TAns"), ""]),

    /* SBL is a list: the teacher's answer, the variable, and whether formative feedback is to be provided. */
    if listp(SBL) then (SB:SBL[1], wrt:SBL[2])  else
        return([false,false,StackAddNote("", "ATCompSquare_STACKERROR_LIST"), ""]),

    /* SA should be only an expression. */
    if expressionp(SA)=false then
        return([false, false, StackAddNote("", "ATCompSquare_STACKERROR_LIST"), StackAddFeedback("", "ATAlgEquiv_SA_not_expression")]),

    /* If we don't have an atom as the teacher's variable, then we need to make a substitution */
    if atom(wrt)#true then (SA:subst(facdum, wrt, SA), SB:subst(facdum, wrt, SB), wrt:facdum),

    if member(wrt,listofvars(SB)) and not(member(wrt,listofvars(SA))) then
        return([true, false, StackAddNote("", "ATCompSquare_SA_not_depend_var"), StackAddFeedback("", "ATCompSquare_SA_not_depend_var", StackDISP(SBL[2], "i"))]),

    opa:safe_op(SA),

    /* Special case of teacher using constant or linear quadratics */
    ae:algebraic_equivalence(SA,SB),
    if ae and not(member(wrt,listofvars(SB))) then
        return([true,true,StackAddNote("","ATCompSquare_true_trivial"),""]),
    if ae and is(degree(expand(SB),wrt)=1) then
        return([true,true,StackAddNote("","ATCompSquare_true_trivial"),""]),

    /* case: (x-1)^2 */
    if opa="^" and part(args(SA),2)=2 then cform:true,

    /* case: k*(x-1)^2 */
    if opa="*" then block([argsb], 
       argsb: sublist(args(SA),lambda([ex],elementp(wrt,setify(listofvars(ex))))),
       if length(argsb)=1 then
           if op(argsb[1])="^" and part(argsb[1],2)=2 then cform:true
    ),

    /* case: (x-1)^2/k */
    if opa=DIV_OP and elementp(wrt,setify(listofvars(denom(SA))))#true and atom(num(SA))#true and op(num(SA))="^" and part(num(SA),2)=2 then cform:true,

    /* The sum of somthing */
    if opa="+" then block(
        argsa: sublist(args(SA),lambda([ex],elementp(wrt,setify(listofvars(ex))))),
        if length(argsa)>1 then
            (AnswerNote:"_no_summands",return(true)),

        if length(argsa)<1 then return(true),
        
        if atom(argsa[1]) then return(true),
      
        /* case: (x-1)^2 + c*/
        if op(argsa[1])="^" and part(argsa[1],2)=2 then cform:true,
        
        /* case: k*(x-1)^2 + c*/
        if op(argsa[1])="*" then block([argsb], 
           argsb: sublist(args(argsa[1]),lambda([ex],elementp(wrt,setify(listofvars(ex))))),
           if length(argsb)=1 then
               if op(argsb[1])="^" and part(argsb[1],2)=2 then cform:true
        )
    ),
    
    /* Check for algebraic equivalence */
    if cform and ae then
        return([true,true,StackAddNote("","ATCompSquare_true"),""]),

    if cform then
        return([true,false,StackAddNote("","ATCompSquare_true_not_AlgEquiv"),StackAddFeedback("","ATCompSquare_not_AlgEquiv")]),

    if not(ae) then
        return([true,false,StackAddNote("","ATCompSquare_false_not_AlgEquiv"),""]),

    AnswerNote:concat("ATCompSquare_false",AnswerNote),
    return([true,false,StackAddNote("",AnswerNote),StackAddFeedback("",AnswerNote)])
    )$



/*********************/
/* Calculus question */
/*********************/

/* This function substitutes an "integrationconstant" in ex for v.
   If v is a list, this substitutes as many integration constants as possible */
subst_int_const(ex,v):=block([lv,li,ls],
  lv:listofvars(ex),
  li:sublist_indices(lv, lambda([ex],is(smismatch("integrationconstant",string(ex))>19) or is(smismatch("%c",string(ex))>2)) ),
  if emptyp(li) then return(ex),
  /* If we have only one variable v, then use this */
  if not(listp(v)) then return(subst(lv[li[1]]=v,ex)),
  ls:map(lambda([n],lv[n]),li),
  subst(zip_with("=",ls,v),ex)
  )$

/* This function strips off any trailing constant of integration from an expression, which is not a number */
strip_int_const(ex, v) := block([ex2,fargs],
    ex2:ex,
    if atom(ex) then return(ex), 
    if op(ex)="+" then
       (fargs:sublist(args(ex),lambda([ex2],not(freeof(v,ex2)) or simp_numberp(ex2))),
        if length(fargs)=1 then ex2:fargs[1] else ex2:apply("+",fargs)),
    return(ex2))$

/********************************************************************/
/* An answer test for integration questions.                        */
/* sa is the students' answer,                                      */
/* sbl is a list consisting of (1) the answer, and (2) the variable */
/********************************************************************/
ATInt(sa, sbl) := block([oldsimp, keepfloat, Validity, RawMark, FeedBack, AnswerNote, var, sb, sbdisp, ret, cont],
    oldsimp:simp,
    simp:false,
    Validity:true, RawMark:false,
    FeedBack:"", AnswerNote:"",
    keepfloat:true,

    SAA:errcatch(ev(sa, simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then 
        return([false, false, StackAddNote("", "ATInt_STACKERROR_SAns"), ""]),
    SBB:errcatch(ev(sbl, simp, nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then 
        return([false, false, StackAddNote("", "ATInt_STACKERROR_TAns"), ""]),

    /* SBL is a list: the teacher's answer, the variable, and whether formative feedback is to be provided. */
    if listp(sbl) then
        (var:sbl[2], sb:sbl[1], cont:true)
    else
        (cont:false, FeedBack:StackAddFeedback("", "ATInt_STACKERROR_LIST"), AnswerNote:StackAddNote("", "ATInt_STACKERROR_LIST")),

    /* Is the variable still a list at this stage?
       If so, the teacher has provided the original expression for feedback purposes. 
    */
    if listp(var) then block(
        if is(length(var)=2) then block(
            sbdisp:second(var),
            var:first(var)
        ) else block(
            print("TEST_FAILED"),
            cont:false, Validity:false, FeedBack:StackAddFeedback("", "ATInt_STACKERROR_OptList"), AnswerNote:StackAddNote("", "ATInt_STACKERROR_OptList")
        )
    ) else 
        sbdisp:ev(diff(sb, var), simp),

    ret:[true, RawMark, AnswerNote, FeedBack], 

    /* SA should be only an expression. */
    if expressionp(sa)=false then
        return([false, false, StackAddNote("", "ATInt_SA_not_expression"), StackAddFeedback("", "ATAlgEquiv_SA_not_expression")])
    else block(
        keepfloat:true,
        if cont then
            ret:Intfun(sa, sb, sbdisp, var)
        ),
    simp:oldsimp,
    return(ret)
    )$

Intfun(SA, SB, SBdisp, v) := block([val,rawmk,ansnote,fb,ret,ex,SAd,SBd,SBraw,saa,dd,dc,lSAv,lSBv,mSAv,mSBv,SAConsistentLogs,SAUsedLogAbs,SBUsedLogAbs],
    val:true, rawmk:false, fb:"", ansnote:"", debug:false,
    ret:[val, rawmk, ansnote, fb],
    /* Check if the teacher and student used only log abs. 
       Teacher must be consistent, otherwise the student doesn't have to be!*/
    SAUsedLogAbs:ATInt_logabs_p(SA,v),
    SBUsedLogAbs:ATInt_logabs_p(SB,v),
    if debug then print(["Original expressions: ", SA, SB]),
    if debug then print(["Used Logabs?: ", SAUsedLogAbs, SBUsedLogAbs]),
    /* This expands out logarithms for constants, e.g. ln(k*|x|) */
    SB:ev(SB, logexpand:super, simp), 
    if debug then print(["Expanded any log constants in the teacher's answer? ", SA, SB]),
    /* This strips off any trailing constant of integration from the teacher's answer */
    SB:strip_int_const(SB, v),
    /* This strips off any trailing constant of integration from the student's answer */
    SAa:strip_int_const(ev(SA, logexpand:super, simp), v),
    if debug then print(["Striped off  constants of integration: ", SA, SB]),
    /* If the teacher has not used logabs, then strip out any logabs from the student's answer. */
    /* Student consistency is a different issue. */
    SAConsistentLogs:ATInt_consistent_logabs_p(SA,v),
    if not(SBUsedLogAbs) then (
      SA:subst(STACKLA=log, ATInt_logabs_to_STACKLA(SA)),
      SAa:subst(STACKLA=log, ATInt_logabs_to_STACKLA(SAa))
      ),
    /* Calculate derivatives */
    SAd:ev(diff(SA,v),simp),
    SBd:ev(diff(SB,v),simp),
    /* Check for constant of integration - code copied from algebraic_equivalence */
    ex:errcatch(ev(fullratsimp(SA-SB), simp, trigexpand:true, logexpand:super, keepfloat:true)),
    if ex=[] then (return([false, false, "ATInt: simplification failed.", StackAddFeedback("", "ATInt_generic", StackDISP(SBdisp, "d"), StackDISP(v, "i"), StackDISP(SAd, "d"))])),
    ex:ex[1],
    ex:ev(trigsimp(ex), simp),
    ex:ev(trigreduce(ex), simp),
    dd:ev(float(ex), simp),
    dc:numberp(dd) and dd#0.0,
    if debug then print([SAa, SBd]),
    if debug then print(["Simplified difference: ", ex]),
    if ev(algebraic_equivalence(SAd,SBd), simp) then
        if ex=0 then
            (rawmk:false, fb:StackAddFeedback("", "ATInt_const"), ansnote:StackAddNote("", "ATInt_const"))
        else if dc then
            (rawmk:false, fb:StackAddFeedback("", "ATInt_const_int"), ansnote:StackAddNote("", "ATInt_const_int"))
        else if freeof(log, SA) and not(ATIntWeirdConstp(ex)) then
            (rawmk:true, ansnote:StackAddNote("", "ATInt_true"))
        else if freeof(log, SA) and ATIntWeirdConstp(ex) then
            (rawmk:false, fb:StackAddFeedback("", "ATInt_weirdconst"), ansnote:StackAddNote("", "ATInt_weirdconst"))
        /* From this point onwards we *have logarithms*. */
        else if ev(algebraic_equivalence(SA, SB), simp) then
            (rawmk:false, fb:StackAddFeedback("", "ATInt_const"), ansnote:StackAddNote("", "ATInt_const_equiv"))
        else if ev(algebraic_equivalence(SAa, SB), simp) then
            (rawmk:true, ansnote:StackAddNote("", "ATInt_true_equiv"))            
        else if freeof(v,ex) and not(ATIntWeirdConstp(ex)) then
            (rawmk:true, ansnote:StackAddNote("", "ATInt_true_differentconst"))
        else
            (rawmk:false, fb:StackAddFeedback("", "ATInt_EqFormalDiff"), ansnote:StackAddNote("", "ATInt_EqFormalDiff"))
    else /* Check for the special cases where the buggy rule is true */
       if ev(algebraic_equivalence(SAa, ev(diff(SBd, v), simp)),simp) and ev(algebraic_equivalence(exp(x), SBd),simp)#true then
           (rawmk:false, fb:StackAddFeedback("", "ATInt_diff"), ansnote:StackAddNote("", "ATInt_diff"))
       else 
           (rawmk:false, fb:StackAddFeedback("", "ATInt_generic", StackDISP(SBdisp, "d"), StackDISP(v, "i"), StackDISP(SAd, "d")), ansnote:StackAddNote("", "ATInt_generic")),
    /* Has the student used log(x) vs log(abs(x)) in their answer? */
    if not(SAUsedLogAbs) and SBUsedLogAbs then
            (rawmk:false, fb:StackAddFeedback("", "ATInt_logabs"), ansnote:StackAddNote(ansnote, "ATInt_logabs")),
    /* Has the student been inconsistent in using log(x) vs log(abs(x)) in their answer? */
    if not(SAConsistentLogs) then
            (rawmk:false, fb:StackAddFeedback("", "ATInt_logabs_inconsistent"), ansnote:StackAddNote(ansnote, "ATInt_logabs_inconsistent")),
    lSAv:listofvars(SA),
    lSAv:listofvars(SA),
    lSBv:listofvars(SB),
    mSAv:member(v, lSAv),
    mSBv:member(v, lSBv),
    if not(mSBv) then (
        if mSAv then
            ansnote:StackAddNote(ansnote, "ATInt_var_SA_notSB")
        else if not(listscontain(lSAv, lSBv, v)) and not(listsoverlap(lSAv, lSBv)) then
            ansnote:StackAddNote(ansnote, "ATInt_var_notSASB_SAnceSB") ) /* v not in SA or SB, and no variable common to SA and SB */
    else if not(mSAv) then
        if mSBv then
            ansnote:StackAddNote(ansnote, "ATInt_var_SB_notSA"),

    ret:[val, rawmk, ansnote, fb],
    return(ret)
)$

/* This function decides if the constant of integration looks "weird".*/
ATIntWeirdConstp(ex):=block([l],
    l:listofvars(ex),
    if length(l)#1 then return(true),
    if degree(ex, first(l))#1 then return(true)
    else return(false)
)$

/* Checks all occurances of v are inside abs, e.g. abs(v) */
ATInt_var_in_abs_p(ex, v):=block(
  if ex=v then return(false),  /* v on its own is not inside abs() */
  if atom(ex) then return(true),
  if freeof(v,ex) then return(false), /* if we don't have v then it is not inside abs() */
  if safe_op(ex) = "abs" then return(true),
  apply("and", maplist(lambda([ex2], ATInt_var_in_abs_p(ex2, v)), args(ex)))
)$

/* Check if all occurances of the variable v, which are inside a log function, are protected by abs() */
ATInt_logabs_p(ex, v):=block(
  if atom(ex) then return(true),
  if safe_op(ex) = "log" then return(apply("and", maplist(lambda([ex2], ATInt_var_in_abs_p(ex2, v)), args(ex)))),
  apply("and", maplist(lambda([ex2], ATInt_logabs_p(ex2, v)), args(ex)))
)$

/* Transform log(abs(ex)) to a single dummy function STACKLA(ex)
   This enables us to strip them out.  This will not catch all cases, e.g. log(k*abs(x)) isn't caught here...
*/
ATInt_logabs_to_STACKLA(ex):=block(
  if atom(ex) then return(ex),
  if safe_op(ex) = "log" then (
    if atom(first(args(ex))) then 
        return(ex)
    else if safe_op(first(args(ex))) = "abs" then 
        return(STACKLA(first(args(first(args(ex))))))
    ),
  return(apply(op(ex),maplist(ATInt_logabs_to_STACKLA,args(ex))))
)$

/* Has the student been consistent in using log(abs(ex))?                     */
/* We need to check for the integration variable, inside logarithm functions. */
/* We don't want things like log(3) to "look like" a log here.                */
ATInt_consistent_logabs_p_helper(ex,v):=block(
  if atom(ex) then return(0),
  if safe_op(ex) = "log" and ATInt_var_in_abs_p(ex, v) then return(STACKLOGABS),
  if safe_op(ex) = "log" and member(v, listofvars(args(ex))) then return(STACKLOG),
  return(apply("+",maplist(lambda([ex1],ATInt_consistent_logabs_p_helper(ex1,v)),args(ex))))
);

ATInt_consistent_logabs_p(ex,v):=block([helper],
  helper:ev(ATInt_consistent_logabs_p_helper(ex,v),simp),
  helper:listofvars(helper),
  if member(STACKLOG, helper) and member(STACKLOGABS, helper) then false else true
);

/********************************************************************/
/* An answer test for differentiation questions.                    */
/* sa is the students' answer,                                      */
/* sbl is a list consisting of (1) the answer, and (2) the variable */
/********************************************************************/
ATDiff(sa,sbl) :=
    block([old_simp, keepfloat, RawMark, FeedBack, AnswerNote, ret, str, da, db, dd, dc, sb, var, cont, SAA, SBB],
    old_simp:simp, simp:true, RawMark:false, FeedBack:"", AnswerNote:"",
    keepfloat:true,

    SAA:errcatch(ev(sa, simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then return([false,false,StackAddNote("","ATDiff_STACKERROR_SAns"),""]),
    SBB:errcatch(ev(sbl, simp, nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then return([false,false,StackAddNote("","ATDiff_STACKERROR_TAns"),""]),

    /* SBL is a list: the teacher's answer, the variable, and whether formative feedback is to be provided. */
    if listp(sbl) then
    (var:sbl[2], sb:sbl[1], cont:true)
    else
       (cont:false, FeedBack:StackAddFeedback("","ATDiff_STACKERROR_LIST"), AnswerNote:StackAddNote("","ATDiff_STACKERROR_LIST")),
    ret:[cont, RawMark, AnswerNote, FeedBack],  /* In case sbl not list */

    /* SA should be only an expression. */
    if expressionp(sa)=false then
        return([false,false,StackAddNote("","ATDiff_SA_not_expression"),StackAddFeedback("","ATAlgEquiv_SA_not_expression")])
    else block(
        keepfloat:true,
        if cont then
        ret:Difffun(sa,sb,var)
        ),
    simp:old_simp,
    return(ret)
    )$

Difffun(SA,SB,v) := block([val,rawmk,ansnote,fb,ret,lSAv,lSBv,mSAv,mSBv],
    val:true, rawmk:false, fb:"", ansnote:"",
    ret:[val,rawmk,ansnote,fb],
    if algebraic_equivalence(SA,SB) then
        (rawmk:true, ansnote:StackAddNote("","ATDiff_true"))
    else
        if algebraic_equivalence(diff(SA,v),int(SB,v)) then
        (rawmk:false, ansnote:StackAddNote("","ATDiff_int"), fb:StackAddFeedback("","ATDiff_int"))
        else (
            lSAv:listofvars(SA),
            lSBv:listofvars(SB),
            mSAv:member(v,lSAv),
            mSBv:member(v,lSBv),
            if not(mSBv) then (
                if mSAv then
                    ansnote:StackAddNote(ansnote,"ATDiff_var_SA_notSB")
                else if not(listscontain(lSAv,lSBv,v)) and not(listsoverlap(lSAv,lSBv)) then
                    ansnote:StackAddNote(ansnote,"ATDiff_var_notSASB_SAnceSB") ) /* not in SA or SB, and no variable common to SA and SB */
            else if not(mSAv) then (
                if mSBv then
                    ansnote:StackAddNote(ansnote,"ATDiff_var_SB_notSA") )  ),
    ret:[val,rawmk,ansnote,fb],
    return(ret)
    )$

/* ****************************************************** */
/*                                                        */
/* The assess function takes two expressions, ex1 and ex2 */
/*                                                        */
/* It returns the name of the *strictest* sense in which  */
/* they are considered to be the "same"                   */
/*                                                        */
/* ****************************************************** */

assess(ex1,ex2):=block([ret],

    SAA:errcatch(ev(SA, simp, nouns)),
    if (is(SAA=[STACKERROR]) or is(SAA=[])) then return([false,false,"assess_STACKERROR_SAns",""]),
    SBB:errcatch(ev(SBL,simp, nouns)),
    if (is(SBB=[STACKERROR]) or is(SBB=[])) then return([false,false,"assess_STACKERROR_TAns",""]),

    ret:ATCASEqual(ex1,ex2),
    if ret[2] then return("ATCASEqual"),

    ret:ATEqualComAss(ex1,ex2),
    if ret[2] then return("ATEqualComAss"),
    
    ret:ATAlgEquiv(ex1,ex2),
    if ret[2] then return("ATAlgEquiv"),

    ret:ATSubstEquiv(ex1,ex2),    
    if ret[2] then return("ATSubstEquiv"),

    ret:ATSameType(ex1,ex2), 
    if ret[2] then return("ATSameType"),
    
    return("")
)$

/* Slight hack to compile these functions and hence suppress warnings. */
load(linearalgebra);

/* Stack expects some output */
stackmaximaversion:2015090900$
print("[ STACK-Maxima started, library version 2015090900 ]")$
