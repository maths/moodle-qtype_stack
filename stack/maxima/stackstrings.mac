/* Various string processing tools, primarily for parsing and generating JSON.  */


/* First some functions for dealing with stack_maps. */

/* A map is a list of key value pairs with the first element being the string "stack_map" */
/* We intentionally skip the use of structs to allow people to directly process the "map" */
/* from within STACK question code as structs were still forbidden there at the time. */
/* Also avoiding certain list convenience functions as they are quite recent additions */
/* to Maxima, so do not wonder why things are done at quite a low level. */
is_stackmap(x) := ev(listp(x) and is(length(x)>0) and is(x[1]="stack_map"), simp)$
/* might as we be called stackmapp() but that sounds odd. */
stackmapp(x) := is_stackmap(x)$

stackmap_get(m, k) := block([],
 if not is_stackmap(m) then return(und),
 return(assoc(k,rest(m,1),und))
)$

stackmap_set(m, k, v) := block([],
 /* If we are given anything else than a map as the map we make a new map. */
 if not is_stackmap(m) then return(["stack_map",[k,v]]),
 /* Find all others. */
 return(append(["stack_map"],sublist(rest(m,1), lambda([x],is(x[1]#k))),[[k,v]]))
)$

stackmap_unset(m, k) := block([],
 if not is_stackmap(m) then return(und),
 return(append(["stack_map"],sublist(rest(m,1), lambda([x],is(x[1]#k)))))
)$

stackmap_keys(m) := block([],
 if not is_stackmap(m) then return(und),
 return(map(lambda([x], x[1]), rest(m,1)))
)$

stackmap_values(m) := block([],
 if not is_stackmap(m) then return(und),
 return(map(lambda([x], x[2]), rest(m,1)))
)$

stackmap_has_key(m, k) := block([tmp, found],
 found: false,
 if not is_stackmap(m) then return(false),
 for tmp in rest(m,1) do (if is(tmp[1]=k) then (found:true,break)),
 return(found)
)$


/* This function takes a string containing JSON and returns a list, number, string, */
/* boolean or a stackmap depending on what if finds. Should it find null or empty */
/* input it returns und. */
/* Note that we do use stringproc. */
stackjson_parse(json) := block([r,tmp,tokens,mode,i,lastslash,c,starts,nt,k,v,dm],
 r: und,
 if not stringp(json) or is(json="") then return(und),
 tmp:strim(sconcat(ascii(32),ascii(9),ascii(10),ascii(11),ascii(12),ascii(13)),json),
 if is(tmp="") then return(und),

 /* easy ones */
 if is(tmp="true") then return(true),
 if is(tmp="false") then return(false),
 if is(tmp="null") then return(und),
 if is(tmp="[]") then return([]),
 if is(tmp="{}") then return(["stack_map"]),

 /* Not easy, do some tokenising */
 mode:"raw", /* In a string or not, maybe number */
 i:0,
 tokens:[],
 lastslash:false,
 while ev(is(i<slength(tmp)), simp) do (
  c:charat(tmp, ev(i+1, simp)),
  if is(mode="raw") then (
   if is(c="[") then tokens:append(tokens,[_stackjson_tokens_list_open])
   elseif is(c="]") then tokens:append(tokens,[_stackjson_tokens_list_close])
   elseif is(c="{") then tokens:append(tokens,[_stackjson_tokens_dict_open])
   elseif is(c="}") then tokens:append(tokens,[_stackjson_tokens_dict_close])
   elseif is(c=":") then tokens:append(tokens,[_stackjson_tokens_key_sep])
   elseif is(c=",") then tokens:append(tokens,[_stackjson_tokens_list_sep])
   elseif is(c="\"") then (mode:"string",lastslash:false,r:"")
   elseif is(c="n") and is(charat(tmp,i+2)="u") and is(charat(tmp,i+3)="l") and is(charat(tmp,i+4)="l") then (i:i+3, tokens:append(tokens,[und]))
   elseif is(c="t") and is(charat(tmp,i+2)="r") and is(charat(tmp,i+3)="u") and is(charat(tmp,i+4)="e") then (i:i+3, tokens:append(tokens,[true]))
   elseif is(c="f") and is(charat(tmp,i+2)="a") and is(charat(tmp,i+3)="l") and is(charat(tmp,i+4)="s") and is(charat(tmp,i+5)="e") then (i:i+4, tokens:append(tokens,[false]))
   elseif not is(sposition(c,sconcat(ascii(32),ascii(9),ascii(10),ascii(11),ascii(12),ascii(13)))=false) then (i:i)
   elseif is(c="-") then (mode:"number",r:["-"])
   elseif digitcharp(c) then (mode:"number",r:[c])
  ) elseif is(mode="string") then (
   if(lastslash) then (
    lastslash:false,
    if is(c="\\") then r:sconcat(r,"\\")
    elseif is(c="n") then r:sconcat(r,ascii(10))
    elseif is(c="t") then r:sconcat(r,ascii(9))
    elseif is(c="r") then r:sconcat(r,ascii(13))
    elseif is(c="b") then r:sconcat(r,ascii(8))
    elseif is(c="f") then r:sconcat(r,ascii(12))
    elseif is(c="\"") then r:sconcat(r,"\"")
    elseif is(c="u") then (r:sconcat(r,unicode(stack_string_hex_to_num(substring(tmp,i+2,i+6)))),i:i+4)
    else r:sconcat(r,c)
   ) else (
    if is(c="\\") then lastslash:true
    elseif is(c="\"") then (tokens:append(tokens,[r]),mode:"raw")
    else r:sconcat(r,c)
   )
  ) elseif is(mode="number") then (
   if digitcharp(c) then r:append(r,[c])
   elseif is(c=".") then r:append(r,[c])
   elseif is(c="e") then r:append(r,[c])
   elseif is(c="E") then r:append(r,[c])
   elseif is(c="+") then r:append(r,[c])
   elseif is(c="-") then r:append(r,[c])
   else (tokens:append(tokens,[stack_string_parse_number(simplode(r))]),i:i-1,mode:"raw")
  ),
  i:i+1
 ),

 /* In the unlikely case that we have an atomic value e.g. string or number exit early. */
 if is(length(tokens)=1) then return(tokens[1]),
 dm:0,
 /* Otherwise reduce grouppings. */
 starts:sublist_indices(tokens, lambda([x], is(x=_stackjson_tokens_list_open) or is(x=_stackjson_tokens_dict_open))),
 while ev(is(length(starts)>0), simp) do (
  r:[],
  nt:[],
  i:1,
  /* Change this to actual sublist as this is not the way to do it... */
  while ev(is(i<last(starts)), simp) do (nt:append(nt,[tokens[i]]), i:ev(i+1, simp)),
  if is(tokens[last(starts)]=_stackjson_tokens_list_open) then (
   i:last(starts)+1,
   while not is(tokens[i]=_stackjson_tokens_list_close) do (
    if not is(tokens[i]=_stackjson_tokens_list_sep) then r:append(r,[tokens[i]]),
    i:ev(i+1, simp)
   )
  ) else (
   r:["stack_map"],
   i:ev(last(starts)+1, simp),
   while not ev(is(tokens[i]=_stackjson_tokens_dict_close), simp) do (
    if not ev(is(tokens[i]=_stackjson_tokens_list_sep), simp) then (
     k:tokens[i],
     v:tokens[ev(i+2, simp)],
     r:append(r,[[k,v]]),
     i:ev(i+3, simp)
    ) else i:ev(i+1, simp)
   )  
  ),
  nt:append(nt,[r]),
  i:i+1,
  /* Change this to actual sublist as this is not the way to do it... */
  while ev(is(i<length(tokens)+1), simp) do (nt:append(nt,[tokens[i]]),i:ev(i+1, simp)),
  if ev(is(length(nt)<length(tokens)), simp) then dm:0,
  tokens:nt,
  /* If the string is bad we may loop forever for this we have an automated exit. */
  dm:ev(dm+1, simp),
  if ev(is(dm>20), simp) then return(und),
  starts:sublist_indices(tokens, lambda([x], is(x=_stackjson_tokens_list_open) or is(x=_stackjson_tokens_dict_open)))
 ),
 /* At this point the tokens list has been reduced to length of one or things are broken... */
 return(tokens[1])
)$

/* Takes a string that is assumed to be hexadecimal and turns it to an integer the hard way. */
/* Returns interesting things if the input is not hexadecimal... */
stack_string_hex_to_num(hexstring) := block([c, tmp],
 c:0,
 for tmp in charlist(sdowncase(hexstring)) do c:c*16+(sposition(tmp,"0123456789abcdef")-1),
 return(ev(c, simp))
)$

/* Takes a string representing an integer or a float and parses it the hard way to avoid having to eval it. */
/* probably sensitive to large exponents */
stack_string_parse_number(somestring) := block([c, b, phase, neg,nege, tmp, i],
 neg:false,
 nege:false,
 c:0,
 phase:"left of dot",
 i:0,
 b:0,
 for tmp in charlist(sdowncase(somestring)) do (
  if is(phase="left of dot") then (
   if is(tmp=".") then (phase:"right of dot", i:-1)
   elseif is(tmp="-") then neg:true
   elseif is(tmp="+") then neg:false
   elseif digitcharp(tmp) then c:c*10+(cint(tmp)-48)
   elseif is(tmp="e") then phase:"exponent"
  ) elseif is(phase="right of dot") then (
   if digitcharp(tmp) then (c:c+((cint(tmp)-48)*10^i),i:i-1)
   elseif is(tmp="e") then phase:"exponent"
  ) elseif is(phase="exponent") then (
   if is(tmp="-") then nege:true
   elseif is(tmp="+") then nege:false
   elseif digitcharp(tmp) then b:b*10+(cint(tmp)-48)
  )
 ),
 if is(phase="exponent") then if nege then c:c*10^-b else c:c*10^b,
 c:ev(c, numer, simp),
 if neg then return(-c),
 return(c)
)$


/* Takes pretty much anything and turns it to a JSON string */
stackjson_stringify(obj) := block([tmp,r,l],
 r:und,
 if is(obj=und) then r:"null"
 else if is(obj=false) then r:"false"
 else if is(obj=true) then r:"true"
 else if stringp(obj) then (
  tmp:ssubst("\\\\","\\",obj),
  tmp:ssubst("\\\"","\"",tmp),
  tmp:ssubst("\\b",ascii(8),tmp),
  tmp:ssubst("\\t",ascii(9),tmp),
  tmp:ssubst("\\n",ascii(10),tmp),
  tmp:ssubst("\\f",ascii(12),tmp),
  tmp:ssubst("\\r",ascii(13),tmp),
  r:sconcat("\"",tmp,"\"")
 ) else if is_stackmap(obj) then (
  l:[],
  for tmp in stackmap_keys(obj) do l:append(l,[sconcat(stackjson_stringify(tmp),":",stackjson_stringify(stackmap_get(obj,tmp)))]), 
  r:sconcat("{",simplode(l,","),"}")
 ) else if listp(obj) and length(obj) > 0 then r:sconcat("[",simplode(makelist(stackjson_stringify(x),x,obj),","),"]")
 else if listp(obj) then r:"[]"
 else if integerp(obj) then r:string(obj)
 else if numberp(obj) then r:string(float(obj))
 else r:stackjson_stringify(string(obj)),
 return(r)
)$


/**
 * Special tools for dealing with CASText2, absolutely no use
 * if you are not running a system with CASText2.
 *
 * Even if you have CASText2 enabled system these tools are very
 * advanced and probably not for a novice author. Essenttially,
 * these are useful if one generates CASText2 values inside
 * keyval-fields and/or stores them into the state in Stateful.
 * The only real use for a raw CASText2 value is to be outputted
 * by the castext-block within castext itself.
 *
 * Note that while it is possible to manually construct a CASText2
 * value the preferred way is to use the compiler logic and just
 * write normal, although escaped, CASText inside a Maxima-string
 * and let the compiler deal with it.
 */
/**
 * Condenses the result of a CASText2 expression. Speeds PHP-side
 * parsing and lessens the transferred bytes.
 */
castext_simplify(ct2) := block([_r,_i,_t,_redo],
 if stringp(ct2) then return(ct2),
 if listp(ct2) then (
  _i:0,
  _redo:false,
  _r:[ct2[1], castext_simplify(ct2[2])],
  if is(ct2[1]="%root") then _i:2,
  /* We especially want to try to simplify jsxgraph-block content. 
   * It is likely to be highly fragmented with plenty of injections.
   */
  if is(ct2[1]="jsxgraph") then (_i:3, _r: append(_r,[castext_simplify(ct2[3])])),
  if is(_i>0) then (
    if listp(last(_r)) and is(last(_r)[1]="%root") then (
      _redo: true,
      _r : append(firstn(_r, ev(length(_r) - 1, simp)), rest(last(_r)))
    ),
    while _i < length(ct2) do (
      _i: ev(_i + 1, simp),
      _t: castext_simplify(ct2[_i]),
      if stringp(_t) and stringp(last(_r)) then (
        _r[length(_r)] : sconcat(last(_r), _t)
      ) else if listp(_t) and is(_t[1]="%root") then (
        /* If we do this we may skip simplification of terms. */
        _redo: true,
        _r : append(_r, rest(_t))
      ) else (
        _r : append(_r, [_t])
      )
    ),
    if is(_r[1]="%root") and is(length(_r)=2) and stringp(_r[2]) then (
      return(_r[2])
    ),
    if _redo then return(castext_simplify(_r)),
    return(_r)
  )
 ),
 return(ct2)
)$

/**
 * A concat for castext2. If you need to concat more terms lreduce...
 */
castext_concat(a, b) := block([_tmp,_a,_b],
 _a: castext_simplify(a),
 _b: castext_simplify(b),
 if stringp(_a) and stringp(_b) then return(sconcat(_a,_b)),
 return(castext_simplify(["%root", _a, _b]))
)$

/**
 * For now we include this as a predicate function not a full answer test.
 */
regex_match_exactp(regex, str) := block([l1, bool1],
  l1:regex_match(regex, str),
  bool1:listp(l1), 
  if bool1 then block([strmatch],
    strmatch:first(l1),
    bool1:sequal(str, strmatch)
  ),
return(bool1))$
