/**
 * Pads a `stackbasen` number with 0-digits from the left so that the number
 * has the desired width (bit width or otherwise). Intended for binary
 * operations but can be used in general for example to pad hexadecimal to
 * a given word size.
 *
 * Note should the number already be wider than the width will not modify it.
 * Use `sbasen_truncate_left` to throw the extra high digits away if that is 
 * neeeded.
 *
 * @param[stackbasen] number, a stackbasen-object to pad.
 * @param[int] width, the digit width to aim for
 * @return[stackbasen] the padded stackbasen-object.
 */
sbasen_pad(number, width) := block([simp,digits,fmt,base,prefix,suffix],
    simp: true,
	[digits,fmt,base]: args(number),
	
	suffix:"",
	prefix:"",
	if is(fmt = "S") then (suffix: sconcat("_", base), digits: split(digits, "_")[1])
	elseif is(fmt = "C") and is(base = 8) then (prefix: "0", digits: substring(digits, 2))
	elseif is(fmt = "C") and is(base = 16) then (prefix: "0x", digits: substring(digits, 3))
	elseif is(fmt = "C") then (prefix: "0b", digits: substring(digits, 3)),

	/* If already wide enough. */
	if is(slength(digits) >= width) then return(number),
    digits: sconcat(simplode(makelist("0", x, 1, width - slength(digits))), digits),

	return(stackbasen(sconcat(prefix, digits, suffix), fmt, base))
)$

s_test_case(simp) := is(sbasen_pad(stackbasen("0xA1","C",16),4)=stackbasen("0x00A1","C",16))$
s_test_case(simp) := is(sbasen_pad(stackbasen("1_2","S",2),8)=stackbasen("00000001_2","S",2))$

/**
 * Drops extra highest digits from the number if the number is overly long.
 * Might be of use when doing binary operations.
 *
 * There is a lowest digits version `sbasen_truncate_right` should one need it.
 *
 * @param[stackbasen] number, a stackbasen-object to truncate.
 * @param[int] width, the digit width to aim for
 * @return[stackbasen] the padded stackbasen-object.
 */
sbasen_truncate_left(number, width) := block([simp,digits,fmt,base,prefix,suffix],
    simp: true,
	[digits,fmt,base]: args(number),
	
	suffix:"",
	prefix:"",
	if is(fmt = "S") then (suffix: sconcat("_", base), digits: split(digits, "_")[1])
	elseif is(fmt = "C") and is(base = 8) then (prefix: "0", substring(digits, 2))
	elseif is(fmt = "C") and is(base = 16) then (prefix: "0x", substring(digits, 3))
	elseif is(fmt = "C") then (prefix: "0b", substring(digits, 3)),

	/* If already short enough. */
	if is(slength(digits) <= width) then return(number),
    digits: substring(digits, slength(digits) - width + 1),

	return(stackbasen(sconcat(prefix, digits, suffix), fmt, base))
)$

s_test_case(simp) := is(sbasen_truncate_left(stackbasen("00000001_2","S",2),4)=stackbasen("0001_2","S",2))$


/**
 * Drops extra lowest digits from the number if the number is overly long.
 * Might be of use when doing binary operations.
 *
 * There is a highest digits version `sbasen_truncate_left` should one need it.
 *
 * @param[stackbasen] number, a stackbasen-object to truncate.
 * @param[int] width, the digit width to aim for
 * @return[stackbasen] the padded stackbasen-object.
 */
sbasen_truncate_right(number, width) := block([simp,digits,fmt,base,prefix,suffix],
    simp: true,
	[digits,fmt,base]: args(number),
	
	suffix:"",
	prefix:"",
	if is(fmt = "S") then (suffix: sconcat("_", base), digits: split(digits, "_")[1])
	elseif is(fmt = "C") and is(base = 8) then (prefix: "0", substring(digits, 2))
	elseif is(fmt = "C") and is(base = 16) then (prefix: "0x", substring(digits, 3))
	elseif is(fmt = "C") then (prefix: "0b", substring(digits, 3)),

	/* If already short enough. */
	if is(slength(digits) <= width) then return(number),
    digits: substring(digits, 1, width + 1),

	return(stackbasen(sconcat(prefix, digits, suffix), fmt, base))
)$

s_test_case(simp) := is(sbasen_truncate_right(stackbasen("00000001_2","S",2),4)=stackbasen("0000_2","S",2))$