/**
 * Pads a `stackbasen` number with 0-digits from the left so that the number
 * has the desired width (bit width or otherwise). Intended for binary
 * operations but can be used in general for example to pad hexadecimal to
 * a given word size.
 *
 * Note should the number already be wider than the width will not modify it.
 * Use `sbasen_truncate_left` to throw the extra high digits away if that is 
 * neeeded.
 *
 * @param[stackbasen] sbasen_number, a stackbasen-object to pad.
 * @param[int] width, the digit width to aim for
 * @return[stackbasen] the padded stackbasen-object.
 */
sbasen_pad(sbasen_number, width) := block([simp,digits,fmt,base,prefix,suffix],
    simp: true,
	[digits,fmt,base]: args(sbasen_number),
	
	suffix:"",
	prefix:"",
	if is(fmt = "S") then (suffix: sconcat("_", base), digits: split(digits, "_")[1])
	elseif is(fmt = "C") and is(base = 8) then (prefix: "0", digits: substring(digits, 2))
	elseif is(fmt = "C") and is(base = 16) then (prefix: "0x", digits: substring(digits, 3))
	elseif is(fmt = "C") then (prefix: "0b", digits: substring(digits, 3)),

	/* If already wide enough. */
	if is(slength(digits) >= width) then return(sbasen_number),
    digits: sconcat(simplode(makelist("0", x, 1, width - slength(digits))), digits),

	return(stackbasen(sconcat(prefix, digits, suffix), fmt, base))
)$

s_test_case(simp) := is(sbasen_pad(stackbasen("0xA1","C",16),4)=stackbasen("0x00A1","C",16))$
s_test_case(simp) := is(sbasen_pad(stackbasen("1_2","S",2),8)=stackbasen("00000001_2","S",2))$

/**
 * Drops extra highest digits from the number if the number is overly long.
 * Might be of use when doing binary operations.
 *
 * There is a lowest digits version `sbasen_truncate_right` should one need it.
 *
 * @param[stackbasen] sbasen_number, a stackbasen-object to truncate.
 * @param[int] width, the digit width to aim for
 * @return[stackbasen] the padded stackbasen-object.
 */
sbasen_truncate_left(sbasen_number, width) := block([simp,digits,fmt,base,prefix,suffix],
    simp: true,
	[digits,fmt,base]: args(sbasen_number),
	
	suffix:"",
	prefix:"",
	if is(fmt = "S") then (suffix: sconcat("_", base), digits: split(digits, "_")[1])
	elseif is(fmt = "C") and is(base = 8) then (prefix: "0", digits: substring(digits, 2))
	elseif is(fmt = "C") and is(base = 16) then (prefix: "0x", digits: substring(digits, 3))
	elseif is(fmt = "C") then (prefix: "0b", digits: substring(digits, 3)),

	/* If already short enough. */
	if is(slength(digits) <= width) then return(sbasen_number),
    digits: substring(digits, slength(digits) - width + 1),

	return(stackbasen(sconcat(prefix, digits, suffix), fmt, base))
)$

s_test_case(simp) := is(sbasen_truncate_left(stackbasen("00000001_2","S",2),4)=stackbasen("0001_2","S",2))$


/**
 * Drops extra lowest digits from the number if the number is overly long.
 * Might be of use when doing binary operations.
 *
 * There is a highest digits version `sbasen_truncate_left` should one need it.
 *
 * @param[stackbasen] number, a stackbasen-object to truncate.
 * @param[int] width, the digit width to aim for
 * @return[stackbasen] the padded stackbasen-object.
 */
sbasen_truncate_right(sbasen_number, width) := block([simp,digits,fmt,base,prefix,suffix],
    simp: true,
	[digits,fmt,base]: args(sbasen_number),
	
	suffix:"",
	prefix:"",
	if is(fmt = "S") then (suffix: sconcat("_", base), digits: split(digits, "_")[1])
	elseif is(fmt = "C") and is(base = 8) then (prefix: "0", digits: substring(digits, 2))
	elseif is(fmt = "C") and is(base = 16) then (prefix: "0x", digits: substring(digits, 3))
	elseif is(fmt = "C") then (prefix: "0b", digits: substring(digits, 3)),

	/* If already short enough. */
	if is(slength(digits) <= width) then return(sbasen_number),
    digits: substring(digits, 1, width + 1),

	return(stackbasen(sconcat(prefix, digits, suffix), fmt, base))
)$

s_test_case(simp) := is(sbasen_truncate_right(stackbasen("00000001_2","S",2),4)=stackbasen("0000_2","S",2))$


/**
 * Drops extra `0` digits from `stackbasen` objects that may have been padded
 * to match some "bit width". Works for all bases.
 *
 * @param[expression] expression, with possible stackbasen-objects to trim.
 * @return[expression] expression with the stackbasen-objects without extra
 *    leading zeros.
 */
sbasen_trim_padding(expression) := block([out, sub_ex, tmp, fmt, base, prefix, suffix, digits],
	out : expression,
	for sub_ex in extract_matching_parts(lambda([x],is(safe_op(x)="stackbasen")), expression) do (
		[digits,fmt,base]: args(sub_ex),

		suffix:"",
		prefix:"",
		if is(fmt = "S") then (suffix: sconcat("_", base), digits: split(digits, "_")[1])
		elseif is(fmt = "C") and is(base = 8) then (prefix: "0", digits: substring(digits, 2))
		elseif is(fmt = "C") and is(base = 16) then (prefix: "0x", digits: substring(digits, 3))
		elseif is(fmt = "C") then (prefix: "0b", digits: substring(digits, 3)),

		digits: striml("0", digits),
		if is(digits="") then digits: "0",

		tmp : stackbasen(sconcat(prefix, digits, suffix), fmt, base),
		out : subst(tmp, sub_ex, out)
	),
	return(out)
)$


s_test_case(simp) := is(sbasen_trim_padding(stackbasen("00000001_2","S",2))=stackbasen("1_2","S",2))$
s_test_case(simp) := is(sbasen_trim_padding(stackbasen("0000000","C",8))=stackbasen("00","C",8))$
s_test_case(simp) := is(sbasen_trim_padding(stackbasen("0b00000001","C",2)+stackbasen("0x0001","C",16))=stackbasen("0b1","C",2)+stackbasen("0x1","C",16))$