/**
 * A function to convert `stackbasen` objects back to normal base-10 numbers,
 * will find all `stackbasen` instances in the input and replaces them with
 * raw base-10 integers.
 *
 * Does not verify validity of those `stackbasen` objects, so might generate
 * interesting results.
 *
 * @param[expression] expression, an expression that might have 
 *    `stackbasen`-objects in it.
 * @return[expression] the original expression with all `stackbasen`-objects
 * converted to raw integers.
 */
sbasen_convert_to_base10(expression) := block([out, sub_ex, tmp, digits, ndx, base, digit],
	out : expression,
	for sub_ex in extract_matching_parts(lambda([x],is(safe_op(x)="stackbasen")), expression) do (
		tmp : 0,
		base : third(sub_ex),
		digits : sbasen_convert_to_digits_lsd(sub_ex),
		ndx : 0,
		for digit in digits do (
			tmp : ev(tmp + digit*(base^ndx),simp),
			ndx : ev(ndx + 1, simp)
		),
		out : subst(tmp, sub_ex, out)
	),
	return(out)
)$

s_test_case(simp) := ev(is(sbasen_convert_to_base10(stackbasen("PI_34","S",34)-stackbasen("PI_32","S",32))=50),simp)$
s_test_case(simp) := is(sbasen_convert_to_base10(stackbasen("Zzz_36","S",36))=46655)$


/**
 * A function to convert `stackbasen` objects into a list of digits
 * presented as base-10 numbers. With most significant digit first.
 * See `sbasen_convet_to_digits_lsd` for a variant with least significant
 * digit first.
 *
 * Does not verify validity of those `stackbasen` objects, so might generate
 * interesting results. If a digit does not fit the 0-9+A-Z range expect to
 * see `false` in the list.
 *
 * @param[stackbasen] sbasen_number, the `stackbasen`-object to turn to a digit
 *    list
 * @return[list] the digits interpereted as base-10 integers, most significant
 *    digit first
 */
sbasen_convert_to_digits(sbasen_number) := block([digits,fmt,base],
	[digits, fmt, base] : args(sbasen_number),
	digits : if is(fmt = "S") then split(digits, "_")[1]
	elseif is(fmt = "C") and is(base = 8) then substring(digits, 2)
	elseif is(fmt = "C") then substring(digits, 3),
	digits : map('sbasen_char_to_digit, charlist(digits)),
	return(digits)
)$

s_test_case(simp) := is(sbasen_convert_to_digits(stackbasen("0xA1","C",16))=[10,1])$
s_test_case(simp) := is(sbasen_convert_to_digits(stackbasen("0x00FF","C",16))=[0,0,15,15])$

/**
 * A function to convert `stackbasen` objects into a list of digits
 * presented as base-10 numbers. With least significant digit first.
 * See `sbasen_convet_to_digits` for a variant with most significant
 * digit first.
 *
 * Does not verify validity of those `stackbasen` objects, so might generate
 * interesting results. If a digit does not fit the 0-9+A-Z range expect to
 * see `false` in the list.
 *
 * @param[stackbasen] sbasen_number, the `stackbasen`-object to turn to a digit
 *    list
 * @return[list] the digits interpereted as base-10 integers, least significant
 *    digit first
 */
sbasen_convert_to_digits_lsd(sbasen_number) := block([digits,fmt,base],
	[digits, fmt, base] : args(sbasen_number),
	digits : if is(fmt = "S") then split(digits, "_")[1]
	elseif is(fmt = "C") and is(base = 8) then substring(digits, 2)
	elseif is(fmt = "C") then substring(digits, 3),
	digits : reverse(map('sbasen_char_to_digit, charlist(digits))),
	return(digits)
)$

s_test_case(simp) := is(sbasen_convert_to_digits_lsd(stackbasen("0xA1","C",16))=[1,10])$
s_test_case(simp) := is(sbasen_convert_to_digits_lsd(stackbasen("0x00FF","C",16))=[15,15,0,0])$


/**
 * Converts all `stackbasen` objects present in an expression to the suffix
 * notation. This should help when checking for equality but won't help
 * if values include padding, if that is the case you may need to use
 * `sbasen_trim_padding`.
 *
 * To avoid issues with different cases will recreate all `stackbasen` objects.
 * And remap the digits. For digits 10-35 will use ASCII letters and the case
 * will be defined by the option `sbasen_construct_default_case`, by default
 * uppercase letters will be used.
 *
 * @param[expression] expression, an expression that might have 
 *    `stackbasen`-objects in it.
 * @return[expression] the original expression with all `stackbasen`-objects
 * 	  converted to use "S"-format.
 */
sbasen_convert_to_suffix_notation(expression) := block([out, sub_ex, tmp, digits],
    /* @ignore[global=sbasen_construct_default_case] */
	out : expression,
	for sub_ex in extract_matching_parts(lambda([x],is(safe_op(x)="stackbasen")), expression) do (
		digits : sbasen_convert_to_digits(sub_ex),
		if is(sbasen_construct_default_case = "lower") then 
			digits : ev(map(lambda([n], charat("0123456789abcdefghijklmnopqrstuvwxyz", n+1)), digits),simp)
		else
			digits : ev(map(lambda([n], charat("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", n+1)), digits),simp),
		tmp : stackbasen(
			sconcat(simplode(digits),"_",third(sub_ex)),
			"S", third(sub_ex)
			), 
		out : subst(tmp, sub_ex, out)
	),
	return(out)
)$

s_test_case(simp) := is(sbasen_convert_to_suffix_notation(stackbasen("0x00FF","C",16))=stackbasen("00FF_16","S",16))$
s_test_case(simp) := is(sbasen_convert_to_suffix_notation(stackbasen("0b1","C",2)-stackbasen("11_2","S",2))=stackbasen("1_2","S",2)-stackbasen("11_2","S",2))$
s_test_case(simp) := ev(is(sbasen_convert_to_suffix_notation(stackbasen("0x00FF","C",16))=stackbasen("00ff_16","S",16)),sbasen_construct_default_case="lower")$
