/**
 * A function to convert `stackbasen` objects back to normal base-10 numbers,
 * will find all `stackbasen` instances in the input and replaces them with
 * raw base-10 integers.
 *
 * Does not verify validity of those `stackbasen` objects, so might generate
 * interesting results.
 *
 * @param[expression] expression, an expression that might have 
 *    `stackbasen`-objects in it.
 * @return[expression] the original expression with all `stackbasen`-objects
 * converted to raw integers.
 */
sbasen_convert_to_base10(expression) := block([out, sub_ex, tmp, digits, ndx, base, digit],
	out : expression,
	for sub_ex in extract_matching_parts(lambda([x],is(safe_op(x)="stackbasen")), expression) do (
		tmp : 0,
		base : third(sub_ex),
		digits : sbasen_convert_to_digits_lsd(sub_ex),
		ndx : 0,
		for digit in digits do (
			tmp : ev(tmp + digit*(base^ndx),simp),
			ndx : ev(ndx + 1, simp)
		),
		out : subst(tmp, sub_ex, out)
	),
	return(out)
)$

s_test_case(simp) := ev(is(sbasen_convert_to_base10(stackbasen("PI_34","S",34)-stackbasen("PI_32","S",32))=50),simp)$
s_test_case(simp) := is(sbasen_convert_to_base10(stackbasen("Zzz_36","S",36))=46655)$


/**
 * A function to convert `stackbasen` objects into a list of digits
 * presented as base-10 numbers. With most significant digit first.
 * See `sbasen_convet_to_digits_lsd` for a variant with least significant
 * digit first.
 *
 * Does not verify validity of those `stackbasen` objects, so might generate
 * interesting results. If a digit does not fit the 0-9+A-Z range expect to
 * see `false` in the list.
 *
 * @param[stackbasen] sbasen_number, the `stackbasen`-object to turn to a digit
 *    list
 * @return[list] the digits interpereted as base-10 integers, most significant
 *    digit first
 */
sbasen_convert_to_digits(sbasen_number) := block([digits,fmt,base],
	[digits, fmt, base] : args(sbasen_number),
	digits : if is(fmt = "S") then split(digits, "_")[1]
	elseif is(fmt = "C") and is(base = 8) then substring(digits, 2)
	elseif is(fmt = "C") then substring(digits, 3),
	digits : map('sbasen_char_to_digit, charlist(digits)),
	return(digits)
)$

s_test_case(simp) := is(sbasen_convert_to_digits(stackbasen("0xA1","C",16))=[10,1])$
s_test_case(simp) := is(sbasen_convert_to_digits(stackbasen("0x00FF","C",16))=[0,0,15,15])$

/**
 * A function to convert `stackbasen` objects into a list of digits
 * presented as base-10 numbers. With least significant digit first.
 * See `sbasen_convet_to_digits` for a variant with most significant
 * digit first.
 *
 * Does not verify validity of those `stackbasen` objects, so might generate
 * interesting results. If a digit does not fit the 0-9+A-Z range expect to
 * see `false` in the list.
 *
 * @param[stackbasen] sbasen_number, the `stackbasen`-object to turn to a digit
 *    list
 * @return[list] the digits interpereted as base-10 integers, least significant
 *    digit first
 */
sbasen_convert_to_digits_lsd(sbasen_number) := block([digits,fmt,base],
	[digits, fmt, base] : args(sbasen_number),
	digits : if is(fmt = "S") then split(digits, "_")[1]
	elseif is(fmt = "C") and is(base = 8) then substring(digits, 2)
	elseif is(fmt = "C") then substring(digits, 3),
	digits : reverse(map('sbasen_char_to_digit, charlist(digits))),
	return(digits)
)$

s_test_case(simp) := is(sbasen_convert_to_digits_lsd(stackbasen("0xA1","C",16))=[1,10])$
s_test_case(simp) := is(sbasen_convert_to_digits_lsd(stackbasen("0x00FF","C",16))=[15,15,0,0])$
